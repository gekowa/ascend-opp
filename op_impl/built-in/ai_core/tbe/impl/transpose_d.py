# Copyright 2019 Huawei Technologies Co., Ltd
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ============================================================================
"""
transpose_d
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import json
import operator
import os
from functools import reduce as functools_reduce

from te import platform as cce
from te.platform import insn_cmd
from te import tvm
from te.platform.cce_build import build_config
import te.platform.cce_params as cce_params
from te.utils.op_utils import *
from impl.hwc_2_chw import hwc_2_chw

# General limitation of the size for input shape: 2**31 - 1
SHAPE_SIZE_LIMIT = 2147483647
# available ub size
UB_SIZE_B = cce.cce_conf.get_soc_spec(cce.cce_conf.UB_SIZE)
# available number of cores
AICORE_NUM = cce.cce_conf.get_soc_spec(cce.cce_conf.CORE_NUM)


# pylint: disable=locally-disabled,too-many-lines
def _get_factor(ele_zero, ele_cnt, total_ele):
    """
    get split factor for _tilling_one_axis function

    Parameters
    ----------
    ele_zero: int
        the number of shape's first dimension elements
    ele_cnt: int
        the number of all elements
    total_ele: int
        the number of total elements in UB

    Returns
    -------
    split_factor: int
        the factor used when tiling the target axis
    """
    split_factor = 1
    for i in reversed(list(range(1, ele_zero))):
        if i*ele_cnt <= total_ele:
            split_factor = i
            break

    return split_factor


def _get_count_bigger_one(shape):
    """
    get the count of elements bigger than one

    """
    count = 0
    for item in shape:
        if item > 1:
            count += 1

    return count


def _tilling_axis_not_last(shape, dtype):
    """
    calculate the split parameters according to different shapes
    for last axis not changed

    Parameters
    ----------
    shape: tuple
        shape of tensor
    dtype: str
        the data type

    Returns
    -------
    split_axis: int
        the target axis that is used for tiling the tensor to find
    split_factor: int
        the factor used when tiling the target axis
    """
    ub_size_bytes = UB_SIZE_B - 1*1024
    # 8 bit = 1byte, '8' below for this reason
    dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
    # 32 means one block size(32 Bytes),
    # divide by 32 to get the numbers of data that
    # can be stored in one block.
    flag = 32 // dtype_bytes_size
    element_new = ((shape[-1] + flag - 1) // flag)*flag
    shape_new = []
    for i in shape:
        shape_new.append(i)
    shape_new[-1] = int(element_new)
    total_ele = ub_size_bytes // dtype_bytes_size
    split_axis = 0
    split_factor = 1

    for i, item in enumerate(shape):
        ele_cnt = functools_reduce(lambda x, y: x*y, shape_new[i:])
        if ele_cnt <= total_ele:
            split_axis = i - 1
            split_factor = total_ele // ele_cnt
            break
        elif i == len(shape) - 1:
            if len(shape) == 1:
                split_axis = 0
                split_factor = _get_factor(shape[0], 1, total_ele)
            else:
                split_axis = i
                split_factor = total_ele
            break

    if split_axis < 0:
        split_axis = 0
        split_factor = shape[0]

    if shape[len(shape) - 1] == 1:
        count = _get_count_bigger_one(shape)
        if count > 1:
            for i, item in enumerate(reversed(shape)):
                if item > 1:
                    flag = i
                    break
            if split_axis != len(shape) - flag - 1:
                split_axis = len(shape) - flag - 1
                split_factor = shape[split_axis]

    return split_axis, split_factor


def _tilling_axis_last(shape, dtype):
    """
    calculate the split parameters according to different shapes
    for last axis changed

    Parameters
    ----------
    shape: tuple
        shape of tensor
    dtype: str
        the data type

    Returns
    -------
    split_axis: int
        the target axis that is used for tiling the tensor to find
    split_factor: int
        the factor used when tiling the target axis
    """
    ub_size_bytes = UB_SIZE_B - 1*1024
    dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
    dtype_bytes_size_fp16 = cce.cce_intrin.get_bit_len("float16") // 8
    if dtype == "float16" or dtype == "int16" or dtype == "uint16":
        total_ele = ub_size_bytes // dtype_bytes_size
    elif dtype == "int8" or dtype == "uint8"\
            or dtype == "int32" or dtype == "float32":
        total_ele = ub_size_bytes // (dtype_bytes_size + dtype_bytes_size_fp16)

    flag = 32 // dtype_bytes_size
    element_new = ((shape[-1] + flag - 1) // flag)*flag
    shape_new = []
    for i in shape:
        shape_new.append(i)
    shape_new[-1] = int(element_new)
    split_axis = 0
    split_factor = 1

    for i, _ in enumerate(shape):
        ele_cnt = functools_reduce(lambda x, y: x*y, shape_new[i:])
        if ele_cnt <= total_ele:
            split_axis = i - 1
            split_factor = total_ele // ele_cnt
            break
        elif i == len(shape) - 1:
            split_axis = i
            split_factor = total_ele
            break

    if split_axis < 0:
        split_axis = 0
        split_factor = shape[0]

    return split_axis, split_factor


def _get_factor_multi_core(ele_zero, ele_cnt, total_ele, no_remainder):
    """
    get split factor for _tilling_axis_multi_core function

    Parameters
    ----------
    ele_zero: int
        the number of shape's first dimension elements
    ele_cnt: int
        the number of all elements
    total_ele: int
        the number of total elements in UB
    no_remainder: bool
        when split_axis == 0,
        the value of shape[0] whether divided by split_factor without remainder.

    Returns
    -------
    split_factor: int
        the factor used when tiling the target axis
    """
    split_factor = 1
    if no_remainder:
        for i in reversed(list(range(1, ele_zero))):
            if ele_zero % i == 0 and i*ele_cnt <= total_ele:
                split_factor = i
                break
    else:
        for i in reversed(list(range(1, ele_zero))):
            if i*ele_cnt <= total_ele:
                split_factor = i
                break

    return split_factor


# pylint: disable=locally-disabled, too-many-locals, too-many-branches
def _tilling_axis_multi_core_fuse(shape, dtype):
    """
    calculate the split parameters according to different shapes
     for multi core scene

    Parameters
    ----------
    shape: tuple
        shape of tensor
    dtype: str
        the data type

    Returns
    -------
    split_axis: int
        the target axis that is used for tiling the tensor to find
    split_factor: int
        the factor used when tiling the target axis
    """
    ub_size_bytes = UB_SIZE_B - 1*1024
    dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
    flag = 32 // dtype_bytes_size
    element_new = ((shape[-1] + flag - 1) // flag)*flag
    shape_new = []
    for i in shape:
        shape_new.append(i)
    shape_new[-1] = int(element_new)

    total_ele = ub_size_bytes // dtype_bytes_size
    split_axis = 0
    split_factor = 1

    for i, _ in enumerate(shape):
        ele_cnt = functools_reduce(lambda x, y: x*y, shape_new[i:])
        if ele_cnt <= total_ele:
            split_axis = i - 1
            split_factor = total_ele // ele_cnt
            if split_axis >= 0:
                for j in reversed(list(range(1, split_factor))):
                    if shape[split_axis] % j == 0:
                        split_factor = j
                        break
            break
        elif i == len(shape) - 1:
            split_axis = i
            split_factor = total_ele

    if split_axis < 0:
        split_axis = 0
        split_factor = shape[0]

    device_core_num = AICORE_NUM
    shape_ele = functools_reduce(lambda x, y: x * y, shape[:])
    if split_axis == 0 and split_factor == shape[0] and device_core_num >= 2\
            and shape_ele >= (2 * flag):
        if shape[0] >= (2 * flag):
            split_factor = shape[0] // 2
        elif len(shape) >= 2:
            loc_more = len(shape) - 1
            for i, value in enumerate(shape):
                if value >= 2:
                    loc_more = i
                    break
            current_ele = functools_reduce(lambda x, y: x * y, shape[loc_more:])
            if current_ele >= (2 * flag):
                split_axis = loc_more
                split_factor = shape[split_axis] // 2

    return split_axis, split_factor


def _get_perm_shape(shape, perm):
    """
    get new shape of transposed tensor

    Parameters
    ----------
    shape: list or tuple
        shape of tensor
    perm: list or tuple
        the data type

    Returns
    -------
    shape_new_tuple: tuple
        the new shape of transposed tensor
    """
    shape_new = []
    for i in perm:
        shape_new.append(shape[i])

    return shape_new


def _check_params(shape, perm, dtype):
    """
    check the parameters including shape, perm, dtype and kernel_name

    Parameters
    ----------
    shape: list or tuple
        shape of tensor
    perm: list or tuple
        permutation of the dimension of tensor
    dtype: str
        the data type

    Returns
    -------
    None
    """
    check_shape(shape, param_name="input_x")
    len_shape = len(shape)
    if len(shape) != len(perm):
        raise RuntimeError(
            "length of perm must be equal to the length of shape")

    list_range = list(range(len_shape))
    list_perm = list(perm[:])
    list_perm.sort()
    if operator.ne(list_range, list_perm):
        raise RuntimeError("value of perm is wrong")

    check_list = ("int8", "int16", "int32", "int64",
                  "uint8", "uint16", "uint32", "uint64",
                  "float16", "float32")
    check_dtype(dtype, check_list, param_name="input_x")


def _add_last_axis(shape, perm, dtype):
    """
    check whether the last axis needs to be added

    """
    len_shape = len(shape)
    if perm[len_shape - 1] != len_shape - 1:
        if dtype == "int64" or dtype == "uint32" or dtype == "uint64"\
                or dtype == "float32" or dtype == "int32":
            return True
        elif dtype == "int8" or dtype == "uint8":
            if shape[len_shape - 1] % 32 != 0:
                return True
        elif shape[len_shape - 1] % 16 != 0:
            return True

        shape_res = _get_perm_shape(shape, perm)
        if shape_res[len_shape - 1] % 16 != 0:
            return True

    return False


def _write_code(wkspace_dict, fname):
    """
    write workspaces to json file

    """
    fname = os.path.realpath(fname)
    if fname.startswith(os.getcwd()):
        if os.path.exists(fname):
            with open(fname, "r") as f_var:
                load_dict = json.load(f_var)
            load_dict.update(wkspace_dict)
            with open(fname, "w") as f_var:
                json.dump(load_dict, f_var, sort_keys=True,
                          indent=4, separators=(',', ':'))


def _get_perm_one(perm):
    """
    get the perm of first stage for transpose the last axis scene

    """
    perm_new = []
    perm_len = len(perm)
    dst_num = perm[perm_len - 1]
    dst_idx = perm_len - 2
    for i in range(perm_len):
        if i == dst_num:
            perm_new.append(dst_idx)
        elif i == dst_idx:
            perm_new.append(dst_num)
        else:
            perm_new.append(i)

    return perm_new


def _get_shape_two(shape):
    """
    get the shape of second stage for transpose the last axis scene

    """
    last = len(shape) - 1
    sec = last - 1
    shape_new = []
    for i, item in enumerate(shape):
        if i == sec:
            shape_new.append(shape[last])
        elif i == last:
            shape_new.append(shape[sec])
        else:
            shape_new.append(item)

    return shape_new


def _get_perm_three(perm_two, perm_res):
    """
    get the perm of third stage for transpose the last axis scene

    """
    perm_new = []
    for item_res in perm_res:
        res = -1
        for i, item in enumerate(perm_two):
            if item == item_res:
                res = i
                break
        perm_new.append(res)

    return perm_new


def _perm_to_flag(perm):
    """
    get the flag for permutation according to perm

    """
    flag = [i for i in perm]
    for i, item in enumerate(perm):
        flag[item] = i

    return flag


def _is_perm_change(perm):
    """
    whether the shape changes according to perm

    """
    length = len(perm)
    list_range = list(range(length))
    list_perm = list(perm[:])
    if operator.ne(list_range, list_perm):
        return True

    return False


def _get_align_axis(out_shape):
    """
    get the axis_info when applying the align

    """
    flag = -1
    if out_shape[-1] != 1:
        axis = len(out_shape) - 2
    else:
        for i, item in enumerate(reversed(out_shape)):
            if item > 1:
                flag = i
                break
        if flag == -1 or flag == 0:
            axis = 0
        else:
            axis = len(out_shape) - flag - 1

    return axis


def _new_alloc(tvm_ib, dtype, shape, name, scope):
    """
    decl new buffer

    Parameters
    ----------
    tvm_ib : tvm.ir_builder
        Developer API of IR node builder make function
    dtype : str
        buffer date type
    shape : int
        buffer shape
    name : str
        buffer name
    scope : str
        buffer memory scope

    Returns
    -------
    new_buffer : tvm.schedule.Buffer
        Symbolic data buffer
    """
    buf_var = tvm_ib.allocate(dtype, shape, name=name, scope=scope)
    new_buffer = tvm.decl_buffer(shape, buf_var.dtype, name=name,
                                 scope=scope, data=buf_var)

    return new_buffer


def _get_params_for_multi_group_ir(tvm_ib, shape, dtype):
    """
    calculate parameters for multi group permute_ir

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    col_len = shape[len(shape) - 2]
    row_len = shape[len(shape) - 1]
    block_row_len = row_len // 16
    block_col_len = col_len // 16
    block_size = 16*16*float_size
    ub_block_num = UB_SIZE_B // 2 // block_size
    index_size = 1
    for i, item in enumerate(shape):
        if i < (len(shape) - 2):
            index_size *= item

    # available bytes in UB
    data_ub_size = ub_block_num*block_size
    # elements in two dim shape
    two_dim = col_len*row_len
    # bytes in two dim shape
    two_dim_bytes = col_len*row_len*float_size
    # two dim shapes in UB
    num_two_dim_one_ub = data_ub_size // two_dim_bytes
    all_core_size = num_two_dim_one_ub*two_dim_bytes*device_core_num
    all_core_offset = num_two_dim_one_ub*two_dim*device_core_num
    actual_one_core_ele = num_two_dim_one_ub*two_dim
    actual_one_core_block = actual_one_core_ele // 256
    num_all_two_dim = index_size*two_dim // 256
    num_block_one_group = device_core_num*num_two_dim_one_ub*two_dim // 256
    data_size = index_size*two_dim_bytes
    num_group_index = data_size // all_core_size
    num_group_mod = data_size % all_core_size

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {'block_row_len': block_row_len, 'two_dim': two_dim,
                 'index_size': index_size,
                 'float_size': float_size, 'col_len': col_len,
                 'row_len': row_len,
                 'num_two_dim_one_ub': num_two_dim_one_ub,
                 'all_core_offset': all_core_offset,
                 'block_index': block_index, 'block_col_len': block_col_len,
                 'num_group_mod': num_group_mod,
                 'actual_one_core_ele': actual_one_core_ele,
                 'actual_one_core_block': actual_one_core_block,
                 'num_all_two_dim': num_all_two_dim,
                 'device_core_num': device_core_num,
                 'num_group_index': num_group_index,
                 'num_block_one_group': num_block_one_group}

    return param_map


def _get_params_for_multi_row_ir(tvm_ib, shape, dtype):
    """
    calculate parameters for multi row permute_ir

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    col_len = shape[len(shape) - 2]
    row_len = shape[len(shape) - 1]
    block_row_len = row_len // 16
    block_col_len = col_len // 16
    block_size = 16*16*float_size
    ub_block_num = UB_SIZE_B // 2 // block_size
    index_size = 1
    for i, item in enumerate(shape):
        if i < (len(shape) - 2):
            index_size *= item

    # available bytes in UB
    data_ub_size = ub_block_num*block_size
    # elements in two dim shape
    two_dim = col_len*row_len
    # bytes in two dim shape
    two_dim_bytes = col_len*row_len*float_size
    # two dim shapes in UB
    num_two_dim_one_ub = data_ub_size // two_dim_bytes
    block_row_len_bytes = 16*row_len*float_size
    # number of block row in one core
    num_block_row_one_core = data_ub_size // block_row_len_bytes
    # number of block row in data
    all_block_row_in_data = index_size*block_col_len
    # number of block row in one group
    num_block_row_one_group = num_block_row_one_core*device_core_num
    num_group_more_row_index = all_block_row_in_data // num_block_row_one_group
    num_group_more_row_mod = all_block_row_in_data % num_block_row_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {'block_row_len': block_row_len, 'float_size': float_size,
                 'two_dim': two_dim,
                 'index_size': index_size, 'col_len': col_len,
                 'row_len': row_len,
                 'num_two_dim_one_ub': num_two_dim_one_ub,
                 'block_index': block_index,
                 'block_col_len': block_col_len,
                 'device_core_num': device_core_num,
                 'num_block_row_one_core': num_block_row_one_core,
                 'num_group_more_row_index': num_group_more_row_index,
                 'num_block_row_one_group': num_block_row_one_group,
                 'num_group_more_row_mod': num_group_more_row_mod}

    return param_map


def _get_params_for_split_row_ir(tvm_ib, shape, dtype):
    """
    calculate parameters for split row permute_ir

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    col_len = shape[len(shape) - 2]
    row_len = shape[len(shape) - 1]
    block_row_len = row_len // 16
    block_col_len = col_len // 16
    block_size = 16*16*float_size
    ub_block_num = UB_SIZE_B // 2 // block_size
    index_size = 1
    for i, item in enumerate(shape):
        if i < (len(shape) - 2):
            index_size *= item

    # available bytes in one ub
    data_ub_size = ub_block_num*block_size
    # elements in two dim shape
    two_dim = col_len*row_len
    # bytes in two dim shape
    two_dim_bytes = col_len*row_len*float_size
    # number of block in two dim shape
    num_block_in_two_dim = two_dim // 256
    # number of two dim shapes in UB
    num_two_dim_one_ub = data_ub_size // two_dim_bytes
    # number of 16*16 block in one core
    num_block256_one_core = data_ub_size // (256*float_size)
    # number of 16*16 block in one group
    num_block256_one_group = num_block256_one_core*device_core_num
    # number of 16*16 block in data
    num_block256_in_data = index_size*two_dim // 256
    num_group_split_row_index = num_block256_in_data // num_block256_one_group
    num_group_split_row_mod = num_block256_in_data % num_block256_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {'block_row_len': block_row_len, 'float_size': float_size,
                 'two_dim': two_dim,
                 'index_size': index_size, 'col_len': col_len,
                 'row_len': row_len,
                 'num_two_dim_one_ub': num_two_dim_one_ub,
                 'block_index': block_index,
                 'block_col_len': block_col_len,
                 'device_core_num': device_core_num,
                 'num_block_in_two_dim': num_block_in_two_dim,
                 'num_block256_one_core': num_block256_one_core,
                 'num_block256_one_group': num_block256_one_group,
                 'num_group_split_row_index': num_group_split_row_index,
                 'num_group_split_row_mod': num_group_split_row_mod}

    return param_map


# pylint: disable=locally-disabled, too-many-statements
def _multi_core_split_row_ir(dst, data, ir_type):
    """
    function of make ir node builder to transpose last two axes
     for split row in one UB scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_params_for_split_row_ir(tvm_ib, data.shape, data.dtype)
    data_ub = _new_alloc(tvm_ib, "uint16_t",
                         param.get('num_block256_one_core')*256,
                         "data_ub", scope=cce.scope_ubuf)
    data_ub_trans = _new_alloc(tvm_ib, "uint16_t",
                               param.get('num_block256_one_core')*256,
                               "data_ub", scope=cce.scope_ubuf)

    with tvm_ib.for_range(0, param.get('num_group_split_row_index'),
                          name='num_g_sr') as num_g_sr:
        with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                              name='num_b_c') as num_b_c:
            block256_index = num_g_sr*param.get('num_block256_one_group')\
                             + param.get('block_index')\
                             * param.get('num_block256_one_core') + num_b_c
            two_dim_index = block256_index // param.get('num_block_in_two_dim')
            two_dim_mod = block256_index % param.get('num_block_in_two_dim')
            block_col_len_index = two_dim_mod // param.get('block_row_len')
            block_row_len_index = two_dim_mod % param.get('block_row_len')
            tvm_ib.emit(tvm.call_extern(data.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=(num_b_c*256)),
                                        data.access_ptr(
                                            'r',
                                            offset=(two_dim_index
                                                    * param.get('two_dim')
                                                    + block_col_len_index
                                                    * param.get('row_len')*16
                                                    + block_row_len_index*16)),
                                        0, 16,
                                        ((16*param.get('float_size')) // 32),
                                        (((param.get('row_len') - 16)
                                          * param.get('float_size')) // 32), 0))
        with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                              name='num_v') as num_v:
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "vtranspose",
                                        data_ub_trans.access_ptr(
                                            "rw", offset=(256*num_v)),
                                        data_ub.access_ptr(
                                            "r", offset=(256*num_v))))
        with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                              name='num_b_c') as num_b_c:
            block256_index = num_g_sr*param.get('num_block256_one_group')\
                             + param.get('block_index')\
                             * param.get('num_block256_one_core') + num_b_c
            two_dim_index = block256_index // param.get('num_block_in_two_dim')
            two_dim_mod = block256_index % param.get('num_block_in_two_dim')
            block_col_len_index = two_dim_mod // param.get('block_row_len')
            block_row_len_index = two_dim_mod % param.get('block_row_len')
            tvm_ib.emit(tvm.call_extern(ir_type, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=(two_dim_index
                                                    * param.get('two_dim')
                                                    + block_row_len_index
                                                    * param.get('col_len')*16
                                                    + block_col_len_index*16)),
                                        data_ub_trans.access_ptr(
                                            "r", offset=(num_b_c*256)),
                                        0, 16,
                                        ((16*param.get('float_size')) // 32),
                                        0, (((param.get('col_len') - 16)
                                             * param.get('float_size')) // 32)))
    with tvm_ib.if_scope(param.get('num_group_split_row_mod') > 0):
        num_core_split_row_index = param.get('num_group_split_row_mod') \
                                   // param.get('num_block256_one_core')
        num_core_split_row_mod = param.get('num_group_split_row_mod')\
                                 % param.get('num_block256_one_core')
        with tvm_ib.if_scope(num_core_split_row_index > 0):
            with tvm_ib.if_scope(param.get('block_index').var
                                 < num_core_split_row_index):
                with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                                      name='num_b_c') as num_b_c:
                    block256_index = param.get('num_group_split_row_index')\
                                     * param.get('num_block256_one_group')\
                                     + param.get('block_index')\
                                     * param.get('num_block256_one_core')\
                                     + num_b_c
                    two_dim_index = block256_index\
                                    // param.get('num_block_in_two_dim')
                    two_dim_mod = block256_index\
                                  % param.get('num_block_in_two_dim')
                    block_col_len_index = two_dim_mod\
                                          // param.get('block_row_len')
                    block_row_len_index = two_dim_mod\
                                          % param.get('block_row_len')
                    tvm_ib.emit(
                        tvm.call_extern(
                            data.dtype, "copy_gm_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=(num_b_c*256)),
                            data.access_ptr(
                                'r',
                                offset=(two_dim_index
                                        * param.get('two_dim')
                                        + block_col_len_index
                                        * param.get('row_len')*16
                                        + block_row_len_index*16)),
                            0, 16, ((16*param.get('float_size')) // 32),
                            (((param.get('row_len') - 16)
                              * param.get('float_size')) // 32), 0))
                with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                                      name='num_vtrans') as num_vtrans:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data_ub.dtype, "vtranspose",
                            data_ub_trans.access_ptr(
                                "rw", offset=(256*num_vtrans)),
                            data_ub.access_ptr("r", offset=(256*num_vtrans))))
                with tvm_ib.for_range(0, param.get('num_block256_one_core'),
                                      name='num_b_c') as num_b_c:
                    block256_index = param.get('num_group_split_row_index')\
                                     * param.get('num_block256_one_group') \
                                     + param.get('block_index')\
                                     * param.get('num_block256_one_core')\
                                     + num_b_c
                    two_dim_index = block256_index\
                                    // param.get('num_block_in_two_dim')
                    two_dim_mod = block256_index\
                                  % param.get('num_block_in_two_dim')
                    block_col_len_index = two_dim_mod\
                                          // param.get('block_row_len')
                    block_row_len_index = two_dim_mod\
                                          % param.get('block_row_len')
                    tvm_ib.emit(
                        tvm.call_extern(
                            ir_type, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=(two_dim_index
                                        * param.get('two_dim')
                                        + block_row_len_index
                                        * param.get('col_len')*16
                                        + block_col_len_index*16)),
                            data_ub_trans.access_ptr(
                                "r", offset=(num_b_c * 256)),
                            0, 16, ((16*param.get('float_size')) // 32),
                            0, (((param.get('col_len') - 16)
                                 * param.get('float_size')) // 32)))
        with tvm_ib.if_scope(tvm.all(param.get('block_index')
                                     < (num_core_split_row_index + 1),
                                     param.get('block_index')
                                     > (num_core_split_row_index - 1))):
            with tvm_ib.for_range(0, num_core_split_row_mod, name='num_b_c')\
                    as num_b_c:
                block256_offset = param.get('num_group_split_row_index')\
                                  * param.get('num_block256_one_group')\
                                 + param.get('block_index')\
                                  * param.get('num_block256_one_core')
                block256_index = block256_offset + num_b_c
                two_dim_index = block256_index\
                                // param.get('num_block_in_two_dim')
                two_dim_mod = block256_index % param.get('num_block_in_two_dim')
                block_col_len_index = two_dim_mod // param.get('block_row_len')
                block_row_len_index = two_dim_mod % param.get('block_row_len')
                tvm_ib.emit(
                    tvm.call_extern(
                        data.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr("w", offset=(num_b_c*256)),
                        data.access_ptr(
                            'r',
                            offset=(two_dim_index
                                    * param.get('two_dim')
                                    + block_col_len_index
                                    * param.get('row_len')*16
                                    + block_row_len_index*16)),
                        0, 16, ((16*param.get('float_size')) // 32),
                        (((param.get('row_len') - 16)
                          * param.get('float_size')) // 32), 0))
            with tvm_ib.for_range(0, num_core_split_row_mod,
                                  name='num_vtrans') as num_vtrans:
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "vtranspose",
                        data_ub_trans.access_ptr(
                            "rw", offset=(256*num_vtrans)),
                        data_ub.access_ptr("r", offset=(256*num_vtrans))))
            with tvm_ib.for_range(0, num_core_split_row_mod,
                                  name='num_b_c') as num_b_c:
                block256_index = param.get('num_group_split_row_index')\
                                 * param.get('num_block256_one_group') \
                                 + param.get('block_index')\
                                 * param.get('num_block256_one_core')\
                                 + num_b_c
                two_dim_index = block256_index\
                                // param.get('num_block_in_two_dim')
                two_dim_mod = block256_index\
                              % param.get('num_block_in_two_dim')
                block_col_len_index = two_dim_mod // param.get('block_row_len')
                block_row_len_index = two_dim_mod % param.get('block_row_len')
                tvm_ib.emit(
                    tvm.call_extern(
                        ir_type, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w',
                            offset=(two_dim_index * param.get('two_dim')
                                    + block_row_len_index
                                    * param.get('col_len')*16
                                    + block_col_len_index*16)),
                        data_ub_trans.access_ptr("r", offset=(num_b_c*256)),
                        0, 16, ((16*param.get('float_size')) // 32),
                        0, (((param.get('col_len') - 16)
                             * param.get('float_size')) // 32)))

    return tvm_ib.get()


def _multi_core_more_row_ir(dst, data, ir_type):
    """
    function of make ir node builder to transpose last two axes
     for multi row in one UB scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_params_for_multi_row_ir(tvm_ib, data.shape, data.dtype)
    data_ub = _new_alloc(tvm_ib, "uint16_t",
                         param.get('num_block_row_one_core')
                         * param.get('row_len') * 16,
                         "data_ub", scope=cce.scope_ubuf)
    data_ub_trans = _new_alloc(tvm_ib, "uint16_t",
                               param.get('num_block_row_one_core')
                               * param.get('row_len') * 16, "data_ub_trans",
                               scope=cce.scope_ubuf)

    with tvm_ib.for_range(0, param.get('num_group_more_row_index'),
                          name='num_g_i') as num_g_i:
        with tvm_ib.for_range(0, param.get('num_block_row_one_core'),
                              name='num_b_c') as num_b_c:
            with tvm_ib.for_range(0, param.get('block_row_len'),
                                  name='num_b_r') as num_b_r:
                tvm_ib.emit(
                    tvm.call_extern(
                        data.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr(
                            "w",
                            offset=(num_b_c*param.get('row_len') * 16
                                    + num_b_r*256)),
                        data.access_ptr(
                            'r',
                            offset=(num_g_i
                                    * param.get('num_block_row_one_group')
                                    * param.get('row_len')*16
                                    + param.get('block_index')
                                    * param.get('num_block_row_one_core')
                                    * param.get('row_len')*16
                                    + num_b_c*param.get('row_len')
                                    * 16 + num_b_r * 16)),
                        0, 16, ((16*param.get('float_size')) // 32),
                        (((param.get('row_len') - 16)
                          * param.get('float_size')) // 32), 0))

        with tvm_ib.for_range(0, param.get('num_block_row_one_core')
                              * param.get('block_row_len'),
                              name='num_vtrans') as num_vtrans:
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "vtranspose",
                                        data_ub_trans.access_ptr(
                                            "rw", offset=(256*num_vtrans)),
                                        data_ub.access_ptr(
                                            "r", offset=(256*num_vtrans))))
        with tvm_ib.for_range(0, param.get('num_block_row_one_core'),
                              name='num_b_c') as num_b_c:
            block_row_index = num_g_i * param.get('num_block_row_one_group')\
                              + param.get('block_index')\
                              * param.get('num_block_row_one_core')\
                              + num_b_c
            two_dim_index = block_row_index // param.get('block_col_len')
            block_row_index_in_two_dim = block_row_index\
                                         % param.get('block_col_len')
            tvm_ib.emit(
                tvm.call_extern(
                    ir_type, "copy_ubuf_to_gm",
                    dst.access_ptr(
                        'w',
                        offset=(two_dim_index * param.get('two_dim')
                                + block_row_index_in_two_dim * 16)),
                    data_ub_trans.access_ptr(
                        "r",
                        offset=(num_b_c * param.get('row_len')*16)),
                    0, param.get('row_len'),
                    ((16*param.get('float_size')) // 32),
                    0, (((param.get('col_len') - 16)
                         * param.get('float_size')) // 32)))
    with tvm_ib.if_scope(param.get('num_group_more_row_mod') > 0):
        num_mod_core_index = param.get('num_group_more_row_mod') \
                             // param.get('num_block_row_one_core')
        num_mod_core_mod = param.get('num_group_more_row_mod') \
                             % param.get('num_block_row_one_core')
        with tvm_ib.if_scope(num_mod_core_index > 0):
            with tvm_ib.if_scope(param.get('block_index').var
                                 < num_mod_core_index):
                with tvm_ib.for_range(0, param.get('num_block_row_one_core'),
                                      name='num_b_c') as num_b_c:
                    with tvm_ib.for_range(0, param.get('block_row_len'),
                                          name='num_b_r') as num_b_r:
                        tvm_ib.emit(
                            tvm.call_extern(
                                data.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w",
                                    offset=(num_b_c * param.get('row_len')
                                            * 16 + num_b_r*256)),
                                data.access_ptr(
                                    'r',
                                    offset=(param.get(
                                        'num_group_more_row_index')
                                            * param.get('num_block_'
                                                        'row_one_group')
                                            * param.get('row_len') * 16
                                            + param.get('block_index')
                                            * param.get('num_block_'
                                                        'row_one_core')
                                            * param.get('row_len')*16
                                            + num_b_c
                                            * param.get('row_len')*16
                                            + num_b_r * 16)),
                                0, 16, ((16*param.get('float_size')) // 32),
                                (((param.get('row_len') - 16)
                                  * param.get('float_size')) // 32), 0))
                with tvm_ib.for_range(0, param.get('num_block_row_one_core')
                                      * param.get('block_row_len'),
                                      name='num_vtrans') as num_vtrans:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data_ub.dtype, "vtranspose",
                            data_ub_trans.access_ptr(
                                "rw", offset=(256*num_vtrans)),
                            data_ub.access_ptr("r", offset=(256*num_vtrans))))
                with tvm_ib.for_range(0, param.get('num_block_row_one_core'),
                                      name='num_b_c') as num_b_c:
                    block_row_index = param.get('num_group_more_row_index')\
                                      * param.get('num_block_row_one_group')\
                                      + param.get('block_index')\
                                      * param.get('num_block_row_one_core')\
                                      + num_b_c
                    two_dim_index = block_row_index\
                                    // param.get('block_col_len')
                    block_row_index_in_two_dim = block_row_index\
                                                 % param.get('block_col_len')
                    tvm_ib.emit(
                        tvm.call_extern(
                            ir_type, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=(two_dim_index
                                        * param.get('two_dim')
                                        + block_row_index_in_two_dim
                                        * 16)),
                            data_ub_trans.access_ptr(
                                "r", offset=(num_b_c * param.get('row_len')
                                             * 16)),
                            0, param.get('row_len'),
                            ((16*param.get('float_size')) // 32),
                            0, (((param.get('col_len') - 16)
                                 * param.get('float_size')) // 32)))
        with tvm_ib.if_scope(tvm.all(param.get('block_index').var
                                     < (num_mod_core_index + 1),
                                     param.get('block_index').var
                                     > (num_mod_core_index - 1))):
            with tvm_ib.for_range(0, num_mod_core_mod, name='num_b_c')\
                    as num_b_c:
                with tvm_ib.for_range(0, param.get('block_row_len'),
                                      name='num_b_r') as num_b_r:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data.dtype, "copy_gm_to_ubuf",
                            data_ub.access_ptr(
                                "w",
                                offset=(num_b_c * param.get('row_len')*16
                                        + num_b_r*256)),
                            data.access_ptr(
                                'r',
                                offset=(param.get('num_group_more_row_index')
                                        * param.get('num_block_row_one_group')
                                        * param.get('row_len') * 16
                                        + param.get('block_index')
                                        * param.get('num_block_row_one_core')
                                        * param.get('row_len') * 16
                                        + num_b_c * param.get('row_len') * 16
                                        + num_b_r*16)),
                            0, 16, ((16*param.get('float_size')) // 32),
                            (((param.get('row_len') - 16)
                              * param.get('float_size')) // 32), 0))
            with tvm_ib.for_range(0, num_mod_core_mod
                                  * param.get('block_row_len'),
                                  name='num_vtrans') as num_vtrans:
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "vtranspose",
                        data_ub_trans.access_ptr(
                            "rw", offset=(256*num_vtrans)),
                        data_ub.access_ptr("r", offset=(256*num_vtrans))))
            with tvm_ib.for_range(0, num_mod_core_mod, name='num_b_c')\
                    as num_b_c:
                block_row_index = param.get('num_group_more_row_index')\
                                  * param.get('num_block_row_one_group') \
                                  + param.get('block_index')\
                                  * param.get('num_block_row_one_core')\
                                  + num_b_c
                two_dim_index = block_row_index // param.get('block_col_len')
                block_row_index_in_two_dim = block_row_index\
                                             % param.get('block_col_len')
                tvm_ib.emit(
                    tvm.call_extern(
                        ir_type, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w',
                            offset=(two_dim_index * param.get('two_dim')
                                    + block_row_index_in_two_dim * 16)),
                        data_ub_trans.access_ptr(
                            "r",
                            offset=(num_b_c * param.get('row_len') * 16)),
                        0, param.get('row_len'),
                        ((16*param.get('float_size')) // 32),
                        0, (((param.get('col_len') - 16)
                             * param.get('float_size')) // 32)))

    return tvm_ib.get()


def _multi_core_more_group_ir(dst, data, ir_type):
    """
    function of make ir node builder to transpose last two axes
     for multi group in one UB scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_params_for_multi_group_ir(tvm_ib, data.shape, data.dtype)
    data_ub = _new_alloc(tvm_ib, "uint16_t", param.get('actual_one_core_ele'),
                         "data_ub", scope=cce.scope_ubuf)
    data_ub_trans = _new_alloc(tvm_ib, "uint16_t",
                               param.get('actual_one_core_ele'),
                               "data_ub_trans", scope=cce.scope_ubuf)

    with tvm_ib.for_range(0, param.get('num_group_index'), name='num_g')\
            as num_g:
        with tvm_ib.for_range(0, param.get('num_two_dim_one_ub'),
                              name='num_b') as num_b:
            with tvm_ib.for_range(0, param.get('block_row_len'),
                                  name='num_br') as num_br:
                tvm_ib.emit(
                    tvm.call_extern(
                        data.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr(
                            "w",
                            offset=(num_b * param.get('two_dim')
                                    + num_br * 16 * param.get('col_len'))),
                        data.access_ptr(
                            'r',
                            offset=(num_g * param.get('all_core_offset')
                                    + param.get("block_index")
                                    * param.get('actual_one_core_ele')
                                    + num_b*param.get('two_dim')
                                    + num_br*16)),
                        0, param.get('col_len'),
                        ((16*param.get('float_size')) // 32),
                        (((param.get('row_len') - 16)
                          * param.get('float_size')) // 32), 0))
        with tvm_ib.for_range(0, param.get('actual_one_core_block'),
                              name='num_b_core') as num_b_core:
            tvm_ib.emit(
                tvm.call_extern(
                    data_ub.dtype, "vtranspose",
                    data_ub_trans.access_ptr("rw", offset=(256*num_b_core)),
                    data_ub.access_ptr("r", offset=(256*num_b_core))))
        with tvm_ib.for_range(0, param.get('num_two_dim_one_ub'),
                              name='num_b') as num_b:
            with tvm_ib.for_range(0, param.get('block_row_len'),
                                  name='num_br') as num_br:
                with tvm_ib.for_range(0, 16, name='i') as i:
                    tvm_ib.emit(
                        tvm.call_extern(
                            ir_type, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=(num_g * param.get('all_core_offset')
                                        + param.get("block_index")
                                        * param.get('actual_one_core_ele')
                                        + num_b * param.get('two_dim')
                                        + num_br * 16 * param.get('col_len')
                                        + 16*param.get('block_col_len')*i)),
                            data_ub_trans.access_ptr(
                                "r",
                                offset=(num_b * param.get('two_dim')
                                        + num_br * 16 * param.get('col_len')
                                        + 16 * i)),
                            0, param.get('block_col_len'),
                            ((16*param.get('float_size')) // 32),
                            ((15*16*param.get('float_size')) // 32), 0))

    with tvm_ib.if_scope(param.get('num_group_mod') > 0):
        tail_block_num_index = param.get('index_size')\
                               - (param.get('num_group_index'))\
                               * param.get('device_core_num')\
                               * param.get('num_two_dim_one_ub')
        tail_core_num_index = tail_block_num_index\
                              // param.get('num_two_dim_one_ub')
        tail_core_num_mod = tail_block_num_index\
                            % param.get('num_two_dim_one_ub')
        tail_core_mod_block = tail_core_num_mod*param.get('two_dim')//256
        with tvm_ib.if_scope(tail_core_num_index > 0):
            with tvm_ib.if_scope(param.get('block_index') < tail_core_num_index):
                with tvm_ib.for_range(0, param.get('num_two_dim_one_ub'),
                                      name='num_b') as num_b:
                    with tvm_ib.for_range(0, param.get('block_row_len'),
                                          name='num_br') as num_br:
                        tvm_ib.emit(
                            tvm.call_extern(
                                data.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w",
                                    offset=(num_b * param.get('two_dim')
                                            + num_br * 16
                                            * param.get('col_len'))),
                                data.access_ptr(
                                    'r',
                                    offset=(param.get('num_group_index')
                                            * param.get('all_core_offset')
                                            + param.get('block_index')
                                            * param.get('actual_one_core_ele')
                                            + num_b * param.get('two_dim')
                                            + num_br * 16)),
                                0, param.get('col_len'),
                                ((16*param.get('float_size')) // 32),
                                (((param.get('row_len') - 16)
                                  * param.get('float_size')) // 32), 0))
                with tvm_ib.for_range(0, param.get('actual_one_core_block'),
                                      name='num_b_core') as num_b_core:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data_ub.dtype, "vtranspose",
                            data_ub_trans.access_ptr(
                                "rw", offset=(256*num_b_core)),
                            data_ub.access_ptr("r", offset=(256*num_b_core))))
                with tvm_ib.for_range(0, param.get('num_two_dim_one_ub'),
                                      name='num_b') as num_b:
                    with tvm_ib.for_range(0, param.get('block_row_len'),
                                          name='num_br') as num_br:
                        with tvm_ib.for_range(0, 16, name='i') as i:
                            tvm_ib.emit(
                                tvm.call_extern(
                                    ir_type, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=(param.get('num_group_index')
                                                * param.get('all_core_offset')
                                                + param.get('block_index')
                                                * param.get('actual_one'
                                                            '_core_ele')
                                                + num_b * param.get('two_dim')
                                                + num_br * 16
                                                * param.get('col_len')
                                                + 16
                                                * param.get('block_col_len')
                                                * i)),
                                    data_ub_trans.access_ptr(
                                        "r",
                                        offset=(num_b * param.get('two_dim')
                                                + num_br * 16
                                                * param.get('col_len')
                                                + 16 * i)),
                                    0, param.get('block_col_len'),
                                    ((16*param.get('float_size')) // 32),
                                    ((15*16*param.get('float_size')) // 32),
                                    0))

        with tvm_ib.if_scope(tvm.all(param.get('block_index')
                                     < (tail_core_num_index + 1),
                                     param.get('block_index')
                                     > (tail_core_num_index - 1))):
            with tvm_ib.for_range(0, tail_core_num_mod, name='num_b') as num_b:
                with tvm_ib.for_range(0, param.get('block_row_len'),
                                      name='num_br') as num_br:
                    tvm_ib.emit(
                        tvm.call_extern(
                            data.dtype, "copy_gm_to_ubuf",
                            data_ub.access_ptr(
                                "w",
                                offset=(num_b * param.get('two_dim')
                                        + num_br * 16 * param.get('col_len'))),
                            data.access_ptr(
                                'r',
                                offset=(param.get('num_group_index')
                                        * param.get('all_core_offset')
                                        + param.get('block_index')
                                        * param.get('actual_one_core_ele')
                                        + num_b * param.get('two_dim')
                                        + num_br * 16)),
                            0, param.get('col_len'),
                            ((16*param.get('float_size')) // 32),
                            (((param.get('row_len') - 16)
                              * param.get('float_size')) // 32), 0))
            with tvm_ib.for_range(0, tail_core_mod_block, name='num_b_core')\
                    as num_b_core:
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "vtranspose",
                        data_ub_trans.access_ptr(
                            "rw", offset=(256*num_b_core)),
                        data_ub.access_ptr("r", offset=(256*num_b_core))))
            with tvm_ib.for_range(0, tail_core_num_mod, name='num_b') as num_b:
                with tvm_ib.for_range(0, param.get('block_row_len'),
                                      name='num_br') as num_br:
                    with tvm_ib.for_range(0, 16, name='i') as i:
                        tvm_ib.emit(
                            tvm.call_extern(
                                ir_type, "copy_ubuf_to_gm",
                                dst.access_ptr(
                                    'w',
                                    offset=(param.get('num_group_index')
                                            * param.get('all_core_offset')
                                            + param.get('block_index')
                                            * param.get('actual_one_core_ele')
                                            + num_b*param.get('two_dim')
                                            + num_br*16
                                            * param.get('col_len')
                                            + 16 * param.get('block_col_len')
                                            * i)),
                                data_ub_trans.access_ptr(
                                    "r",
                                    offset=(num_b * param.get('two_dim')
                                            + num_br * 16
                                            * param.get('col_len') + 16*i)),
                                0, param.get('block_col_len'),
                                ((16*param.get('float_size')) // 32),
                                ((15*16*param.get('float_size')) // 32), 0))

    return tvm_ib.get()


def _ir_branch_index(shape, dtype):
    """
    judge ir node builder branch according to shape and dtype

    """
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    col_len = shape[len(shape) - 2]
    row_len = shape[len(shape) - 1]
    block_size = 16*16*float_size
    ub_block_num = UB_SIZE_B // 2 // block_size
    # available bytes in UB
    data_ub_size = ub_block_num*block_size
    # bytes in two dim shape
    two_dim_bytes = col_len*row_len*float_size
    # bytes in block row length
    block_row_len_bytes = row_len*16*float_size

    if data_ub_size >= two_dim_bytes:
        return "more_group"
    elif data_ub_size < block_row_len_bytes:
        return "split_row"
    elif data_ub_size < two_dim_bytes:
        return "more_row"


# pylint: disable=locally-disabled,unnecessary-lambda
def _get_res_ir(data, shape, perm, dtype):
    """
    the function to get the res_ir and parameters

    """
    def _permute_gm(*index):
        """
        function of permute the dimensions to get data_gm

        """
        for i, item in enumerate(_perm_to_flag(_get_perm_one(perm))):
            if i == 0:
                res_axis = (index[item],)
            else:
                res_axis = res_axis + (index[item],)

        return res_axis

    perm_one = _get_perm_one(perm)
    if _is_perm_change(perm_one) or (dtype != "float16"
                                     and dtype != "int16"
                                     and dtype != "uint16"):
        shape_one = _get_perm_shape(shape, _get_perm_one(perm))
        data_ub_one = tvm.compute(shape, lambda *i: data(*i),
                                  name="data_ub_one")
        if dtype == "float16" or dtype == "int16" or dtype == "uint16":
            ir_type = dtype
            data_ub_one_fp16 = data_ub_one
        else:
            ir_type = "float16"
            data_ub_one_fp16 = tvm.compute(shape,
                                           lambda *i:
                                           data_ub_one(*i).astype("float16"),
                                           name="data_ub_one_fp16")
        data_gm = tvm.compute(shape_one,
                              lambda *i: data_ub_one_fp16(*_permute_gm(*i)),
                              name="data_gm")
        param_ir = {'data_ub_one': data_ub_one,
                    'data_ub_one_fp16': data_ub_one_fp16,
                    'data_gm': data_gm, 'shape_one': shape_one,
                    'ir_type': ir_type}
    else:
        shape_one = shape
        data_gm = data
        ir_type = dtype
        param_ir = {'data_gm': data_gm, 'shape_one': shape_one,
                    'ir_type': ir_type}

    branch_index = _ir_branch_index(shape_one, ir_type)
    if branch_index == "more_group":
        res_ir = tvm.extern(_get_shape_two(shape_one), [data_gm],
                            lambda ins, outs:
                            _multi_core_more_group_ir(outs[0], ins[0], ir_type),
                            name="res_ir", dtype=ir_type)
    elif branch_index == "more_row":
        res_ir = tvm.extern(_get_shape_two(shape_one), [data_gm],
                            lambda ins, outs:
                            _multi_core_more_row_ir(outs[0], ins[0], ir_type),
                            name="res_ir", dtype=ir_type)
    else:
        res_ir = tvm.extern(_get_shape_two(shape_one), [data_gm],
                            lambda ins, outs:
                            _multi_core_split_row_ir(outs[0], ins[0], ir_type),
                            name="res_ir", dtype=ir_type)

    perm_three = _get_perm_three(_get_shape_two(_get_perm_one(perm)), perm)
    if _is_perm_change(perm_three)\
            or (dtype != "float16" and dtype != "int16" and dtype != "uint16"):
        res, param_res = _get_res(res_ir, _get_perm_shape(shape, perm),
                                  dtype, perm,
                                  _get_shape_two(_get_perm_one(perm)))
    else:
        res = res_ir
        param_res = {}

    param_ir.setdefault('res_ir', res_ir)
    param = {}
    param.update(param_ir)
    param.update(param_res)

    return res, param


def _get_res(res_ir, shape_res, dtype, perm, perm_two):
    """
    the function to get the res and parameters

    """
    def _permute_res(*index):
        """
        function of permute the dimensions of data_ub_two

        """
        for i, item in enumerate(flag_three):
            if i == 0:
                res_axis = (index[item],)
            else:
                res_axis = res_axis + (index[item],)

        return res_axis

    perm_three = _get_perm_three(perm_two, perm)
    flag_three = _perm_to_flag(perm_three)
    data_ub_two = tvm.compute(shape_res, lambda *i: res_ir(*_permute_res(*i)),
                              name="data_ub_two")
    if dtype != "float16" and dtype != "int16" and dtype != "uint16":
        data_ub_two_res = tvm.compute(shape_res,
                                      lambda *i: data_ub_two(*i).astype(dtype),
                                      name="data_ub_two_res")
    else:
        data_ub_two_res = data_ub_two
    res = tvm.compute(shape_res, lambda *i: data_ub_two_res(*i), name="res")
    param_res = {'data_ub_two': data_ub_two,
                 'data_ub_two_res': data_ub_two_res}

    return res, param_res


def _schedule_for_data_ub_two(sch, res, param, shape_res, dtype):
    """
    the function of schedule for the third stage
     for transpose the last axis scene

    """
    split_axis2, split_factor2 = _tilling_axis_last(shape_res, dtype)
    axis_outer2, axis_inner2 = sch[res].split(res.op.axis[split_axis2],
                                              factor=split_factor2)
    sch[param.get('data_ub_two')].compute_at(sch[res], axis_outer2)
    sch[param.get('data_ub_two_res')].compute_at(sch[res], axis_outer2)
    sch[param.get('data_ub_two')].emit_insn(
        param.get('data_ub_two').op.axis[split_axis2], insn_cmd.DMA_COPY)
    if dtype == "int32":
        sch[param.get('data_ub_two_res')].emit_insn(
            param.get('data_ub_two_res').op.axis[split_axis2],
            insn_cmd.CAST_RINT)
    elif dtype != "float16" and dtype != "int16" and dtype != "uint16":
        sch[param.get('data_ub_two_res')].emit_insn(
            param.get('data_ub_two_res').op.axis[split_axis2],
            insn_cmd.CAST)
    sch[res].emit_insn(axis_inner2, insn_cmd.DMA_COPY)

    return sch


def _transpose_change_last(data, shape, shape_res, perm, dtype):
    """
    permutes the dimensions and the last axis is transposed

    Parameters
    ----------
    data: tvm.tensor
        tensor of input data
    shape: list or tuple
        shape of input tensor
    shape_res: tuple
        shape of output tensor
    perm: list or tuple
        permutation of the dimension of tensor
    dtype: str
        the data type

    Returns
    -------
    sch: tvm.schedule
        the compute schedule
    tensor_list: list
        list of tensor
        [data, res, param.get('data_gm'), param.get('res_ir')]
    num: int
        the count of workspaces
    total_size: list
        the list of size of workspaces
    """
    res, param = _get_res_ir(data, shape, perm, dtype)
    sch = tvm.create_schedule(res.op)
    if 'data_ub_one' in param:
        sch[param.get('data_ub_one')].set_scope(cce.scope_ubuf)
        sch[param.get('data_ub_one_fp16')].set_scope(cce.scope_ubuf)
    if 'data_ub_two' in param:
        sch[param.get('data_ub_two')].set_scope(cce.scope_ubuf)
        sch[param.get('data_ub_two_res')].set_scope(cce.scope_ubuf)

    if 'data_ub_one' in param:
        split_axis1, split_factor1 = _tilling_axis_last(param.get('shape_one'),
                                                        dtype)
        axis_outer1, axis_inner1 = sch[param.get('data_gm')].split(
            param.get('data_gm').op.axis[split_axis1], factor=split_factor1)
        sch[param.get('data_ub_one')].compute_at(sch[param.get('data_gm')],
                                                 axis_outer1)
        sch[param.get('data_ub_one_fp16')].compute_at(
            sch[param.get('data_gm')], axis_outer1)
        sch[param.get('data_ub_one')].emit_insn(
            param.get('data_ub_one').op.axis[split_axis1], insn_cmd.DMA_COPY)
        if dtype != "float16" and dtype != "int16" or dtype != "uint16":
            sch[param.get('data_ub_one_fp16')].emit_insn(
                param.get('data_ub_one_fp16').op.axis[split_axis1],
                insn_cmd.CAST)
        sch[param.get('data_gm')].emit_insn(axis_inner1, insn_cmd.DMA_COPY)

    if 'data_ub_two' in param:
        sch = _schedule_for_data_ub_two(sch, res, param, shape_res, dtype)

    size = 1
    for item in shape:
        size *= item
    dtype_bytes_size = cce.cce_intrin.get_bit_len(param.get('ir_type')) // 8
    size *= dtype_bytes_size

    if ('data_ub_one' in param) and ('data_ub_two' in param):
        tensor_list = [data, res, param.get('data_gm'), param.get('res_ir')]
        num = 2
        total_size = [size, size]
    elif 'data_ub_one' in param:
        tensor_list = [data, res, param.get('data_gm')]
        num = 1
        total_size = [size]
    elif 'data_ub_two' in param:
        tensor_list = [data, res, param.get('res_ir')]
        num = 1
        total_size = [size]
    else:
        tensor_list = [data, res]
        num = 0
        total_size = []

    return sch, tensor_list, num, total_size


def _do_storage_align(sch, data_ub, shape_res, dtype):
    """
    the function to do storage align

    """
    if len(shape_res) >= 2:
        do_align = True
        if shape_res[len(shape_res) - 1] == 1:
            count = 0
            for i in shape_res:
                if i > 1:
                    count += 1
            if count == 1:
                do_align = False
        if do_align:
            dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
            # 32 means one block size(32 Bytes),
            # divide by 32 to get the numbers of data that
            # can be stored in one block.
            element = 32 // dtype_bytes_size
            align_axis = _get_align_axis(shape_res)
            sch[data_ub].storage_align(data_ub.op.axis[align_axis], element, 0)

    return sch


def _get_fused_index(fused_axis_value, origin_list_copy, split_axis):
    """
    get fused index for not change last schedule

    """
    fused_index_list = []
    for target in fused_axis_value:
        for i, item in enumerate(origin_list_copy):
            if target == item:
                fused_index_list.append(i)
                origin_list_copy[i] = -1
                break

    is_fuse_outer = False
    for i in fused_index_list:
        if i == split_axis:
            is_fuse_outer = True
            fused_index_list.remove(split_axis)
            break

    return fused_index_list, origin_list_copy, is_fuse_outer


def _get_after_reorder_axis(reorder_axis_index, split_axis):
    """
    get after reorder axis for not change last schedule

    """
    after_reorder_axis_index = []
    for i in list(range(split_axis)):
        if i not in reorder_axis_index:
            after_reorder_axis_index.append(i)

    return after_reorder_axis_index


def _do_compute_at(args):
    """
    compute at for not change last schedule

    """
    reorder_axis_index, sch, res, fused_axis, split_axis, data_ub = args
    if reorder_axis_index:
        fused_index_last = reorder_axis_index[-1]
        if fused_index_last == split_axis - 1:
            sch[data_ub].compute_at(sch[res], fused_axis)
        else:
            sch[data_ub].compute_at(sch[res], res.op.axis[split_axis - 1])
    else:
        sch[data_ub].compute_at(sch[res], fused_axis)

    return sch


def _schedule_for_not_change_last(args):
    """
    the function to bind multi core

    """
    sch, data, res, data_ub, shape_res, dtype = args
    sch[data_ub].set_scope(cce.scope_ubuf)
    dtype_bytes_size = cce.cce_intrin.get_bit_len(dtype) // 8
    element = 32 // dtype_bytes_size
    if shape_res[-1] < element:
        split_axis, split_factor = _tilling_axis_not_last(shape_res, dtype)
        axis_outer, axis_inner = sch[res].split(res.op.axis[split_axis],
                                                factor=split_factor)
        sch[data_ub].compute_at(sch[res], axis_outer)
    else:
        split_axis, split_factor = _tilling_axis_multi_core_fuse(shape_res,
                                                                 dtype)

        if split_axis == len(shape_res) - 1 and split_factor < element:
            axis_outer, axis_inner = sch[res].split(res.op.axis[split_axis],
                                                    factor=split_factor)
            sch[data_ub].compute_at(sch[res], axis_outer)
        else:
            axis_outer, axis_inner = sch[res].split(res.op.axis[split_axis],
                                                    factor=split_factor)
            axis_outer_num_index = shape_res[split_axis] // split_factor
            axis_outer_num_mod = shape_res[split_axis] % split_factor
            if axis_outer_num_mod > 0:
                axis_outer_num = axis_outer_num_index + 1
            else:
                axis_outer_num = axis_outer_num_index

            origin_list = [shape_res[i] for i in range(split_axis)]
            if axis_outer_num <= 65535:
                origin_list.append(axis_outer_num)

            origin_sort = list(reversed(sorted(origin_list)))
            fused_value = 1
            fused_axis_value = []
            for _, item in enumerate(origin_sort):
                if fused_value*item <= 65535:
                    fused_axis_value.append(item)
                    fused_value *= item

            origin_list_copy = origin_list[:]
            if fused_axis_value:
                fused_index_list, origin_list_copy, is_fuse_outer =\
                    _get_fused_index(
                        fused_axis_value, origin_list_copy, split_axis)
                reorder_axis_index = sorted(fused_index_list)
                if is_fuse_outer:
                    after_reorder_axis_index = _get_after_reorder_axis(
                        reorder_axis_index, split_axis)
                    reorder_axis = [sch[res].op.axis[i]
                                    for i in reorder_axis_index]
                    reorder_axis.append(axis_outer)
                    for i in after_reorder_axis_index:
                        reorder_axis.append(sch[res].op.axis[i])
                    sch[res].reorder(*reorder_axis)
                    fused_list = [sch[res].op.axis[i]
                                  for i in sorted(fused_index_list)]
                    fused_axis = sch[res].fuse(*fused_list)
                    fused_list.append(axis_outer)
                    fused_axis = sch[res].fuse(fused_axis, axis_outer)
                    args = [reorder_axis_index, sch, res, fused_axis,
                            split_axis, data_ub]
                    sch = _do_compute_at(args)
                    sch[res].bind(fused_axis, tvm.thread_axis('blockIdx.x'))
                else:
                    for i in list(range(split_axis)):
                        if i not in reorder_axis_index:
                            reorder_axis_index.append(i)
                    sch[res].reorder(*[sch[res].op.axis[i]
                                       for i in reorder_axis_index])
                    fused_axis = sch[res].fuse(
                        *[sch[res].op.axis[i]
                          for i in sorted(fused_index_list)])
                    sch[res].bind(fused_axis, tvm.thread_axis('blockIdx.x'))
                    sch[data_ub].compute_at(sch[res], axis_outer)
            else:
                split_axis, split_factor = _tilling_axis_not_last(
                    shape_res, dtype)
                axis_outer, axis_inner = sch[res].split(
                    res.op.axis[split_axis], factor=split_factor)
                sch[data_ub].compute_at(sch[res], axis_outer)

    sch[data_ub].emit_insn(data_ub.op.axis[split_axis], insn_cmd.DMA_COPY)
    sch = _do_storage_align(sch, data_ub, shape_res, dtype)
    sch[res].emit_insn(axis_inner, insn_cmd.DMA_COPY)
    tensor_list = [data, res]

    return sch, tensor_list


def _tranpose_notchange_last(data, shape_res, perm, dtype):
    """
    permutes the dimensions and the last axis is not transposed

    Parameters
    ----------
    data: tvm.tensor
        tensor of input data
    shape_res: list or tuple
        shape of output tensor
    perm: list or tuple
        permutation of the dimension of tensor
    dtype: str
        the data type

    Returns
    -------
    sch: tvm.schedule
        the compute schedule
    tensor_list: list
        list of tensor
    """
    def _permute(*index):
        """
        function of permute the dimensions of data

        """
        for i, item in enumerate(_perm_to_flag(perm)):
            if i == 0:
                res_axis = (index[item],)
            else:
                res_axis = res_axis + (index[item],)

        return res_axis

    data_ub = tvm.compute(shape_res, lambda *index: data(*_permute(*index)),
                          name="data_ub")
    res = tvm.compute(shape_res, lambda *index: data_ub(*index), name="res")
    sch = tvm.create_schedule(res.op)
    args = [sch, data, res, data_ub, shape_res, dtype]
    sch, tensor_list = _schedule_for_not_change_last(args)

    return sch, tensor_list


def _ceil_div(value, block):
    """
    integrate the input value by block

    """
    return (value + block - 1) // block


def _ceil_fill(value, block):
    """
    fill the input value by block

    """
    return _ceil_div(value, block)*block


# pylint: disable=locally-disabled,unused-argument
def _get_param_one_row_0231(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for one row 0231 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    n_i, _, h_i, w_i = src_shape
    num_ele_one_dim_data = h_i * w_i
    num_block_one_dim_data = _ceil_div(num_ele_one_dim_data, cp_align_len)
    num_row_group_one_core = 1
    num_row_group_in_data = num_block_one_dim_data*n_i
    num_row_group_one_group = num_row_group_one_core*device_core_num
    num_group_index = num_row_group_in_data // num_row_group_one_group
    num_group_mod = num_row_group_in_data % num_row_group_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_row_group_one_core": num_row_group_one_core,
                 "num_block_one_dim_data": num_block_one_dim_data,
                 "num_ele_one_dim_data": num_ele_one_dim_data,
                 "num_row_group_one_group": num_row_group_one_group}
    return param_map


def _reg_mov_batch_ci(args):
    """
    reg_move for c_i data

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, index, ub_offset,\
    res_offset, num_row, num_r = args

    ele_reg = 8
    r_cycle = num_row // ele_reg
    r_mod = num_row - ele_reg*r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_zero)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_one)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_two)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_three)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_four)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_five)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_six)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_seven)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset + num_cr*ele_reg
                                             + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    reg_addr[index] = r_mod
    with tvm_ib.for_range(0, reg_addr[index], name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (r_cycle*ele_reg + num_er)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(
                res_offset + r_cycle * ele_reg + num_er)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_align(args):
    """
    reg_mov data for cp_align_len data

    """
    tvm_ib, data_res, data_tail, reg, res_offset, tail_offset,\
    len_align, num_align = args

    ele_reg = 8
    r_cycle = num_align // ele_reg
    r_mod = num_align - ele_reg*r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_zero))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_one))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_two))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_three))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_four))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_five))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_six))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_res.access_ptr('r',
                                offset=(res_offset + len_align + num_cr*ele_reg
                                        + reg_seven))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_zero),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_one),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_two),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_three),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_four),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_five),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_six),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr('w', offset=tail_offset + num_cr*ele_reg
                                 + reg_seven),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr('r',
                                    offset=(res_offset + len_align
                                            + r_cycle * ele_reg + num_er))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr('w', offset=tail_offset + r_cycle*ele_reg
                                     + num_er),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _ub_to_gm_one_row(args):
    """
    function of moving data from data_ub to dst for one row scene

    """
    tvm_ib, param, dst, data_ub, data_res, data_tail, reg, c_i, num_row,\
    num_n_before_core, num_ele_one_n, num_row_group_cur_dim_before,\
    reg_addr, index = args

    with tvm_ib.for_range(0, num_row, name="num_r") as num_r:
        args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
               index, 0, 0, c_i, num_r
        _reg_mov_batch_ci(args)

        with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
            len_align = c_i - param.get("cp_align_len")
            dst_offset = num_n_before_core*num_ele_one_n\
                         + num_row_group_cur_dim_before\
                         * param.get("cp_align_len")*c_i\
                         + num_r*c_i
            burst_len_dst = _ceil_div(len_align, param.get("cp_align_len"))
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))

            args = tvm_ib, data_res, data_tail, reg, 0, 0,\
                   len_align, param.get("cp_align_len")
            _reg_mov_batch_align(args)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w', offset=dst_offset + len_align),
                                        data_tail.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_n_before_core*num_ele_one_n\
                         + num_row_group_cur_dim_before\
                         * param.get("cp_align_len")*c_i\
                         + num_r*c_i
            burst_len_dst = c_i // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _func_one_row_ir_0231(args):
    """
    function of moving data in one row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
    reg, reg_addr, num_g = args

    _, c_i, h_i, w_i = data.shape
    num_row_group_before_core = num_g*param.get("num_row_group_one_group")\
                                + param.get("block_index")\
                                * param.get("num_row_group_one_core")
    num_n_before_core = num_row_group_before_core\
                        // param.get("num_block_one_dim_data")
    num_row_group_cur_dim_before = num_row_group_before_core % param.get(
        "num_block_one_dim_data")
    num_ele_one_n = c_i * h_i * w_i

    # move from data(GM) to data_ub(UB)
    with tvm_ib.if_scope(param.get("num_ele_one_dim_data")
                         % param.get("cp_align_len") > 0):
        with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
            ub_offset = num_ci*param.get("cp_align_len")
            data_offset = num_n_before_core*num_ele_one_n\
                          + num_ci*param.get("num_ele_one_dim_data")\
                          + num_row_group_cur_dim_before\
                          * param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        data_offset = num_n_before_core*num_ele_one_n\
                      + num_row_group_cur_dim_before*param.get("cp_align_len")
        src_stride = param.get("num_block_one_dim_data") - 1
        args = tvm_ib, param, data, data_ub, data_offset, 0, c_i, 1,\
               src_stride, 0
        _func_gm_to_ub(args)

    # move from data_ub(GM) to data_res(UB) to dst(GM)
    with tvm_ib.if_scope(num_row_group_cur_dim_before
                         < param.get("num_block_one_dim_data") - 1):
        num_row = param.get("cp_align_len")
        args = tvm_ib, param, dst, data_ub, data_res, data_tail, reg,\
               c_i, num_row, num_n_before_core, num_ele_one_n,\
               num_row_group_cur_dim_before, reg_addr, 0
        _ub_to_gm_one_row(args)
    with tvm_ib.else_scope():
        num_row = param.get("num_ele_one_dim_data")\
                  - num_row_group_cur_dim_before*param.get("cp_align_len")
        args = tvm_ib, param, dst, data_ub, data_res, data_tail, reg,\
               c_i, num_row, num_n_before_core, num_ele_one_n,\
               num_row_group_cur_dim_before, reg_addr, 1
        _ub_to_gm_one_row(args)


def _one_row_ir_0231(dst, data, core_divide):
    """
    function of making ir node builder for one row 0231 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_one_row_0231(tvm_ib, data.shape, dst.dtype, core_divide)
    c_i = data.shape[1]
    data_ub = _new_alloc(tvm_ib, dst.dtype, c_i*(param.get("cp_align_len") + 1),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, c_i,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g
            _func_one_row_ir_0231(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_row_group_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g
                    _func_one_row_ir_0231(args)

    return tvm_ib.get()


def _get_param_more_row_0231(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for more row 0231 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = (UB_SIZE_B - 32) // core_divide
    ub_half = ub_bytes // 2
    n_i, c_i, h_i, w_i = src_shape
    num_ele_one_dim_data = h_i*w_i
    num_block_one_dim_data = _ceil_div(num_ele_one_dim_data, cp_align_len)
    num_block_in_data = num_block_one_dim_data*n_i*c_i
    num_block_in_ub_half = ub_half // 32
    num_row_group_one_core = num_block_in_ub_half // c_i
    num_block_one_core = num_row_group_one_core*c_i
    num_block_one_group = num_block_one_core*device_core_num
    num_group_index = num_block_in_data // num_block_one_group
    num_group_mod = num_block_in_data % num_block_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_block_one_core": num_block_one_core,
                 "num_block_one_group": num_block_one_group,
                 "num_block_one_dim_data": num_block_one_dim_data,
                 "num_ele_one_dim_data": num_ele_one_dim_data}

    return param_map


def _reg_mov_batch_more_one_store(args):
    """
    reg_mov data for first branch in more row 0231 scene

    """
    tvm_ib, data_ub, data_res, reg, num_row_cur, c_i, num_c = args

    ele_reg = 8
    r_cycle = num_row_cur // ele_reg
    r_mod = num_row_cur - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_zero))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_one))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_two))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_three))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_four))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_five))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_six))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_cur + num_cr*ele_reg
                                       + reg_seven))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_zero) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_one) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_two) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_three) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_four) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_five) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_six) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_seven) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=(num_c * num_row_cur
                                           + r_cycle * ele_reg + num_er))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=(r_cycle * ele_reg + num_er)
                                    * c_i + num_c),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_more_one(args):
    """
    reg_mov data for first branch in more row 0231 scene

    """
    tvm_ib, data_ub, data_res, reg, num_row_cur, c_i, num_r = args

    ele_reg = 8
    r_cycle = c_i // ele_reg
    r_mod = c_i - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_zero)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_one)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_two)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_three)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_four)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_five)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_six)*num_row_cur
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_seven)
                                       * num_row_cur + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_zero),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_one),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_two),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_three),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_four),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_five),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_six),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_seven),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))

    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=((r_cycle * ele_reg + num_er)
                                           * num_row_cur + num_r))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w',
                                    offset=num_r * c_i + r_cycle * ele_reg
                                    + num_er),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_head_store(args):
    """
    reg_mov data for head store in more row 0231 scene

    """
    tvm_ib, data_ub, data_res, reg, num_row_head_actual,\
    num_row_total_space, c_i, num_c = args

    ele_reg = 8
    r_cycle = num_row_head_actual // ele_reg
    r_mod = num_row_head_actual - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_zero)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_one)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_two)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_three)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_four)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_five)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_six)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=num_c * num_row_total_space
                               + num_cr*ele_reg + reg_seven)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_zero) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_one) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_two) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_three) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_four) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_five) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_six) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_cr*ele_reg + reg_seven) * c_i
                                + num_c),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=num_c * num_row_total_space
                                   + r_cycle * ele_reg + num_er)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=(r_cycle * ele_reg + num_er)
                                    * c_i + num_c),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_head(args):
    """
    reg_mov data for head in more row 0231 scene

    """
    tvm_ib, data_ub, data_res, reg,\
    num_row_total_space, c_i, num_r = args

    ele_reg = 8
    r_cycle = c_i // ele_reg
    r_mod = c_i - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_zero)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_one)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_two)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_three)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_four)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_five)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_six)
                               * num_row_total_space + num_r)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_cr*ele_reg + reg_seven)
                               * num_row_total_space + num_r)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_zero),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_one),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_two),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_three),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_four),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_five),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_six),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=num_r * c_i + num_cr*ele_reg
                                + reg_seven),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))

    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=(r_cycle*ele_reg + num_er)
                                   * num_row_total_space + num_r)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=num_r * c_i + r_cycle*ele_reg
                                    + num_er),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_mid_store(args):
    """
    reg_mov data for middle store in more row 0231 scene

    """
    tvm_ib, param, data_ub, data_res, reg, num_row_mid_actual,\
    num_row_total_space, num_row_group_dim_head, num_row_head_actual,\
    c_i, num_md, num_c = args

    ele_reg = 8
    r_cycle = num_row_mid_actual // ele_reg
    r_mod = num_row_mid_actual - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    ub_offset = num_c * num_row_total_space\
                    + (num_row_group_dim_head
                       + num_md*param.get("num_block_one_dim_data"))\
                    * param.get("cp_align_len")
    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_zero)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_one)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_two)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_three)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_four)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_five)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_six)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_seven)
        ))

        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_zero)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_one)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_two)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_three)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_four)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_five)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_six)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        ub_res_offset_mid = (num_row_head_actual + num_md * num_row_mid_actual
                             + (num_cr*ele_reg + reg_seven)) * c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset + r_cycle * ele_reg
                                   + num_er)
            ))
            ub_res_offset_mid = (num_row_head_actual
                                 + num_md * num_row_mid_actual
                                 + (r_cycle * ele_reg + num_er)) * c_i + num_c
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w',
                                    offset=ub_res_offset_mid),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_mid(args):
    """
    reg_mov data for middle in more row 0231 scene

    """
    tvm_ib, param, data_ub, data_res, reg, num_row_mid_actual,\
    num_row_total_space, num_row_group_dim_head, num_row_head_actual,\
    c_i, num_md, num_r = args

    ele_reg = 8
    r_cycle = c_i // ele_reg
    r_mod = c_i - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    ub_offset = (num_row_group_dim_head
                 + num_md*param.get("num_block_one_dim_data"))\
                * param.get("cp_align_len") + num_r
    ub_res_offset_mid = (num_row_head_actual
                         + num_md * num_row_mid_actual + num_r) * c_i
    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * num_row_total_space)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=ub_res_offset_mid
                                + (num_cr*ele_reg + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset
                                   + (r_cycle*ele_reg + num_er)
                                   * num_row_total_space)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w',
                                    offset=ub_res_offset_mid
                                    + (r_cycle*ele_reg + num_er)),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_tail_store(args):
    """
    reg_mov data for tail store in more row 0231 scene

    """
    tvm_ib, param, data_ub, data_res, reg, num_row_total_space,\
    num_row_group_dim_head, num_row_head_actual, num_row_mid_actual,\
    num_mid_n, c_i, num_c, num_row_tail_reg, num_row_tail = args

    ele_reg = 8
    r_cycle = num_row_tail_reg // ele_reg
    r_mod = num_row_tail - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    ub_offset = num_c*num_row_total_space\
                + (num_row_group_dim_head + num_mid_n
                   * param.get("num_block_one_dim_data"))\
                * param.get("cp_align_len")
    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_zero)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_one)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_two)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_three)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_four)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_five)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_six)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + num_cr*ele_reg + reg_seven)
        ))

        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_zero))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_one))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_two))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_three))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_four))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_five))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_six))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        ub_res_offset_tail = (num_row_head_actual
                              + num_mid_n*num_row_mid_actual
                              + (num_cr*ele_reg + reg_seven))*c_i + num_c
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset + r_cycle * ele_reg
                                   + num_er)
            ))
            ub_res_offset_tail = (num_row_head_actual
                                  + num_mid_n*num_row_mid_actual
                                  + (r_cycle * ele_reg + num_er))*c_i + num_c
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=ub_res_offset_tail),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _reg_mov_batch_tail(args):
    """
    reg_mov data for tail in more row 0231 scene

    """
    tvm_ib, param, data_ub, data_res, reg, num_row_total_space,\
    num_row_group_dim_head, num_row_head_actual, num_row_mid_actual,\
    num_mid_n, c_i, num_r = args

    ele_reg = 8
    r_cycle = c_i // ele_reg
    r_mod = c_i - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    ub_offset = (num_row_group_dim_head + num_mid_n * param.get(
        "num_block_one_dim_data")) \
                     * param.get("cp_align_len") + num_r
    ub_res_offset_tail = (num_row_head_actual
                          + num_mid_n * num_row_mid_actual + num_r) * c_i
    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * num_row_total_space)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * num_row_total_space)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_zero),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_one),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_two),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_three),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_four),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_five),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_six),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=ub_res_offset_tail + num_cr*ele_reg
                                + reg_seven),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset + (r_cycle*ele_reg + num_er)
                                   * num_row_total_space)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=ub_res_offset_tail
                                    + r_cycle*ele_reg + num_er),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _func_more_row_ir_0231(args):
    """
    function of moving data in more row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
    reg, reg_addr, num_g, num_block_cur_core = args

    _, c_i, h_i, w_i = data.shape
    num_row_group_cur_core = num_block_cur_core // c_i
    num_block_before_core = num_g*param.get("num_block_one_group")\
                            + param.get("block_index")\
                            * param.get("num_block_one_core")
    num_row_group_before_core = num_block_before_core // c_i
    num_n_before_core = num_row_group_before_core\
                        // param.get("num_block_one_dim_data")
    num_row_group_cur_dim_before = num_row_group_before_core\
                                   % param.get("num_block_one_dim_data")
    num_row_group_dim_head = param.get("num_block_one_dim_data")\
                             - num_row_group_cur_dim_before
    num_ele_one_n = c_i*h_i*w_i

    with tvm_ib.if_scope(num_row_group_dim_head > num_row_group_cur_core):
        # move from data(GM) to data_ub(UB)
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data")
                             % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
                data_offset_cur = num_n_before_core * num_ele_one_n\
                                  + num_row_group_cur_dim_before\
                                  * param.get("cp_align_len")\
                                  + num_ci*param.get("num_ele_one_dim_data")
                ub_offset_cur = num_ci*num_row_group_cur_core\
                                * param.get("cp_align_len")
                burst_len_cur = num_row_group_cur_core
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset_cur),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_cur),
                                            0, 1, burst_len_cur, 0, 0))
        with tvm_ib.else_scope():
            data_offset = num_n_before_core * num_ele_one_n\
                          + num_row_group_cur_dim_before\
                          * param.get("cp_align_len")
            burst_len_data = num_row_group_cur_core
            src_stride = param.get("num_block_one_dim_data") - burst_len_data
            args = tvm_ib, param, data, data_ub, data_offset, 0, c_i,\
                   burst_len_data, src_stride, 0
            _func_gm_to_ub(args)

        # move from data_ub to data_res
        num_row_cur = num_row_group_cur_core*param.get("cp_align_len")
        with tvm_ib.if_scope(c_i >= 8):
            with tvm_ib.for_range(0, num_row_cur, name="num_r") as num_r:
                args = tvm_ib, data_ub, data_res, reg, num_row_cur,\
                       c_i, num_r
                _reg_mov_batch_more_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                args = tvm_ib, data_ub, data_res, reg, num_row_cur,\
                       c_i, num_c
                _reg_mov_batch_more_one_store(args)

        # move from data_res to dst (32B align)
        dst_offset = num_n_before_core*num_ele_one_n\
                     + num_row_group_cur_dim_before\
                     * param.get("cp_align_len")*c_i
        burst_len_dst = num_row_group_cur_core*c_i
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(num_row_group_dim_head <= num_row_group_cur_core):
        num_row_group_after = num_row_group_cur_core - num_row_group_dim_head
        reg_addr[0] = num_row_group_after
        num_mid_n = reg_addr[0] // param.get("num_block_one_dim_data")
        num_row_group_tail = num_row_group_after - param.get(
            "num_block_one_dim_data") * num_mid_n

        # move from data(GM) to data_ub(UB)
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data") % param.get(
            "cp_align_len") > 0):
            # move data for head
            with tvm_ib.if_scope(num_row_group_dim_head > 0):
                with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
                    ub_offset_head = num_ci*num_row_group_cur_core\
                                     * param.get("cp_align_len")
                    data_offset_head = num_n_before_core * num_ele_one_n\
                                       + num_row_group_cur_dim_before\
                                       * param.get("cp_align_len")\
                                       + num_ci\
                                       * param.get("num_ele_one_dim_data")
                    burst_len_head = num_row_group_dim_head
                    tvm_ib.emit(
                        tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset_head),
                                        data.access_ptr(
                                            'r',
                                            offset=data_offset_head),
                                        0, 1, burst_len_head, 0, 0))
            # move data for middle
            with tvm_ib.if_scope(num_mid_n > 0):
                with tvm_ib.for_range(0, num_mid_n, name="num_m") as num_m:
                    with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
                        ub_offset_mid = (num_ci*num_row_group_cur_core
                                         + num_row_group_dim_head
                                         + num_m
                                         * param.get("num_block_one_dim_data"))\
                                        * param.get("cp_align_len")
                        data_offset_mid = (num_n_before_core + num_m + 1)\
                                          * num_ele_one_n\
                                          + num_ci\
                                          * param.get("num_ele_one_dim_data")
                        burst_len_mid = param.get("num_block_one_dim_data")
                        with tvm_ib.if_scope(burst_len_mid <= 65535):
                            tvm_ib.emit(
                                tvm.call_extern(data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w",
                                                    offset=ub_offset_mid),
                                                data.access_ptr(
                                                    'r',
                                                    offset=data_offset_mid),
                                                0, 1, burst_len_mid, 0, 0))
            # move data for tail
            with tvm_ib.if_scope(num_row_group_tail > 0):
                with tvm_ib.for_range(0, c_i, name="num_ci") as num_ci:
                    ub_offset_tail = (num_ci*num_row_group_cur_core
                                      + num_row_group_dim_head
                                      + num_mid_n
                                      * param.get("num_block_one_dim_data"))\
                                     * param.get("cp_align_len")
                    data_offset_tail = (num_n_before_core + num_mid_n + 1)\
                                       * num_ele_one_n\
                                       + num_ci\
                                       * param.get("num_ele_one_dim_data")
                    burst_len_tail = num_row_group_tail
                    tvm_ib.emit(
                        tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset_tail),
                                        data.access_ptr(
                                            'r', offset=data_offset_tail),
                                        0, 1, burst_len_tail, 0, 0))

        with tvm_ib.else_scope():
            # move data for head
            with tvm_ib.if_scope(num_row_group_dim_head > 0):
                data_offset_head = num_n_before_core * num_ele_one_n \
                                   + num_row_group_cur_dim_before * param.get(
                                       "cp_align_len")
                burst_len_head = num_row_group_dim_head
                src_stride_head = param.get(
                    "num_block_one_dim_data") - burst_len_head
                dst_stride_head = num_row_group_after
                args = tvm_ib, param, data, data_ub, data_offset_head, 0,\
                       c_i, burst_len_head, src_stride_head, dst_stride_head
                _func_gm_to_ub(args)
            # move data for middle
            with tvm_ib.if_scope(num_mid_n > 0):
                with tvm_ib.for_range(0, num_mid_n, name="num_m") as num_m:
                    ub_offset_mid = (num_row_group_dim_head + num_m * param.get(
                        "num_block_one_dim_data")) * param.get("cp_align_len")
                    data_offset_mid = (num_n_before_core + num_m + 1)\
                                      * num_ele_one_n
                    burst_len_mid = param.get("num_block_one_dim_data")
                    dst_stride_mid = num_row_group_cur_core - param.get(
                        "num_block_one_dim_data")
                    with tvm_ib.if_scope(burst_len_mid <= 65535):
                        args = tvm_ib, param, data, data_ub, data_offset_mid,\
                               ub_offset_mid, c_i, burst_len_mid, 0,\
                               dst_stride_mid
                        _func_gm_to_ub(args)

            # move data for tail
            with tvm_ib.if_scope(num_row_group_tail > 0):
                ub_offset_tail = (num_row_group_dim_head + num_mid_n
                                  * param.get("num_block_one_dim_data"))\
                                 * param.get("cp_align_len")
                data_offset_tail = (num_n_before_core + num_mid_n + 1)\
                                   * num_ele_one_n
                burst_len_tail = num_row_group_tail
                src_stride_tail = param.get(
                    "num_block_one_dim_data") - burst_len_tail
                dst_stride_tail = num_row_group_cur_core - num_row_group_tail
                args = tvm_ib, param, data, data_ub, data_offset_tail,\
                       ub_offset_tail, c_i, burst_len_tail, src_stride_tail,\
                       dst_stride_tail
                _func_gm_to_ub(args)

        # move from data_ub(UB) to data_res(UB)
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data")
                             % param.get("cp_align_len") > 0):
            num_row_total_space = num_row_group_cur_core\
                                  * param.get("cp_align_len")
            # move data for head
            num_row_head_actual = (h_i*w_i) - (num_row_group_cur_dim_before
                                               * param.get("cp_align_len"))
            with tvm_ib.if_scope(c_i >= 8):
                with tvm_ib.for_range(0, num_row_head_actual,
                                      name="num_r") as num_r:
                    args = tvm_ib, data_ub, data_res, reg,\
                           num_row_total_space, c_i, num_r
                    _reg_mov_batch_head(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                    args = tvm_ib, data_ub, data_res, reg,\
                           num_row_head_actual, num_row_total_space, c_i, num_c
                    _reg_mov_batch_head_store(args)
            # move data for middle
            num_row_mid_actual = param.get("num_ele_one_dim_data")

            with tvm_ib.if_scope(c_i >= 8):
                with tvm_ib.for_range(0, num_mid_n, name="num_md") as num_md:
                    with tvm_ib.for_range(0, num_row_mid_actual,
                                          name="num_r") as num_r:
                        args = tvm_ib, param, data_ub, data_res, reg,\
                               num_row_mid_actual, num_row_total_space,\
                               num_row_group_dim_head, num_row_head_actual, \
                               c_i, num_md, num_r
                        _reg_mov_batch_mid(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, num_mid_n, name="num_md") as num_md:
                    with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                        args = tvm_ib, param, data_ub, data_res, reg,\
                               num_row_mid_actual, num_row_total_space,\
                               num_row_group_dim_head, num_row_head_actual,\
                               c_i, num_md, num_c
                        _reg_mov_batch_mid_store(args)
            # move data for tail
            num_row_tail = num_row_group_tail*param.get("cp_align_len")
            reg_addr[8] = num_row_tail

            with tvm_ib.if_scope(c_i >= 8):
                with tvm_ib.for_range(0, num_row_tail, name="num_r") as num_r:
                    args = tvm_ib, param, data_ub, data_res, reg,\
                           num_row_total_space, num_row_group_dim_head,\
                           num_row_head_actual, num_row_mid_actual, num_mid_n,\
                           c_i, num_r
                    _reg_mov_batch_tail(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                    args = tvm_ib, param, data_ub, data_res, reg,\
                           num_row_total_space, num_row_group_dim_head,\
                           num_row_head_actual, num_row_mid_actual, num_mid_n,\
                           c_i, num_c, reg_addr[8], num_row_tail
                    _reg_mov_batch_tail_store(args)

        with tvm_ib.else_scope():
            num_row_total = num_row_group_cur_core*param.get("cp_align_len")
            with tvm_ib.if_scope(c_i >= 8):
                with tvm_ib.for_range(0, num_row_total, name="num_r") as num_r:
                    args = tvm_ib, data_ub, data_res, reg,\
                           num_row_total, c_i, num_r
                    _reg_mov_batch_head(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, c_i, name="num_c") as num_c:
                    args = tvm_ib, data_ub, data_res, reg,\
                           num_row_total, num_row_total, c_i, num_c
                    _reg_mov_batch_head_store(args)

        # move from data_res(UB) to dst(GM)
        num_row_head_actual = (h_i * w_i) - (
            num_row_group_cur_dim_before * param.get("cp_align_len"))
        num_row_mid_actual = param.get("num_ele_one_dim_data")
        num_row_tail = num_row_group_tail * param.get("cp_align_len")
        total_len = (num_row_head_actual + num_row_mid_actual*num_mid_n
                     + num_row_tail)*c_i
        reg_addr[1] = total_len
        with tvm_ib.if_scope(reg_addr[1] % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(reg_addr[1] > param.get("cp_align_len")):
                total_len_32b_align = reg_addr[1] - param.get("cp_align_len")
                burst_len_align = _ceil_div(total_len_32b_align,
                                            param.get("cp_align_len"))
                dst_offset = num_n_before_core * num_ele_one_n \
                             + num_row_group_cur_dim_before * param.get(
                                 "cp_align_len") * c_i
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, burst_len_align, 0, 0))

                args = tvm_ib, data_res, data_tail, reg, 0, 0,\
                       total_len_32b_align, param.get("cp_align_len")
                _reg_mov_batch_align(args)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset
                                                + total_len_32b_align),
                                            data_tail.access_ptr("r", offset=0),
                                            0, 1, 1, 0, 0))

            with tvm_ib.else_scope():
                dst_offset = num_n_before_core * num_ele_one_n \
                             + num_row_group_cur_dim_before * param.get(
                                 "cp_align_len") * c_i
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            burst_len_dst = reg_addr[1] // param.get("cp_align_len")
            dst_offset = num_n_before_core * num_ele_one_n \
                         + num_row_group_cur_dim_before\
                         * param.get("cp_align_len")*c_i
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _more_row_ir_0231(dst, data, core_divide):
    """
    function of making ir node builder for more row 0231 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_more_row_0231(tvm_ib, data.shape, dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype, param.get('num_block_one_core')
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get('num_block_one_core')
                          * param.get("cp_align_len"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (9,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g, param.get("num_block_one_core")
            _func_more_row_ir_0231(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_block_one_core")
            num_block_mod = param.get("num_group_mod")\
                            % param.get("num_block_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, param.get(
                               "num_block_one_core")
                    _func_more_row_ir_0231(args)
            with tvm_ib.if_scope(num_block_mod > 0):
                with tvm_ib.if_scope(tvm.all(param.get("block_index")
                                             < (num_core + 1),
                                             param.get("block_index")
                                             > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, num_block_mod
                    _func_more_row_ir_0231(args)

    return tvm_ib.get()


def _get_param_split_row_0231(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for split row 0231 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = ((UB_SIZE_B - 32*(cp_align_len + 1)) // 2) // core_divide
    n_i, c_i, h_i, w_i = src_shape
    num_ele_one_dim_data = h_i*w_i
    num_block_one_dim_data = _ceil_div(num_ele_one_dim_data, cp_align_len)
    num_block_in_data = num_block_one_dim_data*n_i*c_i
    num_block_one_n = num_block_one_dim_data*c_i
    ub_ele = ub_bytes // float_size
    num_block_one_core = ub_ele // (cp_align_len + 1)
    num_block_one_group = num_block_one_core*device_core_num
    num_group_index = num_block_in_data // num_block_one_group
    num_group_mod = num_block_in_data % num_block_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_block_one_core": num_block_one_core,
                 "num_block_one_group": num_block_one_group,
                 "num_block_one_dim_data": num_block_one_dim_data,
                 "num_ele_one_dim_data": num_ele_one_dim_data,
                 "num_block_one_n": num_block_one_n}

    return param_map


def _ub_to_gm_split_one(args):
    """
    function of moving data from data_ub to dst in split row 0231 function

    """
    tvm_ib, param, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_n_before_core, num_row_group_cur_n, num_block_cur_row_group,\
    num_ele_one_n, c_i, ub_offset, res_offset, tail_offset, num_block,\
    num_row, n_index = args

    with tvm_ib.for_range(0, num_row, name="num_r") as num_r:
        args = tvm_ib, param, data_ub, data_res, reg, reg_addr, n_index,\
               ub_offset, res_offset, num_block, num_r
        _reg_mov_batch_ci(args)

        with tvm_ib.if_scope(num_block % param.get("cp_align_len") > 0):
            num_len_align = num_block - param.get("cp_align_len")
            dst_offset = num_n_before_core*num_ele_one_n\
                         + (num_row_group_cur_n*param.get("cp_align_len")
                            + num_r)*c_i\
                         + num_block_cur_row_group
            burst_len_one = num_len_align + param.get("cp_align_len") - 1
            reg_addr[n_index] = burst_len_one
            burst_len_dst = reg_addr[n_index] // param.get("cp_align_len")

            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

            args = tvm_ib, data_res, data_tail, reg, res_offset,\
                   tail_offset, num_len_align, param.get("cp_align_len")
            _reg_mov_batch_align(args)

            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=dst_offset + num_len_align),
                                        data_tail.access_ptr(
                                            "r", offset=tail_offset),
                                        0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_n_before_core*num_ele_one_n\
                         + (num_row_group_cur_n*param.get("cp_align_len")
                            + num_r)*c_i\
                         + num_block_cur_row_group
            burst_len_dst = num_block // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _ub_to_gm_split_two(args):
    """
    function of moving data from data_ub to dst in split row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_n_before_core, num_row_group_cur_n, num_block_cur_row_group,\
    num_ele_one_n, c_i, ub_offset, res_offset, tail_offset, num_block,\
    num_row, n_index, num_n_before_tail, num_block_tail_row_group,\
    num_row_group_tail_n = args

    with tvm_ib.for_range(0, num_row, name="num_r") as num_r:
        args = tvm_ib, param, data_ub, data_res, reg, reg_addr, n_index,\
               ub_offset, res_offset, num_block, num_r
        _reg_mov_batch_ci(args)

        with tvm_ib.if_scope(num_block % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(num_block >= param.get("cp_align_len")):
                num_len_align = num_block - param.get("cp_align_len")
                dst_offset = num_n_before_core * num_ele_one_n \
                             + (num_row_group_cur_n * param.get("cp_align_len")
                                + num_r) * c_i \
                             + num_block_cur_row_group
                burst_len_one = num_len_align + param.get("cp_align_len") - 1
                reg_addr[n_index] = burst_len_one
                burst_len_dst = reg_addr[n_index] // param.get("cp_align_len")

                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))

                args = tvm_ib, data_res, data_tail, reg, res_offset, \
                       tail_offset, num_len_align, param.get("cp_align_len")
                _reg_mov_batch_align(args)

                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset
                                                + num_len_align),
                                            data_tail.access_ptr(
                                                "r", offset=tail_offset),
                                            0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                num_block_align = param.get("cp_align_len") - num_block
                with tvm_ib.if_scope(num_r < num_row - 1):
                    with tvm_ib.if_scope(param.get("num_ele_one_dim_data")
                                         % param.get("cp_align_len") > 0):
                        with tvm_ib.for_range(0, num_block_align,
                                              name="num_ba") as num_ba:
                            data_offset = num_n_before_core * num_ele_one_n\
                                          + num_ba\
                                          * param.get("num_ele_one_dim_data")\
                                          + num_row_group_cur_n\
                                          * param.get("cp_align_len")\
                                          + num_r + 1
                            tail_offset = num_ba * param.get("cp_align_len")
                            tvm_ib.emit(
                                tvm.call_extern(data_tail.dtype,
                                                "copy_gm_to_ubuf",
                                                data_tail.access_ptr(
                                                    "w", offset=tail_offset),
                                                data.access_ptr(
                                                    'r',
                                                    offset=data_offset),
                                                0, 1, 1, 0, 0))
                    with tvm_ib.else_scope():
                        data_offset = num_n_before_core * num_ele_one_n\
                                      + num_row_group_cur_n\
                                      * param.get("cp_align_len")\
                                      + num_r + 1
                        src_stride = param.get("num_ele_one_dim_data")\
                                     // param.get("cp_align_len") - 1
                        args = tvm_ib, param, data, data_tail, data_offset, 0,\
                               num_block_align, 1, src_stride, 0
                        _func_gm_to_ub(args)
                with tvm_ib.else_scope():
                    with tvm_ib.if_scope(
                        param.get("num_ele_one_dim_data") % param.get(
                            "cp_align_len") > 0):
                        with tvm_ib.for_range(0, num_block_align,
                                              name="num_ba") as num_ba:
                            data_offset = num_n_before_tail * num_ele_one_n\
                                          + (num_block_tail_row_group + num_ba)\
                                          * param.get("num_ele_one_dim_data")\
                                          + num_row_group_tail_n\
                                          * param.get("cp_align_len")
                            tail_offset = num_ba*param.get("cp_align_len")
                            tvm_ib.emit(
                                tvm.call_extern(data_tail.dtype,
                                                "copy_gm_to_ubuf",
                                                data_tail.access_ptr(
                                                    "w", offset=tail_offset),
                                                data.access_ptr(
                                                    'r',
                                                    offset=data_offset),
                                                0, 1, 1, 0, 0))
                    with tvm_ib.else_scope():
                        data_offset = num_n_before_tail * num_ele_one_n \
                                      + num_block_tail_row_group\
                                      * param.get("num_ele_one_dim_data")\
                                      + num_row_group_tail_n\
                                      * param.get("cp_align_len")
                        src_stride = param.get("num_ele_one_dim_data")\
                                     // param.get("cp_align_len") - 1
                        args = tvm_ib, param, data, data_tail, data_offset, 0,\
                               num_block_align, 1, src_stride, 0
                        _func_gm_to_ub(args)

                with tvm_ib.for_range(0, num_block_align, name="num_ba")\
                        as num_ba:
                    tvm_ib.emit(tvm.call_extern(
                        data_tail.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_tail.access_ptr(
                            'r', offset=num_ba*param.get("cp_align_len"))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        data_res.access_ptr(
                            'w', offset=res_offset + num_block + num_ba),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))

                dst_offset = num_n_before_core * num_ele_one_n \
                             + (num_row_group_cur_n * param.get("cp_align_len")
                                + num_r) * c_i \
                             + num_block_cur_row_group
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_n_before_core*num_ele_one_n\
                         + (num_row_group_cur_n*param.get("cp_align_len")
                            + num_r)*c_i\
                         + num_block_cur_row_group
            burst_len_dst = num_block // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _ub_to_gm_split_three(args):
    """
    function of moving data from data_ub to dst in split row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_n_before_core, num_row_group_cur_n, num_block_cur_row_group,\
    num_ele_one_n, c_i, ub_offset, res_offset, tail_offset, num_block,\
    num_row, n_index = args

    with tvm_ib.for_range(0, num_row, name="num_r") as num_r:
        args = tvm_ib, param, data_ub, data_res, reg, reg_addr, n_index,\
               ub_offset, res_offset, num_block, num_r
        _reg_mov_batch_ci(args)

        with tvm_ib.if_scope(num_block % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(num_block >= param.get("cp_align_len")):
                num_len_align = num_block - param.get("cp_align_len")
                dst_offset = num_n_before_core * num_ele_one_n \
                             + (num_row_group_cur_n * param.get("cp_align_len")
                                + num_r) * c_i \
                             + num_block_cur_row_group
                burst_len_one = num_len_align + param.get("cp_align_len") - 1
                reg_addr[n_index] = burst_len_one
                burst_len_dst = reg_addr[n_index] // param.get("cp_align_len")

                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))

                args = tvm_ib, data_res, data_tail, reg, res_offset, \
                       tail_offset, num_len_align, param.get("cp_align_len")
                _reg_mov_batch_align(args)

                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset
                                                + num_len_align),
                                            data_tail.access_ptr(
                                                "r", offset=tail_offset),
                                            0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                num_block_align = param.get("cp_align_len") - num_block
                with tvm_ib.if_scope(
                    param.get("num_ele_one_dim_data")
                    % param.get("cp_align_len") > 0):
                    with tvm_ib.for_range(0, num_block_align,
                                          name="num_ba") as num_ba:
                        data_offset = num_n_before_core * num_ele_one_n\
                                      + (num_block_cur_row_group
                                         + num_block + num_ba)\
                                      * param.get("num_ele_one_dim_data")\
                                      + num_row_group_cur_n\
                                      * param.get("cp_align_len")\
                                      + num_r
                        tail_offset = num_ba*param.get("cp_align_len")
                        tvm_ib.emit(
                            tvm.call_extern(data_tail.dtype,
                                            "copy_gm_to_ubuf",
                                            data_tail.access_ptr(
                                                "w", offset=tail_offset),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset),
                                            0, 1, 1, 0, 0))
                with tvm_ib.else_scope():
                    data_offset = num_n_before_core * num_ele_one_n \
                                  + (num_block_cur_row_group + num_block)\
                                  * param.get("num_ele_one_dim_data") \
                                  + num_row_group_cur_n\
                                  * param.get("cp_align_len") \
                                  + num_r
                    src_stride = param.get("num_ele_one_dim_data")\
                                 // param.get("cp_align_len") - 1
                    args = tvm_ib, param, data, data_tail, data_offset,\
                           0, num_block_align, 1, src_stride, 0
                    _func_gm_to_ub(args)

                with tvm_ib.for_range(0, num_block_align, name="num_ba")\
                        as num_ba:
                    tvm_ib.emit(tvm.call_extern(
                        data_tail.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_tail.access_ptr(
                            'r', offset=num_ba*param.get("cp_align_len"))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        data_res.access_ptr(
                            'w', offset=res_offset + num_block + num_ba),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))

                dst_offset = num_n_before_core * num_ele_one_n \
                             + (num_row_group_cur_n * param.get("cp_align_len")
                                + num_r) * c_i \
                             + num_block_cur_row_group
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_n_before_core*num_ele_one_n\
                         + (num_row_group_cur_n*param.get("cp_align_len")
                            + num_r)*c_i\
                         + num_block_cur_row_group
            burst_len_dst = num_block // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _func_split_row_ir_0231(args):
    """
    function of moving data in split row 0231 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_g, num_block_cur_core = args

    _, c_i, h_i, w_i = data.shape
    num_ele_one_n = c_i * h_i * w_i
    num_block_before_core = num_g*param.get("num_block_one_group")\
                            + param.get("block_index")\
                            * param.get("num_block_one_core")
    num_n_before_core = num_block_before_core // param.get("num_block_one_n")
    num_block_cur_n = num_block_before_core % param.get("num_block_one_n")
    num_row_group_cur_n = num_block_cur_n // c_i
    num_block_cur_row_group = num_block_cur_n % c_i
    num_block_head = c_i - num_block_cur_row_group
    reg_addr[0] = num_block_head

    with tvm_ib.if_scope(num_block_head >= num_block_cur_core):
        # move from data(GM) to data_ub(UB)
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data") % param.get(
            "cp_align_len") > 0):
            with tvm_ib.for_range(0, num_block_cur_core, name="num_b") as num_b:
                data_offset = num_n_before_core * num_ele_one_n\
                              + (num_block_cur_row_group + num_b)\
                              * param.get("num_ele_one_dim_data")\
                              + num_row_group_cur_n * param.get("cp_align_len")
                ub_offset = num_b*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr('r',
                                                            offset=data_offset),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            data_offset = num_n_before_core * num_ele_one_n\
                          + num_block_cur_row_group * param.get(
                              "num_ele_one_dim_data")\
                          + num_row_group_cur_n * param.get("cp_align_len")
            src_stride = param.get("num_block_one_dim_data") - 1
            args = tvm_ib, param, data, data_ub, data_offset, 0,\
                   num_block_cur_core, 1, src_stride, 0
            _func_gm_to_ub(args)

        # move from data_ub(UB) to data_res(UB)
        with tvm_ib.if_scope(num_row_group_cur_n
                             < param.get("num_block_one_dim_data") - 1):
            num_row = param.get("cp_align_len")
            args = tvm_ib, param, dst, data_ub, data_res, data_tail, reg,\
                   reg_addr, num_n_before_core, num_row_group_cur_n,\
                   num_block_cur_row_group, num_ele_one_n, c_i,\
                   0, 0, 0, num_block_cur_core, num_row, 2
            _ub_to_gm_split_one(args)
        with tvm_ib.else_scope():
            num_row = param.get("num_ele_one_dim_data")\
                      - num_row_group_cur_n*param.get("cp_align_len")
            args = tvm_ib, param, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_n_before_core,\
                   num_row_group_cur_n, num_block_cur_row_group,\
                   num_ele_one_n, c_i, 0, 0, 0, num_block_cur_core, num_row, 3
            _ub_to_gm_split_one(args)

    with tvm_ib.if_scope(num_block_head < num_block_cur_core):
        # move from data to data_ub for head
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data") % param.get(
            "cp_align_len") > 0):
            with tvm_ib.for_range(0, reg_addr[0], name="num_b") as num_b:
                data_offset_head = num_n_before_core * num_ele_one_n\
                              + (num_block_cur_row_group + num_b)\
                                   * param.get("num_ele_one_dim_data")\
                              + num_row_group_cur_n * param.get("cp_align_len")
                ub_offset_head = num_b*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset_head),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_head),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            data_offset_head = num_n_before_core * num_ele_one_n\
                          + num_block_cur_row_group * param.get(
                              "num_ele_one_dim_data")\
                          + num_row_group_cur_n * param.get("cp_align_len")
            src_stride = param.get("num_block_one_dim_data") - 1
            args = tvm_ib, param, data, data_ub, data_offset_head,\
                   0, reg_addr[0], 1, src_stride, 0
            _func_gm_to_ub(args)

        # move from data to data_ub for tail
        num_block_tail = num_block_cur_core - num_block_head
        reg_addr[1] = num_block_tail
        num_block_before_tail = num_block_before_core + reg_addr[0]
        num_n_before_tail = num_block_before_tail\
                            // param.get("num_block_one_n")
        num_block_tail_n = num_block_before_tail % param.get("num_block_one_n")
        num_row_group_tail_n = num_block_tail_n // c_i
        num_block_tail_row_group = 0
        ub_offset_tail_begin = reg_addr[0]*param.get("cp_align_len")

        # move from data to data_ub for tail
        with tvm_ib.if_scope(param.get("num_ele_one_dim_data") % param.get(
            "cp_align_len") > 0):
            with tvm_ib.for_range(0, num_block_tail, name="num_b") as num_b:
                data_offset_tail = num_n_before_tail * num_ele_one_n\
                              + (num_block_tail_row_group + num_b)\
                                   * param.get("num_ele_one_dim_data")\
                              + num_row_group_tail_n\
                                   * param.get("cp_align_len")
                ub_offset_tail = ub_offset_tail_begin\
                                 + num_b*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset_tail),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_tail),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            data_offset_tail = num_n_before_tail*num_ele_one_n\
                          + num_block_tail_row_group\
                               * param.get("num_ele_one_dim_data")\
                          + num_row_group_tail_n*param.get("cp_align_len")
            src_stride = param.get("num_block_one_dim_data") - 1
            args = tvm_ib, param, data, data_ub, data_offset_tail,\
                   ub_offset_tail_begin, reg_addr[1], 1, src_stride, 0
            _func_gm_to_ub(args)

        # move from data_ub to data_res to gm for head
        with tvm_ib.if_scope(num_row_group_cur_n
                             < param.get("num_block_one_dim_data") - 1):
            num_row = param.get("cp_align_len")
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_n_before_core, num_row_group_cur_n,\
                   num_block_cur_row_group, num_ele_one_n, c_i,\
                   0, 0, 0, reg_addr[0], num_row, 4, num_n_before_tail,\
                   num_block_tail_row_group, num_row_group_tail_n
            _ub_to_gm_split_two(args)
        with tvm_ib.else_scope():
            num_row = param.get(
                "num_ele_one_dim_data") - num_row_group_cur_n * param.get(
                    "cp_align_len")
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg,\
                   reg_addr, num_n_before_core, num_row_group_cur_n,\
                   num_block_cur_row_group, num_ele_one_n, c_i,\
                   0, 0, 0, reg_addr[0], num_row, 5, num_n_before_tail,\
                   num_block_tail_row_group, num_row_group_tail_n
            _ub_to_gm_split_two(args)

        # move from data_ub to data_res to gm for tail
        ub_offset_tail = reg_addr[0]*param.get("cp_align_len")
        reg_offset_one = reg_addr[0] + param.get("cp_align_len") - 1
        reg_addr[8] = reg_offset_one
        res_offset_tail = (reg_addr[8] // param.get("cp_align_len"))\
                          * param.get("cp_align_len")
        tail_offset = param.get("cp_align_len")

        with tvm_ib.if_scope(num_row_group_tail_n
                             < param.get("num_block_one_dim_data") - 1):
            num_row = param.get("cp_align_len")
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_n_before_tail, num_row_group_tail_n,\
                   num_block_tail_row_group, num_ele_one_n, c_i,\
                   ub_offset_tail, res_offset_tail, tail_offset,\
                   reg_addr[1], num_row, 6
            _ub_to_gm_split_three(args)
        with tvm_ib.else_scope():
            num_row = param.get(
                "num_ele_one_dim_data") - num_row_group_tail_n * param.get(
                    "cp_align_len")
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_n_before_tail, num_row_group_tail_n,\
                   num_block_tail_row_group, num_ele_one_n, c_i,\
                   ub_offset_tail, res_offset_tail, tail_offset,\
                   reg_addr[1], num_row, 7
            _ub_to_gm_split_three(args)


def _split_row_ir_0231(dst, data, core_divide):
    """
    function of making ir node builder for split row 0231 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_split_row_0231(tvm_ib, data.shape,
                                      dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype, param.get('num_block_one_core')
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get('num_block_one_core')
                          + param.get("cp_align_len"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len')
                           * param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (10,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g, param.get("num_block_one_core")
            _func_split_row_ir_0231(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_block_one_core")
            num_block_mod = param.get("num_group_mod")\
                            % param.get("num_block_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, param.get(
                               "num_block_one_core")
                    _func_split_row_ir_0231(args)
            with tvm_ib.if_scope(num_block_mod > 0):
                with tvm_ib.if_scope(tvm.all(param.get("block_index")
                                             < (num_core + 1),
                                             param.get("block_index")
                                             > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, num_block_mod
                    _func_split_row_ir_0231(args)

    return tvm_ib.get()


def _func_gm_to_ub(args):
    """
    function of moving data from data to data_ub

    """
    tvm_ib, param, data, data_ub, data_offset, ub_offset, ori_nburst,\
    burst_len, src_stride, dst_stride = args

    with tvm_ib.if_scope(ori_nburst > 0):
        with tvm_ib.if_scope(burst_len > 0):
            with tvm_ib.if_scope(burst_len <= 65535):
                with tvm_ib.if_scope(src_stride >= 0):
                    with tvm_ib.if_scope(dst_stride >= 0):
                        with tvm_ib.if_scope(dst_stride <= 65535):
                            with tvm_ib.if_scope(src_stride <= 65535):
                                with tvm_ib.if_scope(ori_nburst <= 4095):
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_ub.dtype,
                                            "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr(
                                                'r', offset=data_offset),
                                            0, ori_nburst,
                                            burst_len,
                                            src_stride, dst_stride))
                                with tvm_ib.else_scope():
                                    n_burst = 4095
                                    c_cycle = ori_nburst // n_burst
                                    c_mod = ori_nburst % n_burst
                                    with tvm_ib.for_range(0, c_cycle,
                                                          name="num_cy")\
                                            as num_cy:
                                        data_cur = data_offset + (
                                            burst_len + src_stride) \
                                                   * param.get("cp_align_len")\
                                                   * n_burst * num_cy
                                        ub_cur = ub_offset + (
                                            burst_len + dst_stride) \
                                                 * param.get("cp_align_len")\
                                                 * n_burst * num_cy
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w",
                                                    offset=ub_cur),
                                                data.access_ptr(
                                                    'r',
                                                    offset=data_cur),
                                                0, n_burst,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                                    with tvm_ib.if_scope(c_mod > 0):
                                        data_cur = data_offset + (
                                            burst_len + src_stride) \
                                                   * param.get("cp_align_len")\
                                                   * n_burst * c_cycle
                                        ub_cur = ub_offset + (
                                            burst_len + dst_stride) \
                                                 * param.get("cp_align_len")\
                                                 * n_burst * c_cycle
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w", offset=ub_cur),
                                                data.access_ptr(
                                                    'r', offset=data_cur),
                                                0, c_mod, burst_len,
                                                src_stride,
                                                dst_stride))
                            with tvm_ib.else_scope():
                                with tvm_ib.for_range(0, ori_nburst,
                                                      name="num_nb") as num_nb:
                                    data_cur = data_offset + (
                                        burst_len + src_stride)\
                                               * param.get("cp_align_len")\
                                               * num_nb
                                    ub_cur = ub_offset + (
                                        burst_len + dst_stride)\
                                             * param.get("cp_align_len")\
                                             * num_nb
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_ub.dtype,
                                            "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_cur),
                                            data.access_ptr(
                                                'r', offset=data_cur),
                                            0, 1, burst_len,
                                            0, 0))


def _get_param_more_dim_0312(tvm_ib, src_shape, dtype):
    """
    calculate parameters for more dim 0312 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    n_i, h_i, w_i, c_i = src_shape
    num_row_one_dim = h_i*w_i
    dim_space = num_row_one_dim*cp_align_len
    dim_space_bytes = dim_space*float_size
    num_dim_one_core = ub_half // dim_space_bytes
    num_dim_in_data = _ceil_div(c_i, cp_align_len)*n_i
    num_dim_one_group = num_dim_one_core*device_core_num
    num_group_index = num_dim_in_data // num_dim_one_group
    num_group_mod = num_dim_in_data % num_dim_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index, "num_row_one_dim": num_row_one_dim,
                 "num_dim_one_core": num_dim_one_core, "dim_space": dim_space,
                 "num_dim_one_group": num_dim_one_group}

    return param_map


def _reg_mov_batch_row(args):
    """
    reg_mov data for _ub_to_res function

    """
    tvm_ib, data_ub, data_res, reg, ub_offset, res_offset,\
    num_row, num_col_space, num_c = args

    ele_reg = 8
    r_cycle = num_row // ele_reg
    r_mod = num_row - ele_reg * r_cycle
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * num_col_space + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * num_col_space + num_c)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + num_c * num_row
                                + (num_cr*ele_reg + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.if_scope(r_mod > 0):
        with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
            tvm_ib.emit(tvm.call_extern(
                data_ub.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_ub.access_ptr('r',
                                   offset=ub_offset + (r_cycle*ele_reg + num_er)
                                   * num_col_space + num_c)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                data_res.access_ptr('w', offset=res_offset + num_c * num_row
                                    + (r_cycle*ele_reg + num_er)),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))


def _ub_to_res(args):
    """
    function of moving data from data_ub to data_res

    """
    tvm_ib, data_ub, data_res, reg, ub_offset, res_offset, num_row,\
    num_col, num_col_space = args

    with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
        args = tvm_ib, data_ub, data_res, reg, ub_offset, res_offset, num_row,\
               num_col_space, num_c
        _reg_mov_batch_row(args)


def _res_to_gm(args):
    """
    function of moving data from data_res to dst

    """
    tvm_ib, param, dst, data_res, data_tail, reg, reg_addr, index, total_len,\
    dst_offset, res_offset = args

    with tvm_ib.if_scope(total_len % param.get("cp_align_len") > 0):
        with tvm_ib.if_scope(total_len > param.get("cp_align_len")):
            total_len_align = total_len - param.get("cp_align_len")
            burst_len_one = total_len_align + param.get("cp_align_len") - 1
            reg_addr[index] = burst_len_one
            burst_len_dst = reg_addr[index] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r",
                                                            offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))
            args = tvm_ib, data_res, data_tail, reg, res_offset,\
                   0, total_len_align, param.get("cp_align_len")
            _reg_mov_batch_align(args)
            reg_addr[index] = total_len_align
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=dst_offset
                                            + reg_addr[index]),
                                        data_tail.access_ptr("r",
                                                             offset=0),
                                        0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r",
                                                            offset=res_offset),
                                        0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        burst_len_dst = total_len // param.get("cp_align_len")
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_more_dim_ir_0312(args):
    """
    function of moving data in more dim 0312 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg, reg_addr,\
    num_g, num_dim_cur_core = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_ele_block_col = h_i*w_i*c_i
    num_row_one_dim = h_i * w_i
    num_dim_before_core = num_g*param.get("num_dim_one_group")\
                          + param.get("block_index")\
                          * param.get("num_dim_one_core")
    num_block_col_before_core = num_dim_before_core // num_dim_block_col
    num_dim_block_col_before = num_dim_before_core % num_dim_block_col
    num_dim_cur_block_col = num_dim_block_col - num_dim_block_col_before

    with tvm_ib.if_scope(num_dim_cur_core <= num_dim_cur_block_col):
        # move data to data_ub
        with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, num_row_one_dim, name="num_r") as num_r:
                data_offset = num_block_col_before_core*num_ele_block_col\
                              + num_dim_block_col_before\
                              * param.get("cp_align_len")\
                              + num_r*c_i
                ub_offset = num_r*num_dim_cur_core*param.get("cp_align_len")
                burst_len = num_dim_cur_core
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr('r',
                                                            offset=data_offset),
                                            0, 1, burst_len, 0, 0))
        with tvm_ib.else_scope():
            data_offset = num_block_col_before_core * num_ele_block_col \
                          + num_dim_block_col_before * param.get("cp_align_len")
            n_burst = num_row_one_dim
            burst_len = num_dim_cur_core
            src_stride = num_dim_block_col - num_dim_cur_core
            args = tvm_ib, param, data, data_ub, data_offset,\
                   0, n_burst, burst_len, src_stride, 0
            _func_gm_to_ub(args)

        # move data_ub to data_res to dst
        num_col_space = num_dim_cur_core*param.get("cp_align_len")
        with tvm_ib.if_scope(num_dim_cur_core < num_dim_cur_block_col):
            num_col = num_col_space
            args = tvm_ib, data_ub, data_res, reg, 0, 0,\
                   num_row_one_dim, num_col, num_col_space
            _ub_to_res(args)

            total_len = num_col*num_row_one_dim
            dst_offset = num_block_col_before_core*num_ele_block_col \
                         + num_dim_block_col_before\
                         * num_row_one_dim*param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, data_tail, reg,\
                   reg_addr, 1, total_len, dst_offset, 0
            _res_to_gm(args)
        with tvm_ib.else_scope():
            num_col = c_i - num_dim_block_col_before*param.get("cp_align_len")
            args = tvm_ib, data_ub, data_res, reg, 0, 0,\
                   num_row_one_dim, num_col, num_col_space
            _ub_to_res(args)

            total_len = num_col*num_row_one_dim
            reg_addr[4] = total_len
            dst_offset = num_block_col_before_core*num_ele_block_col \
                         + num_dim_block_col_before\
                         * num_row_one_dim*param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, data_tail, reg,\
                   reg_addr, 2, reg_addr[4], dst_offset, 0
            _res_to_gm(args)
    with tvm_ib.if_scope(num_dim_cur_core > num_dim_cur_block_col):
        num_dim_head = num_dim_cur_block_col
        num_dim_after = num_dim_cur_core - num_dim_head
        reg_addr[0] = num_dim_after
        num_mid_block_col = reg_addr[0] // num_dim_block_col
        num_dim_tail = reg_addr[0] % num_dim_block_col

        # move data for head
        data_offset = num_block_col_before_core * num_ele_block_col \
                      + num_dim_block_col_before * param.get("cp_align_len")
        with tvm_ib.if_scope(num_dim_head > 0):
            # move data to data_ub
            with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, num_row_one_dim,
                                      name="num_r") as num_r:
                    data_offset_cur = data_offset + num_r * c_i
                    ub_offset = num_r * num_dim_head * param.get(
                        "cp_align_len")
                    burst_len = num_dim_head
                    tvm_ib.emit(
                        tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset_cur),
                                        0, 1, burst_len, 0, 0))
            with tvm_ib.else_scope():
                n_burst = num_row_one_dim
                burst_len = num_dim_head
                src_stride = num_dim_block_col - num_dim_head
                args = tvm_ib, param, data, data_ub, data_offset, 0,\
                       n_burst, burst_len, src_stride, 0
                _func_gm_to_ub(args)

            # move data_ub to data_res
            num_col = c_i - num_dim_block_col_before*param.get("cp_align_len")
            num_col_space = num_dim_head*param.get("cp_align_len")
            args = tvm_ib, data_ub, data_res, reg, 0, 0,\
                   num_row_one_dim, num_col, num_col_space
            _ub_to_res(args)

        # move data for middle
        with tvm_ib.if_scope(num_mid_block_col > 0):
            data_offset_mid = (num_block_col_before_core + 1)*num_ele_block_col
            ub_offset_mid = num_dim_head * param.get(
                "cp_align_len") * num_row_one_dim
            burst_len_mid_one = num_mid_block_col*num_ele_block_col\
                                + param.get("cp_align_len") - 1
            reg_addr[6] = burst_len_mid_one
            burst_len_mid = reg_addr[6] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset_mid),
                                        data.access_ptr('r',
                                                        offset=data_offset_mid),
                                        0, 1, burst_len_mid, 0, 0))
            # move data_ub to data_res
            res_offset = (c_i - num_dim_block_col_before
                          * param.get("cp_align_len"))*num_row_one_dim
            with tvm_ib.for_range(0, num_mid_block_col, name="num_m")as num_m:
                ub_offset_cur = ub_offset_mid + num_m*num_ele_block_col
                res_offset_cur = res_offset + num_m*num_ele_block_col
                args = tvm_ib, data_ub, data_res, reg, ub_offset_cur,\
                       res_offset_cur, num_row_one_dim, c_i, c_i
                _ub_to_res(args)

        # move data for tail
        with tvm_ib.if_scope(num_dim_tail > 0):
            data_offset_tail = (num_block_col_before_core
                                + num_mid_block_col + 1) * num_ele_block_col
            burst_len_mid_one = num_mid_block_col*num_ele_block_col\
                                + param.get("cp_align_len") - 1
            reg_addr[6] = burst_len_mid_one
            mid_one = (reg_addr[6] // param.get("cp_align_len"))\
                      * param.get("cp_align_len")
            ub_offset_tail = num_dim_head*param.get("cp_align_len")\
                             * num_row_one_dim\
                             + mid_one
            with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, num_row_one_dim,
                                      name="num_r") as num_r:
                    data_offset_cur = data_offset_tail + num_r * c_i
                    ub_offset = ub_offset_tail + num_r*num_dim_tail\
                                * param.get("cp_align_len")
                    burst_len = num_dim_tail
                    tvm_ib.emit(
                        tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset_cur),
                                        0, 1, burst_len, 0, 0))
            with tvm_ib.else_scope():
                n_burst = num_row_one_dim
                burst_len = num_dim_tail
                src_stride = num_dim_block_col - num_dim_tail
                args = tvm_ib, param, data, data_ub, data_offset_tail,\
                       ub_offset_tail, n_burst, burst_len, src_stride, 0
                _func_gm_to_ub(args)

            # move data_ub to data_res
            res_offset_tail = (c_i - num_dim_block_col_before
                               * param.get("cp_align_len")
                               + num_mid_block_col*c_i)*num_row_one_dim
            num_col = num_dim_tail*param.get("cp_align_len")
            reg_addr[7] = num_col
            args = tvm_ib, data_ub, data_res, reg, ub_offset_tail,\
                   res_offset_tail, num_row_one_dim, reg_addr[7], num_col
            _ub_to_res(args)

        # move data_res to dst
        total_len = (c_i - num_dim_block_col_before*param.get("cp_align_len")
                     + num_mid_block_col*c_i + num_dim_tail
                     * param.get("cp_align_len"))*num_row_one_dim
        reg_addr[5] = total_len
        dst_offset = num_block_col_before_core * num_ele_block_col \
                     + num_dim_block_col_before \
                     * num_row_one_dim * param.get("cp_align_len")
        args = tvm_ib, param, dst, data_res, data_tail, reg,\
               reg_addr, 3, reg_addr[5], dst_offset, 0
        _res_to_gm(args)


def _more_dim_ir_0312(dst, data):
    """
    function of making ir node builder for more dim ir 0312 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_more_dim_0312(tvm_ib, data.shape, dst.dtype)
    data_ub = _new_alloc(tvm_ib, dst.dtype, param.get('num_dim_one_core')
                         * param.get("dim_space"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get('num_dim_one_core')
                          * param.get("dim_space"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g, param.get("num_dim_one_core")
            _func_more_dim_ir_0312(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_dim_one_core")
            num_dim_mod = param.get("num_group_mod")\
                          % param.get("num_dim_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, param.get(
                               "num_dim_one_core")
                    _func_more_dim_ir_0312(args)
            with tvm_ib.if_scope(num_dim_mod > 0):
                with tvm_ib.if_scope(tvm.all(param.get("block_index")
                                             < (num_core + 1),
                                             param.get("block_index")
                                             > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g, num_dim_mod
                    _func_more_dim_ir_0312(args)

    return tvm_ib.get()


def _get_param_one_dim_0312(tvm_ib, src_shape, dtype):
    """
    calculate parameters for one dim 0312 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    n_i, _, _, c_i = src_shape
    num_dim_in_data = _ceil_div(c_i, cp_align_len)*n_i
    num_dim_one_core = 1
    num_dim_one_group = num_dim_one_core*device_core_num
    num_group_index = num_dim_in_data // num_dim_one_group
    num_group_mod = num_dim_in_data % num_dim_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_dim_one_core": num_dim_one_core,
                 "num_dim_one_group": num_dim_one_group,
                 "num_dim_in_data": num_dim_in_data}

    return param_map


def _reg_mov_batch_one(args):
    """
    reg_mov data in ub for one dim and split dim scene

    """
    tvm_ib, data_ub, data_res, reg, reg_addr, index, ub_offset,\
    res_offset, num_row, num_c, cp_len = args

    ele_reg = 8
    r_cycle = num_row // ele_reg
    r_mod = num_row % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * cp_len + num_c)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    reg_addr[index] = r_mod
    with tvm_ib.for_range(0, reg_addr[index], name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (r_cycle*ele_reg + num_er)
                               * cp_len + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=res_offset + (r_cycle*ele_reg
                                                          + num_er)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_one_dim_ir_0312(args):
    """
    function of moving data in one dim 0312 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg,\
    reg_addr, num_g = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_ele_block_col = h_i*w_i*c_i
    num_row_one_dim = h_i * w_i
    num_dim_before_core = num_g*param.get("num_dim_one_group")\
                          + param.get("block_index")\
                          * param.get("num_dim_one_core")
    num_block_col_before = num_dim_before_core // num_dim_block_col
    num_dim_col_before = num_dim_before_core % num_dim_block_col
    num_col = tvm.min((num_dim_col_before + 1)*param.get("cp_align_len"), c_i)\
              - num_dim_col_before*param.get("cp_align_len")

    data_offset = num_block_col_before*num_ele_block_col\
                  + num_dim_col_before*param.get("cp_align_len")
    with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
        with tvm_ib.for_range(0, num_row_one_dim, name="num_r") as num_r:
            data_offset_cur = data_offset + num_r*c_i
            ub_offset_cur = num_r*param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset_cur),
                                        data.access_ptr('r',
                                                        offset=data_offset_cur),
                                        0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        n_burst = num_row_one_dim
        src_stride = num_dim_block_col - 1
        args = tvm_ib, param, data, data_ub, data_offset, 0, n_burst,\
               1, src_stride, 0
        _func_gm_to_ub(args)

    with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
        args = tvm_ib, data_ub, data_res, reg, reg_addr,\
               1, 0, 0, num_row_one_dim, num_c, param.get("cp_align_len")
        _reg_mov_batch_one(args)
        dst_offset = num_block_col_before * num_ele_block_col\
                     + num_dim_col_before*num_row_one_dim\
                     * param.get("cp_align_len")
        dst_offset_cur = dst_offset + num_row_one_dim * num_c
        args = tvm_ib, param, dst, data_res, data_tail, reg,\
               reg_addr, 0, num_row_one_dim, dst_offset_cur, 0
        _res_to_gm(args)


def _one_dim_ir_0312(dst, data):
    """
    function of making ir node builder for one dim 0312 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_one_dim_0312(tvm_ib, data.shape, dst.dtype)
    _, h_i, w_i, _ = data.shape
    num_row_one_dim = h_i * w_i
    data_ub = _new_alloc(tvm_ib, dst.dtype, num_row_one_dim
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, num_row_one_dim,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g
            _func_one_dim_ir_0312(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_dim_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g
                    _func_one_dim_ir_0312(args)

    return tvm_ib.get()


def _get_param_one_dim_0312_small(tvm_ib, src_shape, dtype):
    """
    calculate parameters for one dim 0312 small ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    n_i, _, _, c_i = src_shape
    num_dim_in_data = _ceil_div(c_i, cp_align_len)*n_i
    num_dim_one_core = 1
    num_dim_one_group = num_dim_one_core*device_core_num
    num_group_index = num_dim_in_data // num_dim_one_group
    num_group_mod = num_dim_in_data % num_dim_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_dim_one_core": num_dim_one_core,
                 "num_dim_one_group": num_dim_one_group,
                 "num_dim_in_data": num_dim_in_data}

    return param_map


def _func_one_dim_ir_0312_small(args):
    """
    function of movint data in one dim 0312 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, reg,\
    reg_addr, num_g = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_ele_block_col = h_i*w_i*c_i
    num_row_one_dim = h_i * w_i
    num_dim_before_core = num_g*param.get("num_dim_one_group")\
                          + param.get("block_index")\
                          * param.get("num_dim_one_core")
    num_block_col_before = num_dim_before_core // num_dim_block_col
    num_dim_col_before = num_dim_before_core % num_dim_block_col
    num_col = c_i

    data_offset = num_block_col_before*num_ele_block_col

    burst_len_data = num_row_one_dim*c_i
    total_len_data = _ceil_div(burst_len_data, param.get("cp_align_len"))
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, total_len_data, 0, 0))

    with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
        args = tvm_ib, data_ub, data_res, reg, reg_addr,\
               1, 0, 0, num_row_one_dim, num_c, c_i
        _reg_mov_batch_one(args)
        dst_offset = num_block_col_before * num_ele_block_col\
                     + num_dim_col_before*num_row_one_dim\
                     * param.get("cp_align_len")
        dst_offset_cur = dst_offset + num_row_one_dim * num_c
        args = tvm_ib, param, dst, data_res, data_tail, reg,\
               reg_addr, 0, num_row_one_dim, dst_offset_cur, 0
        _res_to_gm(args)


def _one_dim_ir_0312_small(dst, data):
    """
    function of making ir node builder for one dim 0312 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_one_dim_0312_small(tvm_ib, data.shape, dst.dtype)
    _, h_i, w_i, c_i = data.shape
    num_row_one_dim = h_i * w_i
    data_ub = _new_alloc(tvm_ib, dst.dtype, num_row_one_dim*c_i,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, num_row_one_dim,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1, name="num_g")\
            as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   reg, reg_addr, num_g
            _func_one_dim_ir_0312_small(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod")\
                       // param.get("num_dim_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_tail, reg, reg_addr, num_g
                    _func_one_dim_ir_0312_small(args)

    return tvm_ib.get()


def _get_param_split_dim_0312(tvm_ib, src_shape, dtype):
    """
    calculate parameters for split dim 0312 ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 96
    n_i, h_i, w_i, c_i = src_shape
    num_row_one_dim = h_i*w_i
    num_row_dim_space = _ceil_fill(num_row_one_dim, cp_align_len)
    num_dim_block_col = _ceil_div(c_i, cp_align_len)
    num_row_in_data = num_row_dim_space*num_dim_block_col*n_i\
                      - (num_row_dim_space - num_row_one_dim)
    ub_ele = ub_bytes // float_size
    num_row_one_core_one = ub_ele // (cp_align_len + 1)
    num_row_one_core = (num_row_one_core_one // cp_align_len) * cp_align_len
    num_row_one_group = num_row_one_core * device_core_num
    num_group_index = num_row_in_data // num_row_one_group
    num_group_mod = num_row_in_data % num_row_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_row_one_dim": num_row_one_dim,
                 "num_row_one_core": num_row_one_core,
                 "num_row_one_group": num_row_one_group,
                 "num_row_in_data_space": num_row_in_data}

    return param_map


def _reg_mov_batch_one_cp_align(args):
    """
    reg_mov cp_align_len data for batch scene in split dim 0312 function

    """
    tvm_ib, param, data_ub, data_res, reg, ub_offset, res_offset,\
    num_row, num_c = args

    ele_reg = 8
    r_cycle = num_row // ele_reg
    r_mod = num_row % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_zero)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_one)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_two)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_three)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_four)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_five)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_six)
                               * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=ub_offset + (num_cr*ele_reg + reg_seven)
                               * param.get("cp_align_len") + num_c)
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=res_offset + (num_cr*ele_reg
                                                     + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr(
                'r',
                offset=ub_offset + (r_cycle*ele_reg + num_er)
                * param.get("cp_align_len") + num_c)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=res_offset + (
                r_cycle * ele_reg + num_er)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _dst_to_data(args):
    """
    calculate data position according to destination position

    """
    dst_pos, num_ele_block_col, num_ele_dim, num_row_one_dim,\
    cp_align_len = args

    num_block_col_index = dst_pos // num_ele_block_col
    num_ele_cur_block_col = dst_pos % num_ele_block_col
    num_dim_index = num_ele_cur_block_col // num_ele_dim
    num_ele_cur_dim = num_ele_cur_block_col % num_ele_dim
    num_col = num_ele_cur_dim // num_row_one_dim
    num_row = num_ele_cur_dim % num_row_one_dim
    data_pos = num_block_col_index*num_ele_block_col\
               + (num_dim_index*cp_align_len + num_col)\
               * num_row_one_dim + num_row

    return data_pos


def _func_split_dim_ir_0312(args):
    """
    function of moving data in split dim 0312 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, data_align,\
    reg, reg_two, reg_addr, num_g, num_row_cur_core = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_row_one_dim = h_i * w_i
    num_ele_block_col = h_i*w_i*c_i
    num_row_dim_space = _ceil_fill(num_row_one_dim, param.get("cp_align_len"))
    num_row_before_core = num_g*param.get("num_row_one_group")\
                          + param.get("block_index")\
                          * param.get("num_row_one_core")
    num_dim_before_core = num_row_before_core // num_row_dim_space
    num_block_col_before_core = num_dim_before_core // num_dim_block_col
    num_dim_cur_block_col = num_dim_before_core % num_dim_block_col
    num_row_cur_dim_before = num_row_before_core % num_row_dim_space
    num_row_cur_dim_after = num_row_dim_space - num_row_cur_dim_before

    data_offset = num_block_col_before_core * num_ele_block_col \
                  + num_dim_cur_block_col * param.get("cp_align_len") \
                  + num_row_cur_dim_before * c_i

    with tvm_ib.if_scope(num_row_cur_dim_after >= num_row_cur_core):
        # move data to data_ub
        with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, num_row_cur_core, name="num_r") as num_r:
                data_offset_cur = data_offset + num_r*c_i
                ub_offset = num_r*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr(
                                                'r', offset=data_offset_cur),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            n_burst = num_row_cur_core
            src_stride = num_dim_block_col - 1
            args = tvm_ib, param, data, data_ub, data_offset,\
                   0, n_burst, 1, src_stride, 0
            _func_gm_to_ub(args)

        # move data_ub to data_res
        num_col = tvm.min((num_dim_cur_block_col + 1)
                          * param.get("cp_align_len"), c_i)\
                  - num_dim_cur_block_col*param.get("cp_align_len")
        with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
            args = tvm_ib, param, data_ub, data_res, reg, 0, 0,\
                   num_row_cur_core, num_c
            _reg_mov_batch_one_cp_align(args)
            dst_offset = num_block_col_before_core*num_ele_block_col\
                             + (num_dim_cur_block_col*param.get("cp_align_len")
                                + num_c)*num_row_one_dim\
                         + num_row_cur_dim_before
            args = tvm_ib, param, dst, data_res, data_tail, reg,\
                   reg_addr, 1, num_row_cur_core, dst_offset, 0
            _res_to_gm(args)
    with tvm_ib.if_scope(num_row_cur_dim_after < num_row_cur_core):
        num_row_head = num_row_one_dim - num_row_cur_dim_before
        reg_addr[0] = num_row_head
        num_row_head_one = num_row_head + param.get("cp_align_len") - 1
        reg_addr[3] = num_row_head_one
        num_row_head_space = (reg_addr[3] // param.get("cp_align_len"))\
                             * param.get("cp_align_len")
        num_row_tail = num_row_cur_core - num_row_head_space
        reg_addr[7] = num_row_tail

        num_dim_before_tail = num_dim_before_core + 1
        num_block_col_before_tail = num_dim_before_tail // num_dim_block_col
        num_dim_cur_block_tail = num_dim_before_tail % num_dim_block_col

        data_offset_head = num_block_col_before_core * num_ele_block_col\
                           + num_dim_cur_block_col * param.get("cp_align_len")\
                           + num_row_cur_dim_before * c_i
        data_offset_tail = num_block_col_before_tail*num_ele_block_col\
                           + num_dim_cur_block_tail*param.get("cp_align_len")
        ub_offset_tail = num_row_head*param.get("cp_align_len")
        res_offset_tail = num_row_head_space
        # move data to data_ub
        with tvm_ib.if_scope(c_i % param.get("cp_align_len") > 0):
            # move data to data_ub for head
            with tvm_ib.for_range(0, num_row_head, name="num_r") as num_r:
                data_offset_cur = data_offset_head + num_r*c_i
                ub_offset = num_r*param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr(
                                                'r', offset=data_offset_cur),
                                            0, 1, 1, 0, 0))
            # move data to data_ub for tail
            with tvm_ib.for_range(0, num_row_tail, name="num_rt") as num_rt:
                data_offset_tail_cur = data_offset_tail + num_rt*c_i
                ub_offset_tail_cur = ub_offset_tail + num_rt\
                                     * param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset_tail_cur),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset_tail_cur),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            # move data to data_ub for head
            src_stride = num_dim_block_col - 1
            args = tvm_ib, param, data, data_ub, data_offset_head,\
                   0, reg_addr[0], 1, src_stride, 0
            _func_gm_to_ub(args)
            # move data to data_ub for tail
            args = tvm_ib, param, data, data_ub, data_offset_tail,\
                   ub_offset_tail, reg_addr[7], 1, src_stride, 0
            _func_gm_to_ub(args)

        # move data_ub to dst for head
        num_col_head = tvm.min((num_dim_cur_block_col + 1)
                               * param.get("cp_align_len"), c_i)\
                       - num_dim_cur_block_col*param.get("cp_align_len")
        reg_addr[5] = num_col_head
        with tvm_ib.for_range(0, reg_addr[5], name="num_ch") as num_ch:
            args = tvm_ib, data_ub, data_res, reg, reg_addr, 9,\
                   0, 0, reg_addr[0], num_ch, param.get("cp_align_len")
            _reg_mov_batch_one(args)
            dst_offset_head = num_block_col_before_core*num_ele_block_col \
                              + (num_dim_cur_block_col*param.get("cp_align_len")
                                 + num_ch) * num_row_one_dim\
                              + num_row_cur_dim_before
            with tvm_ib.if_scope(reg_addr[0] % param.get("cp_align_len") > 0):
                with tvm_ib.if_scope(num_row_head >= param.get("cp_align_len")):
                    row_len_align = num_row_head - param.get("cp_align_len")
                    burst_len_one = row_len_align\
                                    + param.get("cp_align_len") - 1
                    reg_addr[4] = burst_len_one
                    burst_len_head = reg_addr[4] // param.get("cp_align_len")
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset_head),
                                                data_res.access_ptr("r",
                                                                    offset=0),
                                                0, 1, burst_len_head, 0, 0))
                    args = tvm_ib, data_res, data_tail, reg, 0, 0,\
                           row_len_align, param.get("cp_align_len")
                    _reg_mov_batch_align(args)
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=dst_offset_head + reg_addr[0]
                                - param.get("cp_align_len")),
                            data_tail.access_ptr("r", offset=0),
                            0, 1, 1, 0, 0))
                with tvm_ib.else_scope():
                    num_ele = param.get("cp_align_len") - num_row_head
                    reg_addr[6] = num_ele
                    with tvm_ib.for_range(0, reg_addr[6], name="num_e")\
                            as num_e:
                        dst_pos = dst_offset_head + num_e
                        num_ele_dim = num_row_one_dim*param.get("cp_align_len")
                        args = dst_pos, num_ele_block_col, num_ele_dim,\
                               num_row_one_dim, param.get("cp_align_len")
                        data_pos = _dst_to_data(args)
                        tvm_ib.emit(
                            tvm.call_extern(data_align.dtype, "copy_gm_to_ubuf",
                                            data_align.access_ptr("w",
                                                                  offset=0),
                                            data.access_ptr('r',
                                                            offset=data_pos),
                                            0, 1, 1, 0, 0))
                        tvm_ib.emit(tvm.call_extern(
                            data_align.dtype, "reg_mov",
                            tvm.call_extern(reg.dtype, "reg", reg[0]),
                            data_align.access_ptr('r',
                                                  offset=0)
                        ))
                        tvm_ib.emit(tvm.call_extern(
                            data_res.dtype, "reg_mov",
                            data_res.access_ptr('w',
                                                offset=num_row_head + num_e),
                            tvm.call_extern(reg.dtype, "reg", reg[0])
                        ))
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset_head),
                                                data_res.access_ptr("r",
                                                                    offset=0),
                                                0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                burst_len_head = reg_addr[0] // param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset_head),
                                            data_res.access_ptr("r",
                                                                offset=0),
                                            0, 1, burst_len_head, 0, 0))
        # move data from data_ub to dst for tail
        num_col_tail = tvm.min((num_dim_cur_block_tail + 1)
                               * param.get("cp_align_len"), c_i)\
                       - num_dim_cur_block_tail*param.get("cp_align_len")
        with tvm_ib.for_range(0, num_col_tail, name="num_ct") as num_ct:
            args = tvm_ib, data_ub, data_res, reg, reg_addr, 10,\
                   ub_offset_tail, res_offset_tail, reg_addr[7],\
                   num_ct, param.get("cp_align_len")
            _reg_mov_batch_one(args)
            dst_offset_tail = num_block_col_before_tail * num_ele_block_col \
                              + (num_dim_cur_block_tail * param.get(
                                  "cp_align_len") + num_ct) * num_row_one_dim
            args = tvm_ib, param, dst, data_res, data_tail, reg_two, reg_addr,\
                   2, reg_addr[7], dst_offset_tail, num_row_head_space
            _res_to_gm(args)


def _split_dim_ir_0312(dst, data):
    """
    function of making ir node builder for split dim 0312 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_split_dim_0312(tvm_ib, data.shape, dst.dtype)
    data_ub = _new_alloc(tvm_ib, dst.dtype, param.get("num_row_one_core")
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get("num_row_one_core"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_two = tvm_ib.allocate(dst.dtype, (8,), name='reg_two',
                              scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (12,), name='reg_addr',
                               scope=cce.scope_reg)

    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail, \
                   data_align, reg, reg_two, reg_addr, num_g, param.get(
                       "num_row_one_core")
            _func_split_dim_ir_0312(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "num_row_one_core")
            num_row_mod = param.get("num_group_mod") % param.get(
                "num_row_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res, \
                           data_tail, data_align, reg, reg_two, reg_addr,\
                           num_g, param.get("num_row_one_core")
                    _func_split_dim_ir_0312(args)
            with tvm_ib.if_scope(num_row_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res, \
                           data_tail, data_align, reg, reg_two, reg_addr,\
                           num_g, num_row_mod
                    _func_split_dim_ir_0312(args)

    return tvm_ib.get()


def _get_param_split_dim_0312_small(tvm_ib, src_shape, dtype):
    """
    calculate parameters for split dim 0312 small ir builder make function

    """
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 96
    n_i, h_i, w_i, c_i = src_shape
    num_row_one_dim = h_i * w_i
    num_row_dim_space = _ceil_fill(num_row_one_dim, cp_align_len)
    num_dim_block_col = _ceil_div(c_i, cp_align_len)
    num_row_in_data = num_row_dim_space * num_dim_block_col * n_i - (
        num_row_dim_space - num_row_one_dim)
    ub_ele = ub_bytes // float_size
    actual_row_len = c_i
    num_row_one_core_one = ub_ele // (actual_row_len + 1)
    num_row_one_core = (num_row_one_core_one // cp_align_len) * cp_align_len
    num_row_one_group = num_row_one_core * device_core_num
    num_group_index = num_row_in_data // num_row_one_group
    num_group_mod = num_row_in_data % num_row_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_row_one_dim": num_row_one_dim,
                 "num_row_one_core": num_row_one_core,
                 "num_row_one_group": num_row_one_group,
                 "num_row_in_data_space": num_row_in_data,
                 "actual_row_len": actual_row_len}

    return param_map


def _func_split_dim_ir_0312_small(args):
    """
    function of moving data for split dim 0312 small scene

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, data_align, reg,\
    reg_two, reg_addr, num_g, num_row_cur_core = args

    _, h_i, w_i, c_i = data.shape
    num_dim_block_col = _ceil_div(c_i, param.get("cp_align_len"))
    num_row_one_dim = h_i * w_i
    num_ele_block_col = h_i*w_i*c_i
    num_row_dim_space = _ceil_fill(num_row_one_dim, param.get("cp_align_len"))
    num_row_before_core = num_g*param.get("num_row_one_group")\
                          + param.get("block_index")\
                          * param.get("num_row_one_core")
    num_dim_before_core = num_row_before_core // num_row_dim_space
    num_block_col_before_core = num_dim_before_core // num_dim_block_col
    num_row_cur_dim_before = num_row_before_core % num_row_dim_space
    num_row_cur_dim_after = num_row_dim_space - num_row_cur_dim_before

    data_offset = num_block_col_before_core * num_ele_block_col \
                  + num_row_cur_dim_before * c_i

    with tvm_ib.if_scope(num_row_cur_dim_after >= num_row_cur_core):
        # move data to data_ub
        total_len_data = c_i*num_row_cur_core
        burst_len_data = _ceil_div(total_len_data, param.get("cp_align_len"))
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        # move data_ub to data_res
        num_col = c_i
        with tvm_ib.for_range(0, num_col, name="num_c") as num_c:
            args = tvm_ib, data_ub, data_res, reg, reg_addr, 8, 0, 0,\
                   num_row_cur_core, num_c, c_i
            _reg_mov_batch_one(args)

            dst_offset = num_block_col_before_core*num_ele_block_col\
                     + num_c*num_row_one_dim + num_row_cur_dim_before
            args = tvm_ib, param, dst, data_res, data_tail, reg,\
                   reg_addr, 1, num_row_cur_core, dst_offset, 0
            _res_to_gm(args)
    with tvm_ib.if_scope(num_row_cur_dim_after < num_row_cur_core):
        num_row_head = num_row_one_dim - num_row_cur_dim_before
        reg_addr[0] = num_row_head
        num_row_head_one = num_row_head + param.get("cp_align_len") - 1
        reg_addr[3] = num_row_head_one
        num_row_head_space = (reg_addr[3] // param.get("cp_align_len"))\
                             * param.get("cp_align_len")
        num_row_tail = num_row_cur_core - num_row_head_space
        reg_addr[7] = num_row_tail

        num_dim_before_tail = num_dim_before_core + 1
        num_block_col_before_tail = num_dim_before_tail // num_dim_block_col
        num_dim_cur_block_tail = num_dim_before_tail % num_dim_block_col

        data_offset_head = num_block_col_before_core * num_ele_block_col \
                           + num_row_cur_dim_before * c_i
        data_offset_tail = num_block_col_before_tail*num_ele_block_col
        ub_offset_tail_before_len = num_row_head*param.get("actual_row_len")
        ub_offset_tail_one = ub_offset_tail_before_len\
                             + param.get("cp_align_len") - 1
        reg_addr[11] = ub_offset_tail_one
        ub_offset_tail = (reg_addr[11] // param.get("cp_align_len"))\
                         * param.get("cp_align_len")
        res_offset_tail = num_row_head_space
        # move data to data_ub
        total_len_head = c_i*num_row_head
        burst_len_head_one = total_len_head + param.get("cp_align_len") - 1
        reg_addr[13] = burst_len_head_one
        burst_len_head = reg_addr[13] // param.get("cp_align_len")
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset_head),
                                    0, 1, burst_len_head, 0, 0))

        total_len_tail = c_i*num_row_tail
        burst_len_tail_one = total_len_tail + param.get("cp_align_len") - 1
        reg_addr[14] = burst_len_tail_one
        burst_len_tail = reg_addr[14] // param.get("cp_align_len")
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset_tail),
                                    data.access_ptr('r',
                                                    offset=data_offset_tail),
                                    0, 1, burst_len_tail, 0, 0))

        # move data_ub to dst for head
        with tvm_ib.for_range(0, c_i, name="num_ch") as num_ch:
            args = tvm_ib, data_ub, data_res, reg,\
                   reg_addr, 9, 0, 0, reg_addr[0], num_ch, c_i
            _reg_mov_batch_one(args)
            dst_offset_head = num_block_col_before_core*num_ele_block_col \
                              + num_ch*num_row_one_dim + num_row_cur_dim_before
            with tvm_ib.if_scope(reg_addr[0] % param.get("cp_align_len") > 0):
                with tvm_ib.if_scope(num_row_head >= param.get("cp_align_len")):
                    row_len_align = num_row_head - param.get("cp_align_len")
                    burst_len_one = row_len_align\
                                    + param.get("cp_align_len") - 1
                    reg_addr[4] = burst_len_one
                    burst_len_head = reg_addr[4] // param.get("cp_align_len")
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset_head),
                                                data_res.access_ptr(
                                                    "r", offset=0),
                                                0, 1, burst_len_head, 0, 0))
                    args = tvm_ib, data_res, data_tail,\
                           reg, 0, 0, row_len_align, param.get("cp_align_len")
                    _reg_mov_batch_align(args)

                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w',
                                offset=dst_offset_head + reg_addr[0]
                                - param.get("cp_align_len")),
                            data_tail.access_ptr("r", offset=0),
                            0, 1, 1, 0, 0))
                with tvm_ib.else_scope():
                    num_ele = param.get("cp_align_len") - num_row_head
                    reg_addr[6] = num_ele
                    with tvm_ib.for_range(0, reg_addr[6], name="num_e")\
                            as num_e:
                        dst_pos = dst_offset_head + num_e
                        num_ele_dim = num_row_one_dim * param.get(
                            "cp_align_len")
                        args = dst_pos, num_ele_block_col, num_ele_dim,\
                               num_row_one_dim, param.get("cp_align_len")
                        data_pos = _dst_to_data(args)
                        tvm_ib.emit(
                            tvm.call_extern(data_align.dtype, "copy_gm_to_ubuf",
                                            data_align.access_ptr("w",
                                                                  offset=0),
                                            data.access_ptr('r',
                                                            offset=data_pos),
                                            0, 1, 1, 0, 0))
                        tvm_ib.emit(tvm.call_extern(
                            data_align.dtype, "reg_mov",
                            tvm.call_extern(reg.dtype, "reg", reg[0]),
                            data_align.access_ptr('r',
                                                  offset=0)
                        ))
                        tvm_ib.emit(tvm.call_extern(
                            data_res.dtype, "reg_mov",
                            data_res.access_ptr('w',
                                                offset=num_row_head + num_e),
                            tvm.call_extern(reg.dtype, "reg", reg[0])
                        ))
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset_head),
                                                data_res.access_ptr("r",
                                                                    offset=0),
                                                0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                burst_len_head = reg_addr[0] // param.get("cp_align_len")
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset_head),
                                            data_res.access_ptr("r",
                                                                offset=0),
                                            0, 1, burst_len_head, 0, 0))
        # move data_ub to dst for tail
        num_col_tail = c_i
        with tvm_ib.for_range(0, num_col_tail, name="num_ct") as num_ct:
            args = tvm_ib, data_ub, data_res, reg,\
                   reg_addr, 10, ub_offset_tail, res_offset_tail,\
                   reg_addr[7], num_ct, c_i
            _reg_mov_batch_one(args)
            dst_offset_tail = num_block_col_before_tail * num_ele_block_col \
                              + (num_dim_cur_block_tail * param.get(
                                  "cp_align_len") + num_ct) * num_row_one_dim
            args = tvm_ib, param, dst, data_res, data_tail, reg_two,\
                   reg_addr, 2, reg_addr[7], dst_offset_tail, num_row_head_space
            _res_to_gm(args)


def _split_dim_ir_0312_small(dst, data):
    """
    function of making ir node builder for split dim 0312 small scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_split_dim_0312_small(tvm_ib, data.shape, dst.dtype)
    c_i = data.shape[3]
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         _ceil_fill(param.get("num_row_one_core")*c_i,
                                    param.get("cp_align_len")),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, param.get("num_row_one_core"),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_two = tvm_ib.allocate(dst.dtype, (8,), name='reg_two',
                              scope=cce.scope_reg)
    data_tail = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                           "data_tail", scope=cce.scope_ubuf)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (16,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail, \
                   data_align, reg, reg_two, reg_addr, num_g, param.get(
                       "num_row_one_core")
            _func_split_dim_ir_0312_small(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "num_row_one_core")
            num_row_mod = param.get("num_group_mod") % param.get(
                "num_row_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res, \
                           data_tail, data_align, reg, reg_two, reg_addr,\
                           num_g, param.get("num_row_one_core")
                    _func_split_dim_ir_0312_small(args)
            with tvm_ib.if_scope(num_row_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res, \
                           data_tail, data_align, reg, reg_two, reg_addr,\
                           num_g, num_row_mod
                    _func_split_dim_ir_0312_small(args)

    return tvm_ib.get()


def _get_param_more_two_dim_10(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for more two dim 10 ir builder make function

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size // core_divide
    two_dim_ele = col_len*row_len
    two_dim_ele_align = _ceil_fill(two_dim_ele, cp_align_len)

    num_two_dim_ub = ub_ele // two_dim_ele_align
    num_two_dim_group = num_two_dim_ub*device_core_num
    num_group_index = num // num_two_dim_group
    num_group_mod = num % num_two_dim_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index, "two_dim_ele": two_dim_ele,
                 "num_two_dim_ub": num_two_dim_ub,
                 "num_two_dim_group": num_two_dim_group}

    return param_map


# pylint: disable=locally-disabled,unused-variable,invalid-name
def _reg_mov_batch_two_10_col(args):
    """
    reg_mov data in ub for two dim 10 col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, row_len,\
    num_d, num_r, col_len = args

    ele_reg = 8
    r_cycle = col_len // ele_reg
    r_mod = col_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_zero)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_one)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_two)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_three)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_four)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_five)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_six)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + (num_cr*ele_reg + reg_seven)*row_len
                                       + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + num_r * col_len
                                        + (num_cr*ele_reg + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_d * param.get("two_dim_ele")
                                       + (r_cycle*ele_reg + num_er) * row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_d * param.get("two_dim_ele")
                                             + num_r * col_len
                                             + (r_cycle*ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_two_10_row(args):
    """
    reg_mov data in ub for two dim 10 row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, col_len,\
    num_d, num_c, row_len = args

    ele_reg = 8
    r_cycle = row_len // ele_reg
    r_mod = row_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_d*param.get("two_dim_ele")
                                       + num_c*row_len
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_zero)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_one)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_two)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_three)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_four)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_five)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_six)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_d * param.get("two_dim_ele")
                                        + (num_cr*ele_reg + reg_seven)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_d * param.get("two_dim_ele")
                                       + num_c * row_len
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_d * param.get("two_dim_ele")
                                             + (r_cycle*ele_reg + num_er)
                                             * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_two_10_align(args):
    """
    reg_mov data in ub for two dim 10 scene

    """
    tvm_ib, param, data_res, data_align, reg, reg_addr, ele_align, cp_len = args

    ele_reg = 8
    r_cycle = cp_len // ele_reg
    r_mod = cp_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_res.access_ptr('r',
                                offset=(ele_align + (num_cr*ele_reg
                                                     + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_zero)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_one)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_two)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_three)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_four)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_five)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_six)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w',
                                  offset=(num_cr*ele_reg + reg_seven)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_res.access_ptr('r',
                                offset=(ele_align + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_align.dtype, "reg_mov",
            data_align.access_ptr('w', offset=(r_cycle*ele_reg + num_er)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_more_two_dim_10(args):
    """
    function of moving data in more two dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_align, reg, reg_addr,\
    num_g, num_two_dim_cur_core = args

    num, col_len, row_len = data.shape
    num_two_dim_before_core = num_g * param.get("num_two_dim_group")\
                              + param.get("block_index")\
                              * param.get("num_two_dim_ub")
    ele_cur_core = num_two_dim_cur_core*param.get("two_dim_ele")
    # move data from gm to ub
    data_offset = num_two_dim_before_core*param.get("two_dim_ele")
    burst_len_data = _ceil_div(ele_cur_core,
                               param.get("cp_align_len"))
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r', offset=data_offset),
                                0, 1, burst_len_data, 0, 0))
    # reg_mov from data_ub to data_res
    with tvm_ib.if_scope(tvm.all(col_len < 8, row_len >= 8)):
        with tvm_ib.for_range(0, num_two_dim_cur_core, name="num_d") as num_d:
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       col_len, num_d, num_c, row_len
                _reg_mov_batch_two_10_row(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, num_two_dim_cur_core, name="num_d") as num_d:
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       row_len, num_d, num_r, col_len
                _reg_mov_batch_two_10_col(args)

    # move data from data_res to dst
    with tvm_ib.if_scope(ele_cur_core % param.get("cp_align_len") > 0):
        with tvm_ib.if_scope(ele_cur_core > param.get("cp_align_len")):
            ele_align = ele_cur_core - param.get("cp_align_len")
            dst_offset = num_two_dim_before_core * param.get("two_dim_ele")
            burst_len_align = _ceil_div(ele_align, param.get("cp_align_len"))
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_align, 0, 0))
            args = tvm_ib, param, data_res, data_align, reg, reg_addr,\
                   ele_align, param.get("cp_align_len")
            _reg_mov_batch_two_10_align(args)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset
                                                       + ele_align),
                                        data_align.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            dst_offset = num_two_dim_before_core * param.get("two_dim_ele")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = num_two_dim_before_core*param.get("two_dim_ele")
        burst_len_dst = ele_cur_core // param.get("cp_align_len")
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _more_two_dim_ir_10(dst, data, core_divide):
    """
    function of making ir node builder for more two dim scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_more_two_dim_10(tvm_ib, data.shape,
                                       dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         _ceil_fill(param.get("num_two_dim_ub")
                                    * param.get("two_dim_ele"),
                                    param.get("cp_align_len")),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype,
                          _ceil_fill(param.get("num_two_dim_ub")
                                     * param.get("two_dim_ele"),
                                     param.get("cp_align_len")),
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_align,\
                   reg, reg_addr, num_g, param.get("num_two_dim_ub")
            _func_more_two_dim_10(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "num_two_dim_ub")
            num_two_dim_mod = param.get("num_group_mod") % param.get(
                "num_two_dim_ub")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, reg, reg_addr,\
                           num_g, param.get("num_two_dim_ub")
                    _func_more_two_dim_10(args)
            with tvm_ib.if_scope(num_two_dim_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, reg, reg_addr,\
                           num_g, num_two_dim_mod
                    _func_more_two_dim_10(args)

    return tvm_ib.get()


def _get_param_more_dim_10(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for more dim 10 ir builder make function

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size // core_divide
    row_len_one = ub_ele // col_len
    num_row_align_ub = row_len_one // cp_align_len
    num_row_align_dim = _ceil_div(row_len, cp_align_len)
    num_row_align_in_data = num_row_align_dim*num

    num_row_align_group = num_row_align_ub*device_core_num
    num_group_index = num_row_align_in_data // num_row_align_group
    num_group_mod = num_row_align_in_data % num_row_align_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "num_row_align_ub": num_row_align_ub,
                 "num_row_align_dim": num_row_align_dim,
                 "num_row_align_group": num_row_align_group}

    return param_map


def _reg_mov_batch_more_10_row(args):
    """
    reg_mov data in ub for more dim 10 row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, col_len,\
    num_row_align_cur_core, num_c, row_cur_core_true = args

    ele_reg = 8
    r_cycle = row_cur_core_true // ele_reg
    r_mod = row_cur_core_true % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_zero) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_one) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_two) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_three) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_four) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_five) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_six) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_seven) * col_len
                                        + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_c*num_row_align_cur_core
                                       * param.get("cp_align_len")
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=((r_cycle*ele_reg + num_er)
                                             * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_more_10_col(args):
    """
    reg_mov data in ub for more dim 10 col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, num_row_align_cur_core,\
    num_r, col_len = args

    ele_reg = 8
    r_cycle = col_len // ele_reg
    r_mod = col_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_zero)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_one)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_two)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_three)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_four)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_five)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_six)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=((num_cr*ele_reg + reg_seven)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * col_len + (num_cr*ele_reg
                                                           + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=((r_cycle*ele_reg + num_er)
                                       * num_row_align_cur_core
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_r * col_len
                                             + (r_cycle*ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_more_10_tail_row(args):
    """
    reg_mov data in ub for more 10 dim tail row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, ub_offset_tail,\
    res_offset_tail, col_len, num_c, row_len_tail = args

    ele_reg = 8
    r_cycle = row_len_tail // ele_reg
    r_mod = row_len_tail % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_zero)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_one)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_two)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_three)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_four)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_five)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_six)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail
                                        + (num_cr*ele_reg + reg_seven)
                                        * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail + num_c * row_len_tail
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset_tail
                                             + (r_cycle*ele_reg + num_er)
                                             * col_len + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_more_10_tail_col(args):
    """
    reg_mov data in ub for more 10 dim tail col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, ub_offset_tail,\
    res_offset_tail, row_len_tail, num_r, col_len = args

    ele_reg = 8
    r_cycle = col_len // ele_reg
    r_mod = col_len % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_zero)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_one)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_two)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_three)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_four)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_five)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_six)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (num_cr*ele_reg + reg_seven)
                                       * row_len_tail + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset_tail + num_r * col_len
                                        + (num_cr*ele_reg + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset_tail
                                       + (r_cycle*ele_reg + num_er)
                                       * row_len_tail + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset_tail + num_r * col_len
                                             + (r_cycle*ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_more_dim_10(args):
    """
    function of moving data in more dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_align, reg, reg_addr,\
    num_g, num_row_align_cur_core = args

    num, col_len, row_len = data.shape
    two_dim_ele = col_len*row_len
    num_row_align_before_core = num_g * param.get("num_row_align_group")\
                                + param.get("block_index")\
                                * param.get("num_row_align_ub")
    num_two_dim_before_core = num_row_align_before_core\
                              // param.get("num_row_align_dim")
    num_align_cur_dim_before = num_row_align_before_core\
                               % param.get("num_row_align_dim")
    num_align_cur_dim = param.get("num_row_align_dim")\
                        - num_align_cur_dim_before

    with tvm_ib.if_scope(num_align_cur_dim >= num_row_align_cur_core):
        # move data from gm to ub
        data_offset = num_two_dim_before_core*two_dim_ele\
                      + num_align_cur_dim_before*param.get("cp_align_len")
        burst_len_data = num_row_align_cur_core
        with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                data_offset_cur = data_offset + num_c * row_len
                ub_offset_cur = num_c * num_row_align_cur_core\
                                * param.get("cp_align_len")
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr("w", offset=ub_offset_cur),
                        data.access_ptr(
                            'r', offset=data_offset_cur),
                        0, 1, burst_len_data, 0, 0))
        with tvm_ib.else_scope():
            n_burst = col_len
            src_stride = param.get("num_row_align_dim")\
                         - num_row_align_cur_core
            args = tvm_ib, param, data, data_ub, data_offset, 0, n_burst,\
                   burst_len_data, src_stride, 0
            _func_gm_to_ub(args)

        # move data from data_ub to data_res
        row_end = tvm.min((num_align_cur_dim_before + num_row_align_cur_core)
                          * param.get("cp_align_len"), row_len)
        row_cur_core_true = row_end - num_align_cur_dim_before\
                            * param.get("cp_align_len")
        reg_addr[4] = row_cur_core_true
        with tvm_ib.if_scope(tvm.all(col_len < 8, row_cur_core_true >= 8)):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       col_len, num_row_align_cur_core, num_c, reg_addr[4]
                _reg_mov_batch_more_10_row(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_cur_core_true, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       num_row_align_cur_core, num_r, col_len
                _reg_mov_batch_more_10_col(args)

        # move data from data_res to dst
        row_ele = row_cur_core_true*col_len
        reg_addr[0] = row_ele
        dst_offset = num_two_dim_before_core * two_dim_ele \
                     + num_align_cur_dim_before \
                     * param.get("cp_align_len") * col_len
        with tvm_ib.if_scope(reg_addr[0] % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(row_ele > param.get("cp_align_len")):
                row_align = row_ele - param.get("cp_align_len")
                burst_len_dst = _ceil_div(row_align, param.get("cp_align_len"))
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, burst_len_dst, 0, 0))
                args = tvm_ib, param, data_res, data_align, reg, reg_addr,\
                       row_align, param.get("cp_align_len")
                _reg_mov_batch_two_10_align(args)
                reg_addr[2] = row_align
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset + reg_addr[2]),
                        data_align.access_ptr("r", offset=0),
                        0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            burst_len_dst = reg_addr[0] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(num_align_cur_dim < num_row_align_cur_core):
        num_row_align_head = num_align_cur_dim
        num_row_align_tail = num_row_align_cur_core - num_align_cur_dim
        # move data from gm to ub for head
        data_offset_head = num_two_dim_before_core*two_dim_ele \
                           + num_align_cur_dim_before*param.get("cp_align_len")
        burst_len_data = num_row_align_head
        with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                data_offset_cur = data_offset_head + num_c*row_len
                ub_offset_cur = num_c*num_row_align_head*param.get("cp_align_len")
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr("w", offset=ub_offset_cur),
                        data.access_ptr(
                            'r', offset=data_offset_cur),
                        0, 1, burst_len_data, 0, 0))
        with tvm_ib.else_scope():
            n_burst = col_len
            src_stride = param.get("num_row_align_dim") - num_row_align_head
            args = tvm_ib, param, data, data_ub, data_offset_head, 0, n_burst,\
                   burst_len_data, src_stride, 0
            _func_gm_to_ub(args)
        # move data from data_ub to data_res for head
        row_end = tvm.min((num_align_cur_dim_before + num_row_align_head)
                          * param.get("cp_align_len"), row_len)
        row_cur_core_true = row_end - num_align_cur_dim_before\
                            * param.get("cp_align_len")
        reg_addr[5] = row_cur_core_true
        with tvm_ib.if_scope(tvm.all(col_len < 8, row_cur_core_true >= 8)):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       col_len, num_row_align_head, num_c, reg_addr[5]
                _reg_mov_batch_more_10_row(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_cur_core_true, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       num_row_align_head, num_r, col_len
                _reg_mov_batch_more_10_col(args)

        # move data from gm to ub for tail
        row_len_tail = num_row_align_tail*param.get("cp_align_len")
        reg_addr[6] = row_len_tail
        num_two_dim_before_tail = num_two_dim_before_core + 1
        data_offset_tail = num_two_dim_before_tail*two_dim_ele
        burst_len_data = num_row_align_tail
        ub_offset_tail = col_len*num_row_align_head*param.get("cp_align_len")
        with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                data_offset_cur = data_offset_tail + num_c*row_len
                ub_offset_cur = ub_offset_tail + num_c*row_len_tail
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr("w", offset=ub_offset_cur),
                        data.access_ptr(
                            'r', offset=data_offset_cur),
                        0, 1, burst_len_data, 0, 0))
        with tvm_ib.else_scope():
            n_burst = col_len
            src_stride = param.get("num_row_align_dim") - num_row_align_tail
            args = tvm_ib, param, data, data_ub, data_offset_tail,\
                   ub_offset_tail, n_burst, burst_len_data, src_stride, 0
            _func_gm_to_ub(args)
        # move data from data_ub to data_res for tail
        res_offset_tail = row_cur_core_true*col_len
        with tvm_ib.if_scope(tvm.all(col_len < 8, row_len_tail >= 8)):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       ub_offset_tail,\
                       res_offset_tail, col_len, num_c, reg_addr[6]
                _reg_mov_batch_more_10_tail_row(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len_tail, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       ub_offset_tail,\
                       res_offset_tail, row_len_tail, num_r, col_len
                _reg_mov_batch_more_10_tail_col(args)
        # move data from data_res to dst for head and tail
        all_ele = col_len*(row_cur_core_true + row_len_tail)
        reg_addr[1] = all_ele
        dst_offset = num_two_dim_before_core*two_dim_ele\
                     + num_align_cur_dim_before\
                     * param.get("cp_align_len")*col_len
        with tvm_ib.if_scope(reg_addr[1] % param.get("cp_align_len") > 0):
            with tvm_ib.if_scope(all_ele > param.get("cp_align_len")):
                ele_align = all_ele - param.get("cp_align_len")
                burst_len_align = _ceil_div(ele_align,
                                            param.get("cp_align_len"))
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, burst_len_align, 0, 0))
                with tvm_ib.for_range(0, param.get("cp_align_len"),
                                      name="num_a") as num_a:
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_res.access_ptr('r',
                                            offset=(ele_align + num_a))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_align.dtype, "reg_mov",
                        data_align.access_ptr('w', offset=num_a),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))
                reg_addr[3] = ele_align
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset + reg_addr[3]),
                        data_align.access_ptr("r", offset=0),
                        0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr("r", offset=0),
                                            0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            burst_len_dst = reg_addr[1] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _more_dim_ir_10(dst, data, core_divide):
    """
    function of making ir node builder for more dim 10 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_more_dim_10(tvm_ib, data.shape, dst.dtype, core_divide)
    num, col_len, row_len = data.shape
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         param.get("num_row_align_ub")
                         * param.get("cp_align_len") * col_len,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype,
                          param.get("num_row_align_ub")
                          * param.get("cp_align_len") * col_len,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_align,\
                   reg, reg_addr, num_g, param.get("num_row_align_ub")
            _func_more_dim_10(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "num_row_align_ub")
            num_row_align_mod = param.get("num_group_mod") % param.get(
                "num_row_align_ub")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, \
                           reg, reg_addr, num_g, param.get("num_row_align_ub")
                    _func_more_dim_10(args)
            with tvm_ib.if_scope(num_row_align_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, \
                           reg, reg_addr, num_g, num_row_align_mod
                    _func_more_dim_10(args)

    return tvm_ib.get()


def _get_param_split_dim_10(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for split dim 10 ir builder make function

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32 - 32 * cp_align_len
    ub_half = ub_bytes // 2
    ub_ele = ub_half // float_size // core_divide
    row_len_align = _ceil_fill(row_len, cp_align_len)
    col_len_one_core = (ub_ele // row_len_align // cp_align_len)*cp_align_len
    col_len_one_group = col_len_one_core*device_core_num
    col_len_align = _ceil_fill(col_len, cp_align_len)
    col_len_in_data_align = num*col_len_align

    num_group_index = col_len_in_data_align // col_len_one_group
    num_group_mod = col_len_in_data_align % col_len_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "col_len_one_core": col_len_one_core,
                 "col_len_one_group": col_len_one_group,
                 "row_len_align": row_len_align}

    return param_map


def _reg_mov_batch_split_10_tail_row(args):
    """
    reg_mov data in ub for split dim 10 tail row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, num_col_len_cur_core,\
    num_c, row_len_true, row_len = args

    ele_reg = 8
    r_cycle = row_len_true // ele_reg
    r_mod = row_len_true % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_zero)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_one)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_two)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_three)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_four)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_five)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_six)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_seven)
                                        * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_c * row_len
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=((r_cycle*ele_reg + num_er)
                                             * num_col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_split_10_tail_col(args):
    """
    reg_mov data in ub for split dim tail col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, row_len, num_r,\
    num_col_true, num_col_len_cur_core = args

    ele_reg = 8
    r_cycle = num_col_true // ele_reg
    r_mod = num_col_true % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_zero)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_one)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_two)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_three)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_four)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_five)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_six)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=((num_cr * ele_reg + reg_seven)*row_len
                                       + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(num_r * num_col_len_cur_core
                                        + (num_cr * ele_reg + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=((r_cycle*ele_reg + num_er)*row_len
                                       + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(num_r * num_col_len_cur_core
                                             + (r_cycle * ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _res_to_dst_split_dim(args):
    """
    function of moving data for split dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, data_align,\
    reg, reg_addr, row_len, col_len, two_dim_ele, num_dim_before_core,\
    num_col_len_dim_before, num_col_len_head_align,\
    num_col_len_head_true = args

    reg_addr[0] = num_col_len_head_true
    data_offset = num_dim_before_core * two_dim_ele \
                  + row_len * num_col_len_dim_before
    burst_len_data = _ceil_div(row_len * num_col_len_head_true,
                               param.get("cp_align_len"))
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w",
                                                   offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))
    # move data from data_ub to data_res
    with tvm_ib.if_scope(tvm.all(num_col_len_head_true < 8, row_len >= 8)):
        with tvm_ib.for_range(0, num_col_len_head_true,
                              name="num_c") as num_c:
            args = tvm_ib, param, data_ub, data_res, reg, reg_addr, \
                   num_col_len_head_align, num_c, row_len, row_len
            _reg_mov_batch_split_10_tail_row(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            args = tvm_ib, param, data_ub, data_res, reg, reg_addr, \
                   row_len, num_r, reg_addr[0], num_col_len_head_align
            _reg_mov_batch_split_10_tail_col(args)
    # move data from data_res to dst
    with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
        with tvm_ib.if_scope(num_col_len_head_true
                             > param.get("cp_align_len")):
            col_len_align = num_col_len_head_true \
                            - param.get("cp_align_len")
            reg_addr[5] = col_len_align
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                dst_offset_cur = num_dim_before_core * two_dim_ele \
                                 + num_col_len_dim_before + num_r * col_len
                res_offset_cur = num_r * num_col_len_head_align
                burst_len_dst = _ceil_div(col_len_align,
                                          param.get("cp_align_len"))
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur),
                        data_res.access_ptr(
                            "r", offset=res_offset_cur),
                        0, 1, burst_len_dst, 0, 0))
                ele_len = res_offset_cur + reg_addr[5]
                args = tvm_ib, param, data_res, data_align, reg, reg_addr, \
                       ele_len, param.get("cp_align_len")
                _reg_mov_batch_two_10_align(args)
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur + reg_addr[5]),
                        data_align.access_ptr(
                            "r", offset=0),
                        0, 1, 1, 0, 0))
        with tvm_ib.if_scope(num_col_len_head_true
                             == param.get("cp_align_len")):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                dst_offset_cur = num_dim_before_core * two_dim_ele \
                                 + num_col_len_dim_before + num_r * col_len
                res_offset_cur = num_r * num_col_len_head_align
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur),
                        data_res.access_ptr(
                            "r", offset=res_offset_cur),
                        0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        dst_offset = num_dim_before_core * two_dim_ele \
                     + num_col_len_dim_before
        n_burst = row_len
        burst_len_dst = reg_addr[0] // param.get("cp_align_len")
        reg_addr[1] = col_len - num_col_len_head_true
        dst_stride = reg_addr[1] // param.get("cp_align_len")
        args = tvm_ib, param, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride
        _func_ub_to_gm(args)


def _func_split_dim_10(args):
    """
    function of moving data in split dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_align, data_tail, reg,\
    reg_addr, num_g, num_col_len_cur_core = args

    num, col_len, row_len = data.shape
    two_dim_ele = col_len*row_len
    col_len_align = _ceil_fill(col_len, param.get("cp_align_len"))
    num_col_len_before_core = num_g * param.get("col_len_one_group")\
                              + param.get("block_index")\
                              * param.get("col_len_one_core")
    num_dim_before_core = num_col_len_before_core // col_len_align
    num_col_len_dim_before = num_col_len_before_core % col_len_align
    num_col_len_cur_dim_align = col_len_align - num_col_len_dim_before
    num_col_len_cur_dim_true = col_len - num_col_len_dim_before

    with tvm_ib.if_scope(num_col_len_cur_dim_align > num_col_len_cur_core):
        data_offset = num_dim_before_core * two_dim_ele\
                      + row_len * num_col_len_dim_before
        burst_len_data = _ceil_div(num_col_len_cur_core * row_len,
                                   param.get("cp_align_len"))
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        with tvm_ib.if_scope(tvm.all(num_col_len_cur_core < 8, row_len >= 8)):
            with tvm_ib.for_range(0, num_col_len_cur_core,
                                  name="num_c") as num_c:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       num_col_len_cur_core, num_c, row_len, row_len
                _reg_mov_batch_split_10_tail_row(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                       row_len, num_r, num_col_len_cur_core,\
                       num_col_len_cur_core
                _reg_mov_batch_split_10_tail_col(args)
        burst_len_dst = num_col_len_cur_core // param.get("cp_align_len")
        with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                dst_offset_cur = num_dim_before_core*two_dim_ele\
                                 + num_col_len_dim_before + num_r*col_len
                res_offset_cur = num_r*num_col_len_cur_core
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur),
                        data_res.access_ptr(
                            "r", offset=res_offset_cur),
                        0, 1, burst_len_dst, 0, 0))
        with tvm_ib.else_scope():
            dst_offset = num_dim_before_core*two_dim_ele\
                         + num_col_len_dim_before
            n_burst = row_len
            dst_stride = (col_len - num_col_len_cur_core)\
                         // param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, dst_offset, 0, n_burst, \
                   burst_len_dst, 0, dst_stride
            _func_ub_to_gm(args)
    with tvm_ib.if_scope(num_col_len_cur_dim_align <= num_col_len_cur_core):
        with tvm_ib.if_scope(num_col_len_cur_dim_true
                             >= param.get("cp_align_len")):
            num_col_len_head_align = num_col_len_cur_dim_align
            num_col_len_head_true = num_col_len_cur_dim_true
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   data_align, reg, reg_addr, row_len, col_len, two_dim_ele,\
                   num_dim_before_core, num_col_len_dim_before,\
                   num_col_len_head_align, num_col_len_head_true
            _res_to_dst_split_dim(args)
        with tvm_ib.else_scope():
            num_col_len_head_true = _ceil_fill(num_col_len_cur_dim_true,
                                               param.get("cp_align_len"))
            num_col_len_head_align = num_col_len_head_true
            num_col_len_dim_before = col_len - num_col_len_head_true
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail, \
                   data_align, reg, reg_addr, row_len, col_len, two_dim_ele, \
                   num_dim_before_core, num_col_len_dim_before, \
                   num_col_len_head_align, num_col_len_head_true
            _res_to_dst_split_dim(args)

        # move data for tail
        num_col_len_tail = num_col_len_cur_core - num_col_len_cur_dim_align
        reg_addr[3] = num_col_len_tail
        with tvm_ib.if_scope(num_col_len_tail > 0):
            # move data from gm to ub
            ub_offset = num_col_len_cur_dim_align * row_len
            data_offset = (num_dim_before_core + 1)*two_dim_ele
            reg_addr[2] = num_col_len_tail*row_len
            burst_len_tail = reg_addr[2] // param.get("cp_align_len")
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_tail, 0, 0))
            # move data from data_ub to data_res
            res_offset = num_col_len_cur_dim_align*row_len
            with tvm_ib.if_scope(tvm.all(num_col_len_tail < 8, row_len >= 8)):
                with tvm_ib.for_range(0, num_col_len_tail,
                                      name="num_c") as num_c:
                    args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                           ub_offset,\
                           res_offset, num_col_len_tail, num_c, row_len
                    _reg_mov_batch_more_10_tail_row(args)
            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                    args = tvm_ib, param, data_ub, data_res, reg, reg_addr,\
                           ub_offset,\
                           res_offset, row_len, num_r, reg_addr[3]
                    _reg_mov_batch_more_10_tail_col(args)
            # move data from data_res to dst
            burst_len_dst = reg_addr[3] // param.get("cp_align_len")
            with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                    dst_offset_cur = (num_dim_before_core + 1) * two_dim_ele\
                                     + num_r * col_len
                    res_offset_cur = res_offset + num_r*num_col_len_tail
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w', offset=dst_offset_cur),
                            data_res.access_ptr(
                                "r", offset=res_offset_cur),
                            0, 1, burst_len_dst, 0, 0))
            with tvm_ib.else_scope():
                dst_offset = (num_dim_before_core + 1)*two_dim_ele
                n_burst = row_len
                reg_addr[4] = col_len - num_col_len_tail
                dst_stride = reg_addr[4] // param.get("cp_align_len")
                args = tvm_ib, param, dst, data_res, dst_offset,\
                       res_offset, n_burst, \
                       burst_len_dst, 0, dst_stride
                _func_ub_to_gm(args)


def _split_dim_ir_10(dst, data, core_divide):
    """
    function of making ir node builder for split dim 10 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_split_dim_10(tvm_ib, data.shape, dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         param.get("col_len_one_core")
                         * param.get("row_len_align"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype,
                          param.get("col_len_one_core")
                          * param.get("row_len_align"),
                          "data_res", scope=cce.scope_ubuf)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype,
                           param.get('cp_align_len')
                           * param.get("cp_align_len"),
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_align,\
                   data_tail, reg,\
                   reg_addr, num_g, param.get("col_len_one_core")
            _func_split_dim_10(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "col_len_one_core")
            num_col_len_mod = param.get("num_group_mod") % param.get(
                "col_len_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, data_tail, reg, \
                           reg_addr, num_g, param.get("col_len_one_core")
                    _func_split_dim_10(args)
            with tvm_ib.if_scope(num_col_len_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res, \
                           data_align, data_tail, reg, \
                           reg_addr, num_g, num_col_len_mod
                    _func_split_dim_10(args)

    return tvm_ib.get()


def _get_param_large_two_dim_10(tvm_ib, src_shape, dtype, core_divide):
    """
    calculate parameters for large two dim 10 ir builder make function

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32 - 32*cp_align_len
    ub_half = ub_bytes // 2
    ub_ele = ub_half // float_size // core_divide
    row_len_align = _ceil_fill(row_len, cp_align_len)
    col_len_align = _ceil_fill(col_len, cp_align_len)
    col_len_one_core = (ub_ele // cp_align_len // cp_align_len)*cp_align_len
    col_len_one_group = col_len_one_core*device_core_num
    col_len_in_data = (row_len_align // cp_align_len)*col_len_align*num
    num_group_index = col_len_in_data // col_len_one_group
    num_group_mod = col_len_in_data % col_len_one_group

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    param_map = {"num_group_index": num_group_index,
                 "num_group_mod": num_group_mod,
                 "float_size": float_size, "cp_align_len": cp_align_len,
                 "block_index": block_index,
                 "col_len_one_core": col_len_one_core,
                 "col_len_one_group": col_len_one_group,
                 "row_len_align": row_len_align}

    return param_map


def _reg_mov_batch_large_10_tail_row(args):
    """
    reg_mov data in ub for large two dim 10 tail row scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, ub_offset,\
    res_offset, col_len_cur_core, num_c, row_true = args

    ele_reg = 8
    r_cycle = row_true // ele_reg
    r_mod = row_true % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_zero)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_one)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_two)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_three)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_four)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_five)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_six)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (num_cr*ele_reg + reg_seven)))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_zero)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_one)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_two)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_three)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_four)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_five)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_six)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset
                                        + (num_cr*ele_reg + reg_seven)
                                        * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset
                                       + num_c*param.get("cp_align_len")
                                       + (r_cycle*ele_reg + num_er)))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset
                                             + (r_cycle*ele_reg + num_er)
                                             * col_len_cur_core + num_c)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _reg_mov_batch_large_10_tail_col(args):
    """
    reg_mov data in ub for large two dim 10 tail col scene

    """
    tvm_ib, param, data_ub, data_res, reg, reg_addr, ub_offset, res_offset,\
    row_true, num_r, col_len_cur_core = args

    ele_reg = 8
    r_cycle = col_len_cur_core // ele_reg
    r_mod = col_len_cur_core % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_zero)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_one)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_two)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_three)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_four)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_five)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_six)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (num_cr*ele_reg + reg_seven)
                                       * param.get("cp_align_len") + num_r))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_zero))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_one))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_two))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_three))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_four))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_five))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_six))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=(res_offset + num_r * col_len_cur_core
                                        + (num_cr*ele_reg + reg_seven))),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(ub_offset + (r_cycle*ele_reg + num_er)
                                       * param.get("cp_align_len") + num_r))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w', offset=(res_offset
                                             + num_r*col_len_cur_core
                                             + (r_cycle*ele_reg + num_er))),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _res_to_dst_large(args):
    """
    function of moving data for large two dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_tail, data_align, reg,\
    reg_addr, col_len, row_len, two_dim_ele, num_two_dim_before_core,\
    num_col_len_cur_dim_before, num_dim_before_cur_two,\
    num_col_len_head_align, num_col_len_head_true = args

    reg_addr[1] = num_col_len_head_true
    # move data from gm to ub
    data_offset = num_two_dim_before_core * two_dim_ele \
                  + num_col_len_cur_dim_before * row_len \
                  + num_dim_before_cur_two * param.get("cp_align_len")
    with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
        with tvm_ib.for_range(0, num_col_len_head_true,
                              name="num_cl") as num_cl:
            data_offset_cur = data_offset + num_cl * row_len
            ub_offset_cur = num_cl * param.get("cp_align_len")
            tvm_ib.emit(
                tvm.call_extern(
                    data_ub.dtype, "copy_gm_to_ubuf",
                    data_ub.access_ptr(
                        "w", offset=ub_offset_cur),
                    data.access_ptr(
                        'r', offset=data_offset_cur),
                    0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        n_burst = num_col_len_head_true
        src_stride = row_len // param.get("cp_align_len") - 1
        args = tvm_ib, param, data, data_ub, data_offset, 0, \
               reg_addr[1], 1, src_stride, 0
        _func_gm_to_ub(args)
    # move data from data_ub to data_res
    row_end = tvm.min((num_dim_before_cur_two + 1)
                      * param.get("cp_align_len"), row_len)
    row_true = row_end - (num_dim_before_cur_two
                          * param.get("cp_align_len"))
    reg_addr[9] = row_true
    with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
        args = tvm_ib, param, data_ub, data_res, reg, reg_addr, \
               param.get("cp_align_len"), num_r, reg_addr[1], \
               num_col_len_head_align
        _reg_mov_batch_split_10_tail_col(args)
    # move data from data_res to dst
    dst_offset = num_two_dim_before_core * two_dim_ele \
                 + num_dim_before_cur_two * param.get("cp_align_len") \
                 * col_len \
                 + num_col_len_cur_dim_before
    with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
        with tvm_ib.if_scope(num_col_len_head_true
                             > param.get("cp_align_len")):
            col_len_head_align = num_col_len_head_true \
                                 - param.get("cp_align_len")
            reg_addr[6] = col_len_head_align
            burst_len_align = _ceil_div(col_len_head_align,
                                        param.get("cp_align_len"))
            with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
                dst_offset_cur = dst_offset + num_r * col_len
                res_offset_cur = num_r * num_col_len_head_align
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur),
                        data_res.access_ptr(
                            "r", offset=res_offset_cur),
                        0, 1, burst_len_align, 0, 0))
                ele_len = res_offset_cur + reg_addr[6]
                args = tvm_ib, param, data_res, data_align, reg, reg_addr, \
                       ele_len, param.get("cp_align_len")
                _reg_mov_batch_two_10_align(args)
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur + reg_addr[6]),
                        data_align.access_ptr(
                            "r", offset=0),
                        0, 1, 1, 0, 0))
        with tvm_ib.if_scope(num_col_len_head_true
                             == param.get("cp_align_len")):
            with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
                dst_offset_cur = dst_offset + num_r * col_len
                res_offset_cur = num_r * num_col_len_head_align
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur),
                        data_res.access_ptr(
                            "r", offset=res_offset_cur),
                        0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        n_burst = row_true
        burst_len_dst = reg_addr[1] // param.get("cp_align_len")
        reg_addr[2] = col_len - num_col_len_head_true
        dst_stride = reg_addr[2] // param.get("cp_align_len")
        args = tvm_ib, param, dst, data_res, dst_offset, 0, reg_addr[9], \
               burst_len_dst, 0, dst_stride
        _func_ub_to_gm(args)


def _func_large_two_dim_10(args):
    """
    function of moving data in large two dim 10 function

    """
    tvm_ib, param, data, dst, data_ub, data_res, data_align, data_tail, reg,\
    reg_addr, num_g, col_len_cur_core = args

    num, col_len, row_len = data.shape
    two_dim_ele = col_len*row_len
    row_len_align = _ceil_fill(row_len, param.get("cp_align_len"))
    col_len_align = _ceil_fill(col_len, param.get("cp_align_len"))
    num_col_len_before_core = num_g*param.get("col_len_one_group")\
                              + param.get("block_index")\
                              * param.get("col_len_one_core")
    num_col_len_align_two_dim = (row_len_align // param.get("cp_align_len"))\
                                * col_len_align
    num_two_dim_before_core = num_col_len_before_core\
                              // num_col_len_align_two_dim
    num_col_len_two_dim_before = num_col_len_before_core\
                                 % num_col_len_align_two_dim
    num_dim_before_cur_two = num_col_len_two_dim_before // col_len_align
    num_col_len_cur_dim_before = num_col_len_two_dim_before % col_len_align
    num_col_len_cur_dim_align = col_len_align - num_col_len_cur_dim_before
    num_col_len_cur_dim_true = col_len - num_col_len_cur_dim_before

    with tvm_ib.if_scope(num_col_len_cur_dim_align > col_len_cur_core):
        # move data from gm to ub
        data_offset = num_two_dim_before_core * two_dim_ele \
                      + num_col_len_cur_dim_before * row_len \
                      + num_dim_before_cur_two * param.get("cp_align_len")
        with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, col_len_cur_core, name="num_cl") as num_cl:
                data_offset_cur = data_offset + num_cl*row_len
                ub_offset_cur = num_cl*param.get("cp_align_len")
                tvm_ib.emit(
                    tvm.call_extern(
                        data_ub.dtype, "copy_gm_to_ubuf",
                        data_ub.access_ptr(
                            "w", offset=ub_offset_cur),
                        data.access_ptr(
                            'r', offset=data_offset_cur),
                        0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            n_burst = col_len_cur_core
            src_stride = row_len // param.get("cp_align_len") - 1
            args = tvm_ib, param, data, data_ub, data_offset, 0,\
                   n_burst, 1, src_stride, 0
            _func_gm_to_ub(args)
        # move data from data_ub to data_res
        row_end = tvm.min((num_dim_before_cur_two + 1)
                          * param.get("cp_align_len"), row_len)
        row_true = row_end - (num_dim_before_cur_two*param.get("cp_align_len"))
        reg_addr[7] = row_true
        with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
            args = tvm_ib, param, data_ub, data_res, reg, reg_addr, 0, 0,\
                   row_true, num_r, col_len_cur_core
            _reg_mov_batch_large_10_tail_col(args)
        # move data from data_res to dst
        dst_offset = num_two_dim_before_core * two_dim_ele\
                     + num_dim_before_cur_two * param.get("cp_align_len")\
                     * col_len\
                     + num_col_len_cur_dim_before
        burst_len_dst = col_len_cur_core // param.get("cp_align_len")
        with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
            with tvm_ib.for_range(0, row_true, name="num_rt") as num_rt:
                dst_offset_cur = dst_offset + num_rt*col_len
                res_offset_cur = num_rt*col_len_cur_core
                tvm_ib.emit(
                    tvm.call_extern(
                        dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr(
                            'w', offset=dst_offset_cur),
                        data_res.access_ptr(
                            "r", offset=res_offset_cur),
                        0, 1, burst_len_dst, 0, 0))
        with tvm_ib.else_scope():
            n_burst = row_true
            reg_addr[0] = col_len - col_len_cur_core
            dst_stride = reg_addr[0] // param.get("cp_align_len")
            args = tvm_ib, param, dst, data_res, dst_offset, 0, reg_addr[7],\
                   burst_len_dst, 0, dst_stride
            _func_ub_to_gm(args)
    with tvm_ib.if_scope(num_col_len_cur_dim_align <= col_len_cur_core):
        # move data for head
        with tvm_ib.if_scope(num_col_len_cur_dim_true
                             >= param.get("cp_align_len")):
            num_col_len_head_align = num_col_len_cur_dim_align
            num_col_len_head_true = num_col_len_cur_dim_true
            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail,\
                   data_align, reg, reg_addr, col_len, row_len, two_dim_ele,\
                   num_two_dim_before_core, num_col_len_cur_dim_before,\
                   num_dim_before_cur_two, num_col_len_head_align,\
                   num_col_len_head_true
            _res_to_dst_large(args)
        with tvm_ib.else_scope():
            num_col_len_head_true = _ceil_fill(num_col_len_cur_dim_true,
                                               param.get("cp_align_len"))
            num_col_len_head_align = num_col_len_head_true
            num_col_len_cur_dim_before = col_len - num_col_len_head_true

            args = tvm_ib, param, data, dst, data_ub, data_res, data_tail, \
                   data_align, reg, reg_addr, col_len, row_len, two_dim_ele, \
                   num_two_dim_before_core, num_col_len_cur_dim_before, \
                   num_dim_before_cur_two, num_col_len_head_align, \
                   num_col_len_head_true
            _res_to_dst_large(args)

        # move data for tail
        num_col_len_tail = col_len_cur_core - num_col_len_cur_dim_align
        with tvm_ib.if_scope(num_col_len_tail > 0):
            num_col_len_before_tail = num_g * param.get("col_len_one_group") \
                                      + param.get("block_index")\
                                      * param.get("col_len_one_core")\
                                      + num_col_len_cur_dim_align
            reg_addr[3] = num_col_len_before_tail
            num_col_len_align_two_dim = (row_len_align // param.get(
                "cp_align_len")) * col_len_align
            num_two_dim_before_tail = reg_addr[3] // num_col_len_align_two_dim
            num_col_len_two_dim_tail_before = reg_addr[3]\
                                              % num_col_len_align_two_dim
            num_dim_before_cur_two_tail = num_col_len_two_dim_tail_before\
                                          // col_len_align

            reg_addr[4] = num_col_len_tail
            ub_offset = num_col_len_cur_dim_align * param.get("cp_align_len")
            res_offset = num_col_len_cur_dim_align * param.get("cp_align_len")

            # move data from gm to ub
            data_offset = num_two_dim_before_tail*two_dim_ele\
                          + num_dim_before_cur_two_tail\
                          * param.get("cp_align_len")
            with tvm_ib.if_scope(row_len % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, num_col_len_tail,
                                      name="num_cl") as num_cl:
                    data_offset_cur = data_offset + num_cl * row_len
                    ub_offset_cur = ub_offset + num_cl * param.get(
                        "cp_align_len")
                    tvm_ib.emit(
                        tvm.call_extern(
                            data_ub.dtype, "copy_gm_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset_cur),
                            data.access_ptr(
                                'r', offset=data_offset_cur),
                            0, 1, 1, 0, 0))
            with tvm_ib.else_scope():
                n_burst = num_col_len_tail
                src_stride = row_len // param.get("cp_align_len") - 1
                args = tvm_ib, param, data, data_ub, data_offset, ub_offset,\
                       reg_addr[4], 1, src_stride, 0
                _func_gm_to_ub(args)
            # move data from data_ub to data_res
            row_end = tvm.min(
                (num_dim_before_cur_two_tail + 1) * param.get("cp_align_len"),
                row_len)
            row_true = row_end - (num_dim_before_cur_two_tail
                                  * param.get("cp_align_len"))
            reg_addr[10] = row_true
            with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
                args = tvm_ib, param, data_ub, data_res, reg, reg_addr, \
                       ub_offset, res_offset, row_true, num_r, reg_addr[4]
                _reg_mov_batch_large_10_tail_col(args)
            # move data from data_res to dst
            dst_offset = num_two_dim_before_tail * two_dim_ele \
                         + num_dim_before_cur_two_tail\
                         * param.get("cp_align_len") * col_len
            burst_len_dst = reg_addr[4] // param.get("cp_align_len")
            with tvm_ib.if_scope(col_len % param.get("cp_align_len") > 0):
                with tvm_ib.for_range(0, row_true, name="num_r") as num_r:
                    dst_offset_cur = dst_offset + num_r * col_len
                    res_offset_cur = res_offset + num_r * num_col_len_tail
                    tvm_ib.emit(
                        tvm.call_extern(
                            dst.dtype, "copy_ubuf_to_gm",
                            dst.access_ptr(
                                'w', offset=dst_offset_cur),
                            data_res.access_ptr(
                                "r", offset=res_offset_cur),
                            0, 1, burst_len_dst, 0, 0))
            with tvm_ib.else_scope():
                n_burst = row_true
                reg_addr[5] = col_len - num_col_len_tail
                dst_stride = reg_addr[5] // param.get(
                    "cp_align_len")
                args = tvm_ib, param, dst, data_res, dst_offset,\
                       res_offset, reg_addr[10],\
                       burst_len_dst, 0, dst_stride
                _func_ub_to_gm(args)


def _large_two_dim_ir_10(dst, data, core_divide):
    """
    function of making ir node builder for large two dim 10 scene

    """
    tvm_ib = tvm.ir_builder.create()
    param = _get_param_large_two_dim_10(tvm_ib, data.shape,
                                        dst.dtype, core_divide)
    data_ub = _new_alloc(tvm_ib, dst.dtype,
                         param.get("col_len_one_core")
                         * param.get("cp_align_len"),
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype,
                          param.get("col_len_one_core")
                          * param.get("cp_align_len"),
                          "data_res", scope=cce.scope_ubuf)
    data_align = _new_alloc(tvm_ib, dst.dtype, param.get('cp_align_len'),
                            "data_align", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype,
                           param.get('cp_align_len')
                           * param.get("cp_align_len"),
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_addr = tvm_ib.allocate("int32", (16,), name='reg_addr',
                               scope=cce.scope_reg)
    with tvm_ib.for_range(0, param.get("num_group_index") + 1,
                          name="num_g") as num_g:
        with tvm_ib.if_scope(num_g < param.get("num_group_index")):
            args = tvm_ib, param, data, dst, data_ub, data_res, data_align,\
                   data_tail, reg, reg_addr, num_g,\
                   param.get("col_len_one_core")
            _func_large_two_dim_10(args)
        with tvm_ib.if_scope(tvm.all(num_g >= param.get("num_group_index"),
                                     param.get("num_group_mod") > 0)):
            num_core = param.get("num_group_mod") // param.get(
                "col_len_one_core")
            num_col_len_mod = param.get("num_group_mod") % param.get(
                "col_len_one_core")
            with tvm_ib.if_scope(num_core > 0):
                with tvm_ib.if_scope(param.get("block_index") < num_core):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, data_tail, reg, \
                           reg_addr, num_g, param.get("col_len_one_core")
                    _func_large_two_dim_10(args)
            with tvm_ib.if_scope(num_col_len_mod > 0):
                with tvm_ib.if_scope(
                    tvm.all(param.get("block_index") < (num_core + 1),
                            param.get("block_index") > (num_core - 1))):
                    args = tvm_ib, param, data, dst, data_ub, data_res,\
                           data_align, data_tail, reg, \
                           reg_addr, num_g, num_col_len_mod
                    _func_large_two_dim_10(args)

    return tvm_ib.get()


def _reg_mov_batch_small_shape_102(args):
    """
    reg_mov data in ub for small shape 102 scene

    """
    tvm_ib, data_ub, data_res, reg, reg_addr, col_len, row_len,\
    num_c, num_r, ele_len = args

    ele_reg = 4
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3

    tvm_ib.emit(tvm.call_extern(
        data_ub.dtype, "reg_mov",
        tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
        data_ub.access_ptr('r',
                           offset=(num_c * row_len * ele_len
                                   + num_r * ele_len + reg_zero))
    ))
    tvm_ib.emit(tvm.call_extern(
        data_ub.dtype, "reg_mov",
        tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
        data_ub.access_ptr('r',
                           offset=(num_c * row_len * ele_len
                                   + num_r * ele_len + reg_one))
    ))
    tvm_ib.emit(tvm.call_extern(
        data_ub.dtype, "reg_mov",
        tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
        data_ub.access_ptr('r',
                           offset=(num_c * row_len * ele_len
                                   + num_r * ele_len + reg_two))
    ))
    tvm_ib.emit(tvm.call_extern(
        data_ub.dtype, "reg_mov",
        tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
        data_ub.access_ptr('r',
                           offset=(num_c * row_len * ele_len
                                   + num_r * ele_len + reg_three))
    ))

    tvm_ib.emit(tvm.call_extern(
        data_res.dtype, "reg_mov",
        data_res.access_ptr('w',
                            offset=(num_r * col_len * ele_len
                                    + num_c * ele_len + reg_zero)),
        tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
    ))
    tvm_ib.emit(tvm.call_extern(
        data_res.dtype, "reg_mov",
        data_res.access_ptr('w',
                            offset=(num_r * col_len * ele_len
                                    + num_c * ele_len + reg_one)),
        tvm.call_extern(reg.dtype, "reg", reg[reg_one])
    ))
    tvm_ib.emit(tvm.call_extern(
        data_res.dtype, "reg_mov",
        data_res.access_ptr('w',
                            offset=(num_r * col_len * ele_len
                                    + num_c * ele_len + reg_two)),
        tvm.call_extern(reg.dtype, "reg", reg[reg_two])
    ))
    tvm_ib.emit(tvm.call_extern(
        data_res.dtype, "reg_mov",
        data_res.access_ptr('w',
                            offset=(num_r * col_len * ele_len
                                    + num_c * ele_len + reg_three)),
        tvm.call_extern(reg.dtype, "reg", reg[reg_three])
    ))


def _small_shape_ir_102(dst, data):
    """
    function of making ir node builder for small shape 102 scene

    """
    tvm_ib = tvm.ir_builder.create()
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size
    src_shape = data.shape
    shape_ele = functools_reduce(lambda x, y: x*y, src_shape[:])
    col_len, row_len, ele_len = data.shape
    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_addr = tvm_ib.allocate("int32", (8,), name='reg_addr',
                               scope=cce.scope_reg)

    burst_len = _ceil_div(shape_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w",
                                                   offset=0),
                                data.access_ptr('r',
                                                offset=0),
                                0, 1, burst_len, 0, 0))

    with tvm_ib.if_scope(ele_len == 4):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                args = tvm_ib, data_ub, data_res, reg, reg_addr, col_len,\
                       row_len, num_c, num_r, ele_len
                _reg_mov_batch_small_shape_102(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                with tvm_ib.for_range(0, ele_len, name="num_e") as num_e:
                    tvm_ib.emit(tvm.call_extern(
                        data_ub.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_ub.access_ptr('r',
                                           offset=(num_c*row_len*ele_len
                                                   + num_r*ele_len + num_e))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        data_res.access_ptr(
                            'w',
                            offset=(num_r*col_len*ele_len
                                    + num_c*ele_len + num_e)),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))
    tvm_ib.emit(
        tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                        dst.access_ptr('w',
                                       offset=0),
                        data_res.access_ptr("r",
                                            offset=0),
                        0, 1, burst_len, 0, 0))

    return tvm_ib.get()


def _vconv_for_fp32_0312_one(args):
    """
    function of vnchwconv for 0312 float32 special one scene

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
    repeat_vconv, src_stride_vconv, dst_stride_vconv, c_sub_align_div = args

    src0_offset = 8*0
    src1_offset = 8*1
    dst0_offset = 8*2
    dst1_offset = 8*3
    src_gap = 32*16*c_sub_align_div
    src_eight_gap = src_gap*8
    dst_gap = 32
    dst_eight_gap = dst_gap*8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))

    tvm_ib.emit(tvm.call_extern("int32",
                                "scatter_vnchwconv_b16",
                                "VA2",
                                "VA0",
                                repeat_vconv,
                                dst_stride_vconv,
                                src_stride_vconv))


def _vconv_for_fp32_0312_two(args):
    """
    function of vnchwconv for 0312 float32 special two scene

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
    repeat_vconv, src_stride_vconv, dst_stride_vconv = args

    src0_offset = 8*0
    src1_offset = 8*1
    dst0_offset = 8*2
    dst1_offset = 8*3
    src_gap = 32
    src_eight_gap = src_gap*8
    dst_gap = 64
    dst_eight_gap = dst_gap*8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))

    tvm_ib.emit(tvm.call_extern("int32",
                                "scatter_vnchwconv_b16",
                                "VA2",
                                "VA0",
                                repeat_vconv,
                                dst_stride_vconv,
                                src_stride_vconv))


def _mov_0312_256_vconv_fp32(dst, data, row_zu):
    """
    function of making ir node builder for 0312 float32 special scene

    """
    tvm_ib = tvm.ir_builder.create()
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_one = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_one", scope=cce.scope_ubuf)
    data_two = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_two", scope=cce.scope_ubuf)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, h_i, w_i, c_i = data.shape

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)
    num_block_one_dim = device_core_num // n_i
    num_dim = block_index // num_block_one_dim
    num_block = block_index % num_block_one_dim
    col_len_block = h_i*w_i // num_block_one_dim

    c_sub_align = _ceil_fill(c_i, cp_align_len)
    c_sub_align_div = _ceil_div(c_i, cp_align_len)
    vconv_col_group = c_sub_align // cp_align_len
    ele_256_ub = 256*c_sub_align
    num_256_ub = ub_ele // ele_256_ub
    num_256_shape = h_i * w_i // 256 // num_block_one_dim
    ub_loop = num_256_shape // num_256_ub
    num_256_mod = num_256_shape % num_256_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        col_group = num_256_ub*256 // row_zu
        vconv_group = num_256_ub

        for num_rz in range(row_zu):
            data_offset = num_dim*h_i*w_i*c_i + num_block*col_len_block*c_i\
                          + num_u*num_256_ub*256*c_i + num_rz * c_i
            ub_offset = num_rz * c_sub_align
            n_burst = col_group
            burst_len_data = c_sub_align // cp_align_len
            src_stride = (row_zu * c_i - c_sub_align) // cp_align_len
            dst_stride = (row_zu - 1) * c_sub_align // cp_align_len
            args = tvm_ib, data, data_one, data_offset, ub_offset, n_burst, \
                   burst_len_data, src_stride, dst_stride, cp_align_len
            _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vg * 256 * c_sub_align + num_vc * 8)\
                            * float_size
                two_begin = (ub_ele + num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                repeat_vconv = 16
                src_stride_vconv = c_sub_align_div
                dst_stride_vconv = 16
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div
                _vconv_for_fp32_0312_one(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    n_burst = 16
                    burst_len = 2
                    src_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, src_stride, 0))

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8 * 16) * float_size
            two_begin = (ub_ele + num_h * 8) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0312_two(args)

        dst_offset = num_dim*h_i*w_i*c_i + num_block*col_len_block\
                     + num_u*num_256_ub*256
        n_burst_dst = c_i
        burst_len_dst = num_256_ub*256 // cp_align_len
        dst_stride = (h_i*w_i - num_256_ub*256) // cp_align_len
        args = tvm_ib, dst, data_two, dst_offset, 0, n_burst_dst,\
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(num_256_mod > 0):
        col_group = num_256_mod * 256 // row_zu
        vconv_group = num_256_mod

        for num_rz in range(row_zu):
            data_offset = num_dim*h_i*w_i*c_i + num_block*col_len_block*c_i\
                          + ub_loop * num_256_ub * 256 * c_i + num_rz * c_i
            ub_offset = num_rz * c_sub_align
            n_burst = col_group
            burst_len_data = c_sub_align // cp_align_len
            src_stride = (row_zu * c_i - c_sub_align) // cp_align_len
            dst_stride = (row_zu - 1) * c_sub_align // cp_align_len
            args = tvm_ib, data, data_one, data_offset, ub_offset, n_burst, \
                   burst_len_data, src_stride, dst_stride, cp_align_len
            _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vg * 256 * c_sub_align + num_vc * 8)\
                            * float_size
                two_begin = (ub_ele + num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                repeat_vconv = 16
                src_stride_vconv = c_sub_align_div
                dst_stride_vconv = 16
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div
                _vconv_for_fp32_0312_one(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    n_burst = 16
                    burst_len = 2
                    src_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, src_stride, 0))

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8 * 16) * float_size
            two_begin = (ub_ele + num_h * 8) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0312_two(args)

        dst_offset = num_dim*h_i*w_i*c_i + num_block*col_len_block\
                     + ub_loop * num_256_ub * 256
        n_burst_dst = c_i
        burst_len_dst = num_256_mod * 256 // cp_align_len
        dst_stride = (h_i * w_i - num_256_mod * 256) // cp_align_len
        args = tvm_ib, dst, data_two, dst_offset, 0, n_burst_dst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    return tvm_ib.get()


def _vconv_for_fp32_0231_two(args):
    """
    function of vnchwconv for 0231 float32 special two scene

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
    repeat_vconv, src_stride_vconv, dst_stride_vconv = args

    src0_offset = 8*0
    src1_offset = 8*1
    dst0_offset = 8*2
    dst1_offset = 8*3
    src_gap = 64
    src_eight_gap = src_gap*8
    dst_gap = 32
    dst_eight_gap = dst_gap*8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))

    tvm_ib.emit(tvm.call_extern("int32",
                                "scatter_vnchwconv_b16",
                                "VA2",
                                "VA0",
                                repeat_vconv,
                                dst_stride_vconv,
                                src_stride_vconv))


def _vconv_for_fp32_0231_one(args):
    """
    function of vnchwconv for 0231 float32 special one scene

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
    repeat_vconv, src_stride_vconv, dst_stride_vconv, c_sub_align_div = args

    src0_offset = 8*0
    src1_offset = 8*1
    dst0_offset = 8*2
    dst1_offset = 8*3
    src_gap = 32
    src_eight_gap = src_gap*8
    dst_gap = 32*16*c_sub_align_div
    dst_eight_gap = dst_gap*8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))

    tvm_ib.emit(tvm.call_extern("int32",
                                "scatter_vnchwconv_b16",
                                "VA2",
                                "VA0",
                                repeat_vconv,
                                dst_stride_vconv,
                                src_stride_vconv))


def _mov_0231_256_vconv_fp32(dst, data, row_zu):
    """
    function of making ir node builder for 0231 float32 special scene

    """
    tvm_ib = tvm.ir_builder.create()
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_one = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_one", scope=cce.scope_ubuf)
    data_two = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_two", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, c_i, h_i, w_i = data.shape

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)
    num_block_one_dim = device_core_num // n_i
    num_dim = block_index // num_block_one_dim
    num_block = block_index % num_block_one_dim
    col_len_block = h_i*w_i // num_block_one_dim

    c_small = (c_i // cp_align_len)*cp_align_len
    c_sub_align = _ceil_fill(c_small, cp_align_len)
    c_sub_align_div = _ceil_div(c_small, cp_align_len)
    vconv_col_group = c_sub_align // cp_align_len
    ele_256_ub = 256*c_sub_align
    num_256_ub = ub_ele // ele_256_ub
    num_256_shape = h_i * w_i // 256 // num_block_one_dim
    ub_loop = num_256_shape // num_256_ub
    num_256_mod = num_256_shape % num_256_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        col_group = num_256_ub * 256 // row_zu
        vconv_group = num_256_ub

        data_offset = num_dim * h_i * w_i * c_i + num_block * col_len_block\
                      + num_u * num_256_ub * 256
        n_burst_data = c_small
        burst_len_data = num_256_ub*256 // cp_align_len
        src_stride = (h_i*w_i - num_256_ub*256) // cp_align_len
        args = tvm_ib, data, data_one, data_offset, 0, n_burst_data, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8) * float_size
            two_begin = (ub_ele + num_h * 8 * 16) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0231_two(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    n_burst = 16
                    burst_len = 2
                    dst_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, 0, dst_stride))

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                two_begin = (ub_ele + num_vg * 256 * c_sub_align + num_vc * 8)\
                            * float_size
                repeat_vconv = 16
                src_stride_vconv = 16
                dst_stride_vconv = c_sub_align_div
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div
                _vconv_for_fp32_0231_one(args)

        for num_rz in range(row_zu):
            dst_offset = num_dim * h_i * w_i * c_i\
                         + num_block * col_len_block * c_i \
                         + num_u * num_256_ub * 256 * c_i + num_rz * c_i
            res_offset = num_rz * c_sub_align
            n_burst = col_group
            burst_len_dst = c_sub_align // cp_align_len
            src_stride = (row_zu - 1) * c_sub_align // cp_align_len
            dst_stride = (row_zu * c_i - c_sub_align) // cp_align_len
            args = tvm_ib, dst, data_two, dst_offset, res_offset, n_burst,\
                   burst_len_dst, src_stride, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)

        # move data for after cp_align_len
        c_align = c_i - cp_align_len
        vconv_col_group_align = 1
        c_sub_align_div_align = 1
        c_sub_align_align = 8
        data_offset = num_dim * h_i * w_i * c_i + num_block * col_len_block\
                      + num_u * num_256_ub * 256 + c_align*h_i*w_i
        n_burst_data = cp_align_len
        burst_len_data = num_256_ub * 256 // cp_align_len
        src_stride = (h_i * w_i - num_256_ub * 256) // cp_align_len
        args = tvm_ib, data, data_one, data_offset, 0, n_burst_data,\
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8) * float_size
            two_begin = (ub_ele + num_h * 8 * 16) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group_align
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0231_two(args)

        with tvm_ib.for_range(0, vconv_col_group_align, name="num_vc")\
                as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    n_burst = 16
                    burst_len = 2
                    dst_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, 0, dst_stride))

        with tvm_ib.for_range(0, vconv_col_group_align, name="num_vc")\
                as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                two_begin = (ub_ele + num_vg * 256 * c_sub_align_align
                             + num_vc * 8) * float_size
                repeat_vconv = 16
                src_stride_vconv = 16
                dst_stride_vconv = c_sub_align_div_align
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div_align
                _vconv_for_fp32_0231_one(args)

        for num_rz in range(row_zu):
            dst_offset = num_dim * h_i * w_i * c_i\
                         + num_block * col_len_block * c_i \
                         + num_u * num_256_ub * 256 * c_i\
                         + num_rz * c_i + c_align
            res_offset = num_rz * c_sub_align_align
            n_burst = col_group
            burst_len_dst = c_sub_align_align // cp_align_len
            src_stride = (row_zu - 1) * c_sub_align_align // cp_align_len
            dst_stride = (row_zu * c_i - c_sub_align_align) // cp_align_len
            args = tvm_ib, dst, data_two, dst_offset, res_offset, n_burst, \
                   burst_len_dst, src_stride, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(num_256_mod > 0):
        col_group = num_256_mod * 256 // row_zu
        vconv_group = num_256_mod

        data_offset = num_dim * h_i * w_i * c_i + num_block * col_len_block\
                      + ub_loop * num_256_ub * 256
        n_burst_data = c_small
        burst_len_data = num_256_mod * 256 // cp_align_len
        src_stride = (h_i * w_i - num_256_mod * 256) // cp_align_len
        args = tvm_ib, data, data_one, data_offset, 0, n_burst_data, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8) * float_size
            two_begin = (ub_ele + num_h * 8 * 16) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0231_two(args)

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    n_burst = 16
                    burst_len = 2
                    dst_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, 0, dst_stride))

        with tvm_ib.for_range(0, vconv_col_group, name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                two_begin = (ub_ele + num_vg * 256 * c_sub_align + num_vc * 8)\
                            * float_size
                repeat_vconv = 16
                src_stride_vconv = 16
                dst_stride_vconv = c_sub_align_div
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div
                _vconv_for_fp32_0231_one(args)

        for num_rz in range(row_zu):
            dst_offset = num_dim * h_i * w_i * c_i\
                         + num_block * col_len_block * c_i\
                         + ub_loop * num_256_ub * 256 * c_i + num_rz * c_i
            res_offset = num_rz * c_sub_align
            n_burst = col_group
            burst_len_dst = c_sub_align // cp_align_len
            src_stride = (row_zu - 1) * c_sub_align // cp_align_len
            dst_stride = (row_zu * c_i - c_sub_align) // cp_align_len
            args = tvm_ib, dst, data_two, dst_offset, res_offset, n_burst,\
                   burst_len_dst, src_stride, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)

        # move data for after cp_align_len
        c_align = c_i - cp_align_len
        vconv_col_group_align = 1
        c_sub_align_div_align = 1
        c_sub_align_align = 8
        data_offset = num_dim * h_i * w_i * c_i + num_block * col_len_block\
                      + ub_loop * num_256_ub * 256 + c_align * h_i * w_i
        n_burst_data = cp_align_len
        burst_len_data = num_256_mod * 256 // cp_align_len
        src_stride = (h_i * w_i - num_256_mod * 256) // cp_align_len
        args = tvm_ib, data, data_one, data_offset, 0, n_burst_data, \
                   burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        with tvm_ib.for_range(0, 2, name="num_h") as num_h:
            one_begin = (num_h * 8) * float_size
            two_begin = (ub_ele + num_h * 8 * 16) * float_size
            repeat_vconv = 8 * vconv_group * vconv_col_group_align
            src_stride_vconv = 32
            dst_stride_vconv = 32
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
                       repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_for_fp32_0231_two(args)

        with tvm_ib.for_range(0, vconv_col_group_align,
                              name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                for num_c in range(8):
                    two_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 32 * cp_align_len\
                                 + num_c * 8 * 32 * vconv_group
                    one_offset = num_vc * vconv_group * 256 * cp_align_len\
                                 + num_vg * 256 * cp_align_len + num_c * 8 * 2
                    n_burst = 16
                    burst_len = 2
                    dst_stride = 14
                    tvm_ib.emit(
                        tvm.call_extern(data_one.dtype, "copy_ubuf_to_ubuf",
                                        data_one.access_ptr("w",
                                                            offset=one_offset),
                                        data_two.access_ptr('r',
                                                            offset=two_offset),
                                        0, n_burst, burst_len, 0,
                                        dst_stride))

        with tvm_ib.for_range(0, vconv_col_group_align,
                              name="num_vc") as num_vc:
            with tvm_ib.for_range(0, vconv_group, name="num_vg") as num_vg:
                one_begin = (num_vc * vconv_group * 256 * cp_align_len
                             + num_vg * 256 * cp_align_len) * float_size
                two_begin = (ub_ele + num_vg * 256 * c_sub_align_align
                             + num_vc * 8) * float_size
                repeat_vconv = 16
                src_stride_vconv = 16
                dst_stride_vconv = c_sub_align_div_align
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin,\
                           repeat_vconv, src_stride_vconv, dst_stride_vconv,\
                       c_sub_align_div_align
                _vconv_for_fp32_0231_one(args)

        for num_rz in range(row_zu):
            dst_offset = num_dim * h_i * w_i * c_i\
                         + num_block * col_len_block * c_i \
                         + ub_loop * num_256_ub * 256 * c_i\
                         + num_rz * c_i + c_align
            res_offset = num_rz * c_sub_align_align
            n_burst = col_group
            burst_len_dst = c_sub_align_align // cp_align_len
            src_stride = (row_zu - 1) * c_sub_align_align // cp_align_len
            dst_stride = (row_zu * c_i - c_sub_align_align) // cp_align_len
            args = tvm_ib, dst, data_two, dst_offset, res_offset, n_burst, \
                       burst_len_dst, src_stride, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)

    return tvm_ib.get()


def _vconv_one(args):
    """
    function of vnchwconv for _func_vconv_fp16

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
    repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu = args

    src0_offset = 8 * 0
    src1_offset = 8 * 1
    dst0_offset = 8 * 2
    dst1_offset = 8 * 3
    src_gap = 32 * r_zu
    src_eight_gap = src_gap * 8
    dst_gap = 32 * c_zu
    dst_eight_gap = dst_gap * 8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))
    with tvm_ib.if_scope(repeat_vconv == 1):
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    1,
                                    0,
                                    0))
    with tvm_ib.else_scope():
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    repeat_vconv,
                                    dst_stride_vconv,
                                    src_stride_vconv))


def _func_two_permute_align_small_fp16(args):
    """
    function of moving data for two permute align small fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    n_index = num_g * device_core_num + block_index
    data_offset = n_index * col_len * row_len
    burst_len_data = col_len * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    c_zu = col_len // 16
    r_zu = row_len // 16
    with tvm_ib.if_scope(row_len >= col_len):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len
    burst_len_dst = col_len * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _two_permute_align_small_fp16(dst, data):
    """
    function of making ir node builder for permute align small fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_permute_align_small_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_permute_align_small_fp16(args)

    return tvm_ib.get()


def _func_two_permute_align_split_row_fp16(args):
    """
    function of moving data for two permute align split row fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_len_ub = (ub_ele // col_len // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

        data_offset = n_index * col_len * row_len + num_u * row_len_ub
        n_burst = col_len
        burst_len_data = row_len_ub // cp_align_len
        src_stride = (row_len - row_len_ub) // cp_align_len
        args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        c_zu = col_len // 16
        r_zu = row_len_ub // 16
        with tvm_ib.if_scope(row_len_ub >= col_len):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_ub * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len * row_len_ub
        burst_len_dst = (col_len * row_len_ub) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(ub_mod > 0):
        data_offset = n_index * col_len * row_len + ub_loop * row_len_ub
        n_burst = col_len
        burst_len_data = ub_mod // cp_align_len
        src_stride = (row_len - ub_mod) // cp_align_len
        args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        c_zu = col_len // 16
        r_zu = ub_mod // 16
        with tvm_ib.if_scope(ub_mod >= col_len):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * ub_mod * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + ub_loop * col_len * row_len_ub
        burst_len_dst = (col_len * ub_mod) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_permute_align_split_row_fp16(dst, data):
    """
    function of making ir node builder for permute align split row fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_permute_align_split_row_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_permute_align_split_row_fp16(args)

    return tvm_ib.get()


def _move_for_permute_split_row_fp16_fencore(args):
    """
    function of moving data for two permute align split row fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    float_size, cp_align_len, ub_ele, n_index, col_len,\
    row_len, row_len_begin, row_len_now = args

    data_offset = n_index * col_len * row_len + row_len_begin
    n_burst = col_len
    burst_len_data = row_len_now // cp_align_len
    src_stride = (row_len - row_len_now) // cp_align_len
    args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
           burst_len_data, src_stride, 0, cp_align_len
    _func_gm_to_ub_align(args)

    c_zu = col_len // 16
    r_zu = row_len_now // 16
    with tvm_ib.if_scope(row_len_now >= col_len):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_now * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len + col_len * row_len_begin
    burst_len_dst = (col_len * row_len_now) // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_permute_align_split_row_fp16_fencore_nomod(args):
    """
    function of two permute align split row fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, row_len_begin, row_len_now
    _move_for_permute_split_row_fp16_fencore(args)


def _func_two_permute_align_split_row_fp16_fencore_mod(args):
    """
    function of two permute align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index,\
               col_len, row_len, row_len_begin, row_len_now
        _move_for_permute_split_row_fp16_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = ub_mod
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, row_len_begin, row_len_now
        _move_for_permute_split_row_fp16_fencore(args)


def _two_permute_align_split_row_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for permute align split row fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    row_len_ub = (ub_ele // col_len // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_permute_align_split_row_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_permute_align_split_row_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_permute_align_split_row_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_permute_align_split_row_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_permute_align_split_col_fp16(args):
    """
    function of moving data for permute align split col fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    col_len_ub = (ub_ele // row_len // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = (col_len_ub * row_len) // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        c_zu = col_len_ub // 16
        r_zu = row_len // 16
        with tvm_ib.if_scope(row_len >= col_len_ub):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_ub * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len_ub
        n_burst = row_len
        burst_len_dst = col_len_ub // cp_align_len
        dst_stride = (col_len - col_len_ub) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(ub_mod > 0):
        data_offset = n_index * col_len * row_len\
                      + ub_loop * col_len_ub * row_len
        burst_len_data = (ub_mod * row_len) // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        c_zu = ub_mod // 16
        r_zu = row_len // 16
        with tvm_ib.if_scope(row_len >= ub_mod):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_mod * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + ub_loop * col_len_ub
        n_burst = row_len
        burst_len_dst = ub_mod // cp_align_len
        dst_stride = (col_len - ub_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _two_permute_align_split_col_fp16(dst, data):
    """
    function of making ir node builder for permute align split col fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_permute_align_split_col_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_permute_align_split_col_fp16(args)

    return tvm_ib.get()


def _move_for_permute_split_col_fp16_fencore(args):
    """
    function of moving data for permute align split col fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf, \
    float_size, cp_align_len, ub_ele, n_index, col_len, \
    row_len, col_len_begin, col_len_now = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = (col_len_now * row_len) // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len // 16
    with tvm_ib.if_scope(row_len >= col_len_now):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len + col_len_begin
    n_burst = row_len
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
           burst_len_dst, 0, dst_stride, cp_align_len
    _func_ub_to_gm_align(args)


def _func_two_permute_align_split_col_fp16_fencore_nomod(args):
    """
    function for permute align split col fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, col_len_begin, col_len_now
    _move_for_permute_split_col_fp16_fencore(args)


def _func_two_permute_align_split_col_fp16_fencore_mod(args):
    """
    function for permute align split col fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index,\
               col_len, row_len, col_len_begin, col_len_now
        _move_for_permute_split_col_fp16_fencore(args)

    with tvm_ib.else_scope():
        col_len_now = ub_mod
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_permute_split_col_fp16_fencore(args)


def _two_permute_align_split_col_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for permute align split col fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    col_len_ub = (ub_ele // row_len // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_permute_align_split_col_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_permute_align_split_col_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_permute_align_split_col_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_permute_align_split_col_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_permute_align_large_fp16(args):
    """
    function of moving data for permute align large fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

            data_offset = n_index * col_len * row_len\
                          + num_u * ub_col * row_len + num_rowz * row_ub
            n_burst = ub_col
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            dst_offset = n_index * col_len * row_len\
                         + num_rowz * row_ub * col_len + num_u * ub_col
            n_burst = row_ub
            burst_len_dst = ub_col // cp_align_len
            dst_stride = (col_len - ub_col) // cp_align_len
            args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
                   burst_len_dst, 0, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)
        with tvm_ib.if_scope(ub_col_mod > 0):
            data_offset = n_index * col_len * row_len \
                          + ub_loop * ub_col * row_len + num_rowz * row_ub
            n_burst = ub_col_mod
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col_mod // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col_mod * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            dst_offset = n_index * col_len * row_len \
                         + num_rowz * row_ub * col_len + ub_loop * ub_col
            n_burst = row_ub
            burst_len_dst = ub_col_mod // cp_align_len
            dst_stride = (col_len - ub_col_mod) // cp_align_len
            args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
                   burst_len_dst, 0, dst_stride, cp_align_len
            _func_ub_to_gm_align(args)


def _two_permute_align_large_fp16(dst, data):
    """
    function of making ir node builder for permute align large fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_permute_align_large_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_permute_align_large_fp16(args)

    return tvm_ib.get()


def _move_for_permute_large_fp16_fencore(args):
    """
    function of moving data for permute align large fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    ub_ele, float_size, cp_align_len, col_len, row_len, n_index,\
    row_index, row_ub, col_len_now, col_len_begin = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len + row_index * row_ub
    n_burst = col_len_now
    burst_len_data = row_ub // cp_align_len
    src_stride = (row_len - row_ub) // cp_align_len
    args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
           burst_len_data, src_stride, 0, cp_align_len
    _func_gm_to_ub_align(args)

    c_zu = col_len_now // 16
    r_zu = row_ub // 16
    with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
        one_begin = (num_rz * 16) * float_size
        two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
        repeat_vconv = c_zu
        src_stride_vconv = 16 * r_zu
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, \
               two_begin, repeat_vconv, src_stride_vconv, \
               dst_stride_vconv, r_zu, c_zu
        _vconv_one(args)

    dst_offset = n_index * col_len * row_len \
                 + row_index * row_ub * col_len + col_len_begin
    n_burst = row_ub
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
           burst_len_dst, 0, dst_stride, cp_align_len
    _func_ub_to_gm_align(args)


def _func_two_permute_align_large_fp16_fencore_nomod(args):
    """
    function for permute align large fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_zu, \
    row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = ub_col
    col_len_begin = col_index * ub_col
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
           row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
    _move_for_permute_large_fp16_fencore(args)


def _func_two_permute_align_large_fp16_fencore_mod(args):
    """
    function for permute align large fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_zu, \
    row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(col_index < col_fen - 1):
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len,\
               row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
        _move_for_permute_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        col_len_now = ub_col_mod
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
        _move_for_permute_large_fp16_fencore(args)


def _two_permute_align_large_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for permute align large fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    with tvm_ib.if_scope(ub_col_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
            _func_two_permute_align_large_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, row_zu, \
                       row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, \
                       group_index
                _func_two_permute_align_large_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
            _func_two_permute_align_large_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, row_zu, \
                       row_ub, fen_n, ub_loop, ub_col, ub_col_mod, \
                       col_fen, group_index
                _func_two_permute_align_large_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _set_mask(length):
    """
    calculate MASK in cce

    Parameters
    ----------
    length : int
        calculate length

    Returns
    -------
    mask : tuple of int
        low and high bit of mask.
    """
    length = int(length)
    mask1 = 2**max(length - 64, 0) - 1  # high 64bits
    mask2 = 2**min(length, 64) - 1  # low 64bits
    return mask1, mask2


def _func_two_col_align_little_fp16(args):
    """
    function for col align little fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(row_len <= 31):
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            add_zu = col_len // 8
            add_mod = col_len % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len
                repeat = add_zu
                srcm0 = row_len
                dstm0 = 1
                srcm1 = srcm0 * 8
                dstm1 = 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                ub_offset = num_r * 16 * col_len + add_zu * 8 * 16
                repeat = 1
                srcm0 = row_len
                dstm0 = 1
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len
            n_burst = col_len
            burst_len = 1
            src_stride = row_len - 1
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len
    burst_len_dst = dim_ele // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _two_col_align_little_fp16(dst, data):
    """
    function of making ir node builder for col align little fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_little_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_little_fp16(args)

    return tvm_ib.get()


def _func_two_col_align_small_fp16(args):
    """
    function of moving data for col align small fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len + num_c * row_len
        ub_offset = num_c * row_len_align
        burst_len_data = _ceil_div(row_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len // 16
    r_zu = row_len_align // 16
    with tvm_ib.if_scope(row_len_align >= col_len):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_align * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len
    burst_len_dst = (col_len * row_len) // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _two_col_align_small_fp16(dst, data):
    """
    function of making ir node builder for col align small fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_small_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_small_fp16(args)

    return tvm_ib.get()


def _func_two_col_align_split_row_fp16(args):
    """
    function of moving data for col align split row fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_len_ub = (ub_ele // col_len // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len + num_c * row_len\
                          + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len // 16
        r_zu = row_len_ub // 16
        with tvm_ib.if_scope(row_len_ub >= col_len):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_ub * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len * row_len_ub
        burst_len_dst = (col_len * row_len_ub) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)

        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len + num_c * row_len\
                          + ub_loop * row_len_ub
            ub_offset = num_c * ub_mod_align
            burst_len_data = _ceil_div(ub_mod, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len // 16
        r_zu = ub_mod_align // 16
        with tvm_ib.if_scope(ub_mod_align >= col_len):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * ub_mod_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + ub_loop * col_len * row_len_ub
        burst_len_dst = (col_len * ub_mod) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_col_align_split_row_fp16(dst, data):
    """
    function of making ir node builder for col align split row fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_split_row_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_split_row_fp16(args)

    return tvm_ib.get()


def _move_for_col_align_split_row_fp16_fencore(args):
    """
    function of moving data for col align split row fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    col_len, row_len, cp_align_len, float_size, ub_ele, n_index,\
    row_len_ub, row_len_begin, row_len_now = args

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len + num_c * row_len \
                      + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len // 16
    r_zu = row_len_now // 16
    with tvm_ib.if_scope(row_len_now >= col_len):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_now * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len + row_len_begin * col_len
    burst_len_dst = (col_len * row_len_now) // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_col_align_split_row_fp16_fencore_nomod(args):
    """
    function for col align split row fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
           col_len, row_len, cp_align_len, float_size, ub_ele, n_index,\
           row_len_ub, row_len_begin, row_len_now
    _move_for_col_align_split_row_fp16_fencore(args)


def _func_two_col_align_split_row_fp16_fencore_mod(args):
    """
    function for col align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, col_len, row_len, cp_align_len, float_size,\
               ub_ele, n_index, row_len_ub, row_len_begin, row_len_now
        _move_for_col_align_split_row_fp16_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = _ceil_fill(ub_mod, cp_align_len)
        row_len_begin = row_len - row_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, col_len, row_len, cp_align_len, float_size, \
               ub_ele, n_index, row_len_ub, row_len_begin, row_len_now
        _move_for_col_align_split_row_fp16_fencore(args)


def _two_col_align_split_row_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for two col align split row fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    row_len_ub = (ub_ele // col_len // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_row_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_row_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_row_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_row_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_col_align_split_col_fp16(args):
    """
    function of moving data for col align split col fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    col_len_ub = (ub_ele // row_len_align // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len_ub, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + num_u * col_len_ub * row_len + num_cl * row_len
            ub_offset = num_cl * row_len_align
            burst_len_data = _ceil_div(row_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len_ub // 16
        r_zu = row_len_align // 16
        with tvm_ib.if_scope(row_len_align >= col_len_ub):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_ub * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len_ub
        n_burst = row_len
        burst_len_dst = col_len_ub // cp_align_len
        dst_stride = (col_len - col_len_ub) // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, n_burst, burst_len_dst, 0, dst_stride))

    with tvm_ib.if_scope(ub_mod > 0):
        with tvm_ib.for_range(0, ub_mod, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + ub_loop * col_len_ub * row_len + num_cl * row_len
            ub_offset = num_cl * row_len_align
            burst_len_data = _ceil_div(row_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_mod // 16
        r_zu = row_len_align // 16
        with tvm_ib.if_scope(row_len_align >= ub_mod):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_mod * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        dst_offset = n_index * col_len * row_len + ub_loop * col_len_ub
        n_burst = row_len
        burst_len_dst = ub_mod // cp_align_len
        dst_stride = (col_len - ub_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _two_col_align_split_col_fp16(dst, data):
    """
    function of making ir node builder for col align split col fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_split_col_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_split_col_fp16(args)

    return tvm_ib.get()


def _move_for_col_align_split_col_fp16_fencore(args):
    """
    function of moving data for col align split col fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    ub_ele, cp_align_len, float_size, col_len, row_len, row_len_align,\
    n_index, col_len_ub, col_len_now, col_len_begin = args

    with tvm_ib.for_range(0, col_len_now, name="num_cl") as num_cl:
        data_offset = n_index * col_len * row_len \
                      + col_len_begin * row_len + num_cl * row_len
        ub_offset = num_cl * row_len_align
        burst_len_data = _ceil_div(row_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len_align // 16
    with tvm_ib.if_scope(row_len_align >= col_len_now):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_align * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    dst_offset = n_index * col_len * row_len + col_len_begin
    n_burst = row_len
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, n_burst, burst_len_dst, 0, dst_stride))


def _func_two_col_align_split_col_fp16_fencore_nomod(args):
    """
    function for col align split col fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, cp_align_len, float_size, \
           col_len, row_len, row_len_align, n_index, \
           col_len_ub, col_len_now, col_len_begin
    _move_for_col_align_split_col_fp16_fencore(args)


def _func_two_col_align_split_col_fp16_fencore_mod(args):
    """
    function for col align split col fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, cp_align_len, float_size,\
               col_len, row_len, row_len_align, n_index,\
               col_len_ub, col_len_now, col_len_begin
        _move_for_col_align_split_col_fp16_fencore(args)

    with tvm_ib.else_scope():
        col_len_now = _ceil_fill(ub_mod, cp_align_len)
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, cp_align_len, float_size, \
               col_len, row_len, row_len_align, n_index, \
               col_len_ub, col_len_now, col_len_begin
        _move_for_col_align_split_col_fp16_fencore(args)


def _two_col_align_split_col_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for col align split col fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    col_len_ub = (ub_ele // row_len_align // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_col_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_col_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_col_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_col_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_col_align_split_col_fp16_new(args):
    """
    function for col align split col fp16 new scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = num_col_len_ub * 16
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = col_len_ub * row_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele_align = col_len_ub * row_len
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(row_len <= 31):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                add_zu = col_len_ub // 8
                add_mod = col_len_ub % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_r * 16
                    ub_offset = num_r * 16 * col_len_ub
                    repeat = add_zu
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = srcm0 * 8
                    dstm1 = 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                    ub_offset = num_r * 16 * col_len_ub + add_zu * 8 * 16
                    repeat = 1
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len_ub
                n_burst = col_len_ub
                burst_len = 1
                src_stride = row_len - 1
                dst_stride = 0
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len + num_u * col_len_ub
        n_burst = row_len
        burst_len_dst = col_len_ub // cp_align_len
        dst_stride = (col_len - col_len_ub) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(ub_mod > 0):
        data_offset = n_index * col_len * row_len \
                      + ub_loop * col_len_ub * row_len
        burst_len_data = ub_mod * row_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele_align = ub_mod * row_len
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(row_len <= 31):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                add_zu = ub_mod // 8
                add_mod = ub_mod % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_r * 16
                    ub_offset = num_r * 16 * ub_mod
                    repeat = add_zu
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = srcm0 * 8
                    dstm1 = 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                    ub_offset = num_r * 16 * ub_mod + add_zu * 8 * 16
                    repeat = 1
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                res_offset = num_r * 16
                ub_offset = num_r * 16 * ub_mod
                n_burst = ub_mod
                burst_len = 1
                src_stride = row_len - 1
                dst_stride = 0
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len + ub_loop * col_len_ub
        n_burst = row_len
        burst_len_dst = ub_mod // cp_align_len
        dst_stride = (col_len - ub_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _two_col_align_split_col_fp16_new(dst, data):
    """
    function of making ir node builder for col align split col fp16 new scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_split_col_fp16_new(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_split_col_fp16_new(args)

    return tvm_ib.get()


def _move_for_col_align_split_col_fp16_new_fencore(args):
    """
    function of moving data for col align split col fp16 new fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    ub_ele, cp_align_len, float_size, col_len, row_len, row_len_align,\
    n_index, col_len_ub, col_len_now, col_len_begin = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = col_len_now * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    dim_ele_align = col_len_now * row_len
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(row_len <= 31):
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            add_zu = col_len_now // 8
            add_mod = col_len_now % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len_now
                repeat = add_zu
                srcm0 = row_len
                dstm0 = 1
                srcm1 = srcm0 * 8
                dstm1 = 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                ub_offset = num_r * 16 * col_len_now + add_zu * 8 * 16
                repeat = 1
                srcm0 = row_len
                dstm0 = 1
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_now
            n_burst = col_len_now
            burst_len = 1
            src_stride = row_len - 1
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len + col_len_begin
    n_burst = row_len
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
           burst_len_dst, 0, dst_stride, cp_align_len
    _func_ub_to_gm_align(args)


def _func_two_col_align_split_col_fp16_new_fencore_nomod(args):
    """
    function for col align split col fp16 new fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, cp_align_len, float_size, \
           col_len, row_len, row_len_align, n_index, \
           col_len_ub, col_len_now, col_len_begin
    _move_for_col_align_split_col_fp16_new_fencore(args)


def _func_two_col_align_split_col_fp16_new_fencore_mod(args):
    """
    function for col align split col fp16 new fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, cp_align_len, float_size,\
               col_len, row_len, row_len_align, n_index,\
               col_len_ub, col_len_now, col_len_begin
        _move_for_col_align_split_col_fp16_new_fencore(args)

    with tvm_ib.else_scope():
        col_len_now = _ceil_fill(ub_mod, cp_align_len)
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, cp_align_len, float_size, \
               col_len, row_len, row_len_align, n_index, \
               col_len_ub, col_len_now, col_len_begin
        _move_for_col_align_split_col_fp16_new_fencore(args)


def _two_col_align_split_col_fp16_new_fencore(dst, data):
    """
    function of making ir node builder
    for col align split col fp16 new fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, col_len, row_len = data.shape
    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = num_col_len_ub * 16
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_col_fp16_new_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_col_fp16_new_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_col_align_split_col_fp16_new_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_col_align_split_col_fp16_new_fencore_nomod(args)

    return tvm_ib.get()


def _move_data_large(args):
    """
    function of moving data for large scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    cp_align_len, col_len, row_len, ub_ele, float_size, row_ub, ub_loop,\
    ub_col, ub_col_mod, n_index, num_rowz, row_len_now = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, ub_col, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (num_u * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + num_rowz * row_ub * col_len + num_u * ub_col
        n_burst = row_len_now
        burst_len_dst = ub_col // cp_align_len
        dst_stride = (col_len - ub_col) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(ub_col_mod > 0):
        with tvm_ib.for_range(0, ub_col_mod, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (ub_loop * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col_mod // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col_mod * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + num_rowz * row_ub * col_len + ub_loop * ub_col
        n_burst = row_len_now
        burst_len_dst = ub_col_mod // cp_align_len
        dst_stride = (col_len - ub_col_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _func_two_col_align_large_fp16(args):
    """
    function of moving data for col align large fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    row_zu = row_len_align // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.if_scope(num_rowz < (row_zu - 1)):
            row_len_now = row_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
                   addr_array_buf, cp_align_len, col_len, row_len, ub_ele,\
                   float_size, row_ub, ub_loop, ub_col, ub_col_mod, n_index,\
                   num_rowz, row_len_now
            _move_data_large(args)

        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, cp_align_len, col_len, row_len, ub_ele, \
                   float_size, row_ub, ub_loop, ub_col, ub_col_mod, n_index, \
                   num_rowz, row_len_now
            _move_data_large(args)


def _two_col_align_large_fp16(dst, data):
    """
    function of making ir node builder for col align large fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_col_align_large_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_col_align_large_fp16(args)

    return tvm_ib.get()


def _move_data_large_fencore(args):
    """
    function of moving data for large fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    cp_align_len, col_len, row_len, ub_ele, float_size, row_ub, ub_loop,\
    ub_col, ub_col_mod, n_index, num_rowz, row_len_now = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, ub_col, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (num_u * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + num_rowz * row_ub * col_len + num_u * ub_col
        n_burst = row_len_now
        burst_len_dst = ub_col // cp_align_len
        dst_stride = (col_len - ub_col) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)

    with tvm_ib.if_scope(ub_col_mod > 0):
        with tvm_ib.for_range(0, ub_col_mod, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (ub_loop * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col_mod // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col_mod * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        dst_offset = n_index * col_len * row_len\
                     + num_rowz * row_ub * col_len + ub_loop * ub_col
        n_burst = row_len_now
        burst_len_dst = ub_col_mod // cp_align_len
        dst_stride = (col_len - ub_col_mod) // cp_align_len
        args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
               burst_len_dst, 0, dst_stride, cp_align_len
        _func_ub_to_gm_align(args)


def _move_for_col_align_large_fp16_fencore(args):
    """
    function of moving data for col align large fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
    row_len, n_index, row_index, row_ub, \
    row_len_now, col_len_now, col_len_begin = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, col_len_now, name="num_uc") as num_uc:
        data_offset = n_index * col_len * row_len \
                      + (col_len_begin + num_uc) * row_len \
                      + row_index * row_ub
        ub_offset = num_uc * row_len_now_align
        burst_len_data = _ceil_div(row_len_now, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len_now_align // 16
    with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
        one_begin = (num_rz * 16) * float_size
        two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
        repeat_vconv = c_zu
        src_stride_vconv = 16 * r_zu
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, \
               two_begin, repeat_vconv, src_stride_vconv, \
               dst_stride_vconv, r_zu, c_zu
        _vconv_one(args)

    dst_offset = n_index * col_len * row_len \
                 + row_index * row_ub * col_len + col_len_begin
    n_burst = row_len_now
    burst_len_dst = col_len_now // cp_align_len
    dst_stride = (col_len - col_len_now) // cp_align_len
    args = tvm_ib, dst, data_res, dst_offset, 0, n_burst, \
           burst_len_dst, 0, dst_stride, cp_align_len
    _func_ub_to_gm_align(args)


def _func_two_col_align_large_fp16_fencore_nomod(args):
    """
    function for col align large fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod,\
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        row_len_now = row_ub
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_col_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = row_len - (row_zu - 1) * row_ub
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_col_align_large_fp16_fencore(args)


def _func_two_col_align_large_fp16_fencore_mod(args):
    """
    function for col align large fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod,\
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_ub
            col_len_now = ub_col
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len,\
                   col_len, row_len, n_index, row_index, row_ub,\
                   row_len_now, col_len_now, col_len_begin
            _move_for_col_align_large_fp16_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_ub
            col_len_now = ub_col_mod
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len,\
                   col_len, row_len, n_index, row_index, row_ub,\
                   row_len_now, col_len_now, col_len_begin
            _move_for_col_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_len - (row_zu - 1) * row_ub
            col_len_now = ub_col
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len,\
                   col_len, row_len, n_index, row_index, row_ub,\
                   row_len_now, col_len_now, col_len_begin
            _move_for_col_align_large_fp16_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            col_len_now = ub_col_mod
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len,\
                   col_len, row_len, n_index, row_index, row_ub,\
                   row_len_now, col_len_now, col_len_begin
            _move_for_col_align_large_fp16_fencore(args)


def _two_col_align_large_fp16_fencore(dst, data):
    """
    function of making ir node builder for col align large fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    row_zu = row_len_align // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_col_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, num_g
            _func_two_col_align_large_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen,\
                       ub_col, ub_col_mod, group_index
                _func_two_col_align_large_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, num_g
            _func_two_col_align_large_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen,\
                       ub_col, ub_col_mod, group_index
                _func_two_col_align_large_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_row_align_little_fp16(args):
    """
    function of moving data for row align little fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(col_len <= 31):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            add_zu = row_len // 8
            add_mod = row_len % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_c * 16 * row_len
                ub_offset = num_c * 16
                repeat = add_zu
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 8
                dstm1 = dstm0 * 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_c * 16 * row_len + add_zu * 8 * 16
                ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                repeat = 1
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            res_offset = num_c * 16 * row_len
            ub_offset = num_c * 16
            n_burst = row_len
            burst_len = 1
            src_stride = 0
            dst_stride = col_len - 1
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len
    burst_len_dst = dim_ele // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _two_row_align_little_fp16(dst, data):
    """
    function of making ir node builder for row align little fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_little_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_little_fp16(args)

    return tvm_ib.get()


def _func_two_row_align_small_fp16(args):
    """
    function of moving data for row align large small fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    col_len_align = _ceil_fill(col_len, cp_align_len)

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = col_len * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    c_zu = col_len_align // 16
    r_zu = row_len // 16
    with tvm_ib.if_scope(row_len >= col_len_align):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                   two_begin, repeat_vconv, src_stride_vconv,\
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                   two_begin, repeat_vconv, src_stride_vconv,\
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, (row_len - 1), name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len + num_r * col_len
        res_offset = num_r * col_len_align
        burst_len_dst = _ceil_div(col_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))

    move_len = col_len - cp_align_len
    dst_offset = n_index * col_len * row_len + (row_len - 1) * col_len
    with tvm_ib.if_scope(move_len > 0):
        res_offset = (row_len - 1) * col_len_align
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_res.access_ptr(
                'r', offset=(row_len - 1) * col_len_align + move_len + num_a)
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr(
                'w', offset=num_a),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset + move_len),
                                data_tail.access_ptr("r", offset=0),
                                0, 1, 1, 0, 0))


def _two_row_align_small_fp16(dst, data):
    """
    function of making ir node builder for row align small fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_small_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_small_fp16(args)

    return tvm_ib.get()


def _func_two_row_align_split_row_fp16(args):
    """
    function of moving data for row align split row fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    col_len_align = _ceil_fill(col_len, cp_align_len)

    row_len_ub = (ub_ele // col_len_align // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index
    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        data_offset = n_index * col_len * row_len + num_u * row_len_ub
        n_burst = col_len
        burst_len_data = row_len_ub // cp_align_len
        src_stride = (row_len - row_len_ub) // cp_align_len
        args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        c_zu = col_len_align // 16
        r_zu = row_len_ub // 16
        with tvm_ib.if_scope(row_len_ub >= col_len_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_ub * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_align * 16)\
                            * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.if_scope(ub_mod > 0):
            with tvm_ib.for_range(0, row_len_ub, name="num_rl") as num_rl:
                dst_offset = n_index * col_len * row_len\
                             + (num_u * row_len_ub + num_rl) * col_len
                res_offset = num_rl * col_len_align
                burst_len_dst = _ceil_div(col_len, cp_align_len)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))
        with tvm_ib.else_scope():
            with tvm_ib.if_scope(num_u < ub_loop - 1):
                with tvm_ib.for_range(0, row_len_ub, name="num_rl") as num_rl:
                    dst_offset = n_index * col_len * row_len \
                                 + (num_u * row_len_ub + num_rl) * col_len
                    res_offset = num_rl * col_len_align
                    burst_len_dst = _ceil_div(col_len, cp_align_len)
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_offset),
                                                data_res.access_ptr(
                                                    "r", offset=res_offset),
                                                0, 1, burst_len_dst, 0, 0))

            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, (row_len_ub - 1), name="num_rl")\
                        as num_rl:
                    dst_offset = n_index * col_len * row_len \
                                 + (num_u * row_len_ub + num_rl) * col_len
                    res_offset = num_rl * col_len_align
                    burst_len_dst = _ceil_div(col_len, cp_align_len)
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_offset),
                                                data_res.access_ptr(
                                                    "r", offset=res_offset),
                                                0, 1, burst_len_dst, 0, 0))

                move_len = col_len - cp_align_len
                dst_offset = n_index * col_len * row_len \
                             + (num_u * row_len_ub + row_len_ub - 1)\
                             * col_len
                res_offset = (row_len_ub - 1) * col_len_align
                burst_len_dst = _ceil_div(move_len, cp_align_len)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))
                with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_res.access_ptr(
                            'r',
                            offset=((row_len_ub - 1) * col_len_align
                                    + move_len + num_a))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_tail.dtype, "reg_mov",
                        data_tail.access_ptr(
                            'w', offset=num_a),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset + move_len),
                                            data_tail.access_ptr(
                                                "r", offset=0),
                                            0, 1, 1, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        data_offset = n_index * col_len * row_len + ub_loop * row_len_ub
        n_burst = col_len
        burst_len_data = ub_mod // cp_align_len
        src_stride = (row_len - ub_mod) // cp_align_len
        args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
               burst_len_data, src_stride, 0, cp_align_len
        _func_gm_to_ub_align(args)

        c_zu = col_len_align // 16
        r_zu = ub_mod // 16
        with tvm_ib.if_scope(ub_mod >= col_len_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * ub_mod * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_align * 16)\
                            * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, (ub_mod - 1), name="num_rl") as num_rl:
            dst_offset = n_index * col_len * row_len \
                         + (ub_loop * row_len_ub + num_rl) * col_len
            res_offset = num_rl * col_len_align
            burst_len_dst = _ceil_div(col_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

        move_len = col_len - cp_align_len
        dst_offset = n_index * col_len * row_len \
                     + (ub_loop * row_len_ub + ub_mod - 1) * col_len
        res_offset = (ub_mod - 1) * col_len_align
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=(ub_mod - 1) * col_len_align + move_len + num_a)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + move_len),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))


def _two_row_align_split_row_fp16(dst, data):
    """
    function of making ir node builder for row align split row fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_split_row_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_split_row_fp16(args)

    return tvm_ib.get()


def _move_for_row_align_split_row_fp16_fencore_mod(args):
    """
    function of moving data for row align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, cp_align_len, float_size, ub_ele, \
    col_len, row_len, n_index, row_len_ub, \
    row_len_begin, row_len_now, ub_mod, fen_n, fen_index = args

    col_len_align = _ceil_fill(col_len, cp_align_len)

    data_offset = n_index * col_len * row_len + row_len_begin
    n_burst = col_len
    burst_len_data = row_len_now // cp_align_len
    src_stride = (row_len - row_len_now) // cp_align_len
    args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
           burst_len_data, src_stride, 0, cp_align_len
    _func_gm_to_ub_align(args)

    c_zu = col_len_align // 16
    r_zu = row_len_now // 16
    with tvm_ib.if_scope(row_len_now >= col_len_align):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_now * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, (row_len_now - 1),
                          name="num_rl") as num_rl:
        dst_offset = n_index * col_len * row_len \
                     + (row_len_begin + num_rl) * col_len
        res_offset = num_rl * col_len_align
        burst_len_dst = _ceil_div(col_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))

    move_len = col_len - cp_align_len
    dst_offset = n_index * col_len * row_len \
                 + (row_len_begin + row_len_now - 1) * col_len
    res_offset = (row_len_now - 1) * col_len_align
    burst_len_dst = _ceil_div(move_len, cp_align_len)
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, 1, burst_len_dst, 0, 0))
    with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_res.access_ptr(
                'r', offset=((row_len_now - 1) * col_len_align
                             + move_len + num_a))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr(
                'w', offset=num_a),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset + move_len),
                                data_tail.access_ptr(
                                    "r", offset=0),
                                0, 1, 1, 0, 0))


def _func_two_row_align_split_row_fp16_fencore_nomod(args):
    """
    function for row align split row fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
           addr_array, addr_array_buf, cp_align_len, float_size, ub_ele, \
           col_len, row_len, n_index, row_len_ub, \
           row_len_begin, row_len_now, ub_mod, fen_n, fen_index
    _move_for_row_align_split_row_fp16_fencore_mod(args)


def _func_two_row_align_split_row_fp16_fencore_mod(args):
    """
    function for row align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, cp_align_len, float_size,\
               ub_ele, col_len, row_len, n_index, row_len_ub, \
               row_len_begin, row_len_now, ub_mod, fen_n, fen_index
        _move_for_row_align_split_row_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        row_len_now = ub_mod
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, cp_align_len, float_size,\
               ub_ele, col_len, row_len, n_index, row_len_ub, \
               row_len_begin, row_len_now, ub_mod, fen_n, fen_index
        _move_for_row_align_split_row_fp16_fencore_mod(args)


def _two_row_align_split_row_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for row align split row fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    col_len_align = _ceil_fill(col_len, cp_align_len)

    row_len_ub = (ub_ele // col_len_align // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_row_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_row_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_row_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_row_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_vadds(args):
    """
    function of moving data with vadds function

    """
    tvm_ib, data_ub, data_res, ub_offset, res_offset,\
    repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len = args
    max_r = 255

    with tvm_ib.if_scope(repeat <= max_r):
        with tvm_ib.if_scope(repeat == 1):
            tvm_ib.emit(tvm.call_extern(data_res.dtype, "vadds",
                                        data_res.access_ptr("w",
                                                            offset=res_offset),
                                        data_ub.access_ptr('r',
                                                           offset=ub_offset),
                                        0, repeat, dstm0, srcm0, 0, 0))
        with tvm_ib.else_scope():
            tvm_ib.emit(tvm.call_extern(data_res.dtype, "vadds",
                                        data_res.access_ptr("w",
                                                            offset=res_offset),
                                        data_ub.access_ptr('r',
                                                           offset=ub_offset),
                                        0, repeat, dstm0, srcm0, dstm1, srcm1))
    with tvm_ib.else_scope():
        zu_repeat = repeat // max_r
        mod_repeat = repeat % max_r
        with tvm_ib.for_range(0, zu_repeat, name="num_zr") as num_zr:
            ub_offset_cur = ub_offset + num_zr*max_r*srcm1*cp_align_len
            res_offset_cur = res_offset + num_zr*max_r*dstm1*cp_align_len
            tvm_ib.emit(
                tvm.call_extern(
                    data_res.dtype, "vadds",
                    data_res.access_ptr("w", offset=res_offset_cur),
                    data_ub.access_ptr('r', offset=ub_offset_cur),
                    0, max_r, dstm0, srcm0, dstm1, srcm1))
        with tvm_ib.if_scope(mod_repeat > 0):
            ub_offset_cur = ub_offset + zu_repeat*max_r*srcm1*cp_align_len
            res_offset_cur = res_offset + zu_repeat*max_r*dstm1*cp_align_len
            with tvm_ib.if_scope(mod_repeat == 1):
                tvm_ib.emit(
                    tvm.call_extern(
                        data_res.dtype, "vadds",
                        data_res.access_ptr("w", offset=res_offset_cur),
                        data_ub.access_ptr('r', offset=ub_offset_cur),
                        0, mod_repeat, dstm0, srcm0, 0, 0))
            with tvm_ib.else_scope():
                tvm_ib.emit(
                    tvm.call_extern(
                        data_res.dtype, "vadds",
                        data_res.access_ptr("w", offset=res_offset_cur),
                        data_ub.access_ptr('r', offset=ub_offset_cur),
                        0, mod_repeat, dstm0, srcm0, dstm1, srcm1))


def _func_two_row_align_split_row_fp16_new(args):
    """
    function of moving data for row align split row fp16 new scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = num_row_len_ub * 16
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len \
                          + num_c * row_len + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * row_len_ub
        dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(col_len <= 31):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                add_zu = row_len_ub // 8
                add_mod = row_len_ub % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_c * 16 * row_len_ub
                    ub_offset = num_c * 16
                    repeat = add_zu
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 8
                    dstm1 = dstm0 * 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_c * 16 * row_len_ub + add_zu * 8 * 16
                    ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                    repeat = 1
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                res_offset = num_c * 16 * row_len_ub
                ub_offset = num_c * 16
                n_burst = row_len_ub
                burst_len = 1
                src_stride = 0
                dst_stride = col_len - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len \
                     + num_u * row_len_ub * col_len
        burst_len_dst = col_len * row_len_ub // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(ub_mod > 0):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len \
                          + num_c * row_len + ub_loop * row_len_ub
            ub_offset = num_c * ub_mod
            burst_len_data = ub_mod // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * ub_mod
        dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(col_len <= 31):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                add_zu = ub_mod // 8
                add_mod = ub_mod % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_c * 16 * ub_mod
                    ub_offset = num_c * 16
                    repeat = add_zu
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 8
                    dstm1 = dstm0 * 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_c * 16 * ub_mod + add_zu * 8 * 16
                    ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                    repeat = 1
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                res_offset = num_c * 16 * ub_mod
                ub_offset = num_c * 16
                n_burst = ub_mod
                burst_len = 1
                src_stride = 0
                dst_stride = col_len - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len \
                     + ub_loop * row_len_ub * col_len
        burst_len_dst = col_len * ub_mod // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_row_align_split_row_fp16_new(dst, data):
    """
    function of making ir node builder for row align split row fp16 new scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_split_row_fp16_new(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_split_row_fp16_new(args)

    return tvm_ib.get()


def _move_for_row_align_split_row_fp16_new_fencore(args):
    """
    function of moving data for row align split row fp16 new fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    cp_align_len, float_size, ub_ele, col_len, row_len, n_index,\
    row_len_ub, row_len_begin, row_len_now = args

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len \
                      + num_c * row_len + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    dim_ele = col_len * row_len_now
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(col_len <= 31):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            add_zu = row_len_now // 8
            add_mod = row_len_now % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_c * 16 * row_len_now
                ub_offset = num_c * 16
                repeat = add_zu
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 8
                dstm1 = dstm0 * 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_c * 16 * row_len_now + add_zu * 8 * 16
                ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                repeat = 1
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            res_offset = num_c * 16 * row_len_now
            ub_offset = num_c * 16
            n_burst = row_len_now
            burst_len = 1
            src_stride = 0
            dst_stride = col_len - 1
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len \
                 + row_len_begin * col_len
    burst_len_dst = col_len * row_len_now // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_row_align_split_row_fp16_new_fencore_nomod(args):
    """
    function for row align split row fp16 new fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, cp_align_len, float_size, ub_ele, \
           col_len, row_len, n_index, row_len_ub, \
           row_len_begin, row_len_now
    _move_for_row_align_split_row_fp16_new_fencore(args)


def _func_two_row_align_split_row_fp16_new_fencore_mod(args):
    """
    function for row align split row fp16 new fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, cp_align_len, float_size, ub_ele,\
               col_len, row_len, n_index, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_row_align_split_row_fp16_new_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = ub_mod
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, cp_align_len, float_size, ub_ele, \
               col_len, row_len, n_index, row_len_ub, \
               row_len_begin, row_len_now
        _move_for_row_align_split_row_fp16_new_fencore(args)


def _two_row_align_split_row_fp16_new_fencore(dst, data):
    """
    function of making ir node builder
    for row align split row fp16 new fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = num_row_len_ub * 16
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_row_fp16_new_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_row_fp16_new_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_row_fp16_new_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_row_fp16_new_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_row_align_split_col_fp16(args):
    """
    function of moving data for row align split col fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    col_len_ub = (ub_ele // row_len // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = (col_len_ub * row_len) // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        c_zu = col_len_ub // 16
        r_zu = row_len // 16
        with tvm_ib.if_scope(row_len >= col_len_ub):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_ub * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, row_len, name="num_rl") as num_rl:
            dst_offset = n_index * col_len * row_len\
                         + num_rl * col_len + num_u * col_len_ub
            res_offset = num_rl * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r",
                                            offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_mod_begin = col_len - ub_mod_align

        data_offset = n_index * col_len * row_len\
                      + col_len_mod_begin * row_len
        burst_len_data = (ub_mod_align * row_len) // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        c_zu = ub_mod_align // 16
        r_zu = row_len // 16
        with tvm_ib.if_scope(row_len >= ub_mod_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_mod_align * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, row_len, name="num_rl") as num_rl:
            dst_offset = n_index * col_len * row_len\
                         + num_rl * col_len + col_len_mod_begin
            res_offset = num_rl * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r",
                                            offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _two_row_align_split_col_fp16(dst, data):
    """
    function of making ir node builder for row align split col fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_split_col_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_split_col_fp16(args)

    return tvm_ib.get()


def _move_for_row_align_split_col_fp16_fencore(args):
    """
    function of moving data for row align split col fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    ub_ele, cp_align_len, float_size, col_len, row_len, n_index,\
    col_len_ub, col_len_begin, col_len_now = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = (col_len_now * row_len) // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len // 16
    with tvm_ib.if_scope(row_len >= col_len_now):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, row_len, name="num_rl") as num_rl:
        dst_offset = n_index * col_len * row_len \
                     + num_rl * col_len + col_len_begin
        res_offset = num_rl * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_row_align_split_col_fp16_fencore_nomod(args):
    """
    function for row align split col fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)


    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, cp_align_len, float_size, \
           col_len, row_len, n_index, col_len_ub, \
           col_len_begin, col_len_now
    _move_for_row_align_split_col_fp16_fencore(args)


def _func_two_row_align_split_col_fp16_fencore_mod(args):
    """
    function for row align split col fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, cp_align_len, float_size,\
               col_len, row_len, n_index, col_len_ub,\
               col_len_begin, col_len_now
        _move_for_row_align_split_col_fp16_fencore(args)

    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_now = ub_mod_align
        col_len_begin = col_len - ub_mod_align
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, cp_align_len, float_size, \
               col_len, row_len, n_index, col_len_ub, \
               col_len_begin, col_len_now
        _move_for_row_align_split_col_fp16_fencore(args)


def _two_row_align_split_col_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for row align split col fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    col_len_ub = (ub_ele // row_len // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_col_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_col_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_row_align_split_col_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_row_align_split_col_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_row_align_large_fp16(args):
    """
    function of moving data for row align large fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:

            data_offset = n_index * col_len * row_len\
                          + num_u * ub_col * row_len + num_rowz * row_ub
            n_burst = ub_col
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
                dst_offset = n_index * col_len * row_len\
                             + (num_rowz * row_ub + num_ru) * col_len\
                             + num_u * ub_col
                res_offset = num_ru * ub_col
                burst_len_dst = ub_col // cp_align_len
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))

        with tvm_ib.if_scope(ub_col_mod > 0):
            ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
            col_mod_begin = col_len - ub_col_mod_align

            data_offset = n_index * col_len * row_len \
                          + col_mod_begin * row_len + num_rowz * row_ub
            n_burst = ub_col_mod
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col_mod_align // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col_mod_align * 16)\
                            * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
                dst_offset = n_index * col_len * row_len \
                             + (num_rowz * row_ub + num_ru) * col_len \
                             + col_mod_begin
                res_offset = num_ru * ub_col_mod_align
                burst_len_dst = ub_col_mod_align // cp_align_len
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))


def _two_row_align_large_fp16(dst, data):
    """
    function of making ir node builder for row align large fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_row_align_large_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_row_align_large_fp16(args)

    return tvm_ib.get()


def _func_two_row_align_large_fp16_fencore(args):
    """
    function of moving data for row align large fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
            data_offset = n_index * col_len * row_len\
                          + num_u * ub_col * row_len + num_rowz * row_ub
            n_burst = ub_col
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin,\
                       two_begin, repeat_vconv, src_stride_vconv,\
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
                dst_offset = n_index * col_len * row_len\
                             + (num_rowz * row_ub + num_ru) * col_len\
                             + num_u * ub_col
                res_offset = num_ru * ub_col
                burst_len_dst = ub_col // cp_align_len
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))

        with tvm_ib.if_scope(ub_col_mod > 0):
            ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
            col_mod_begin = col_len - ub_col_mod_align

            data_offset = n_index * col_len * row_len \
                          + col_mod_begin * row_len + num_rowz * row_ub
            n_burst = ub_col_mod
            burst_len_data = row_ub // cp_align_len
            src_stride = (row_len - row_ub) // cp_align_len
            args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
                   burst_len_data, src_stride, 0, cp_align_len
            _func_gm_to_ub_align(args)

            c_zu = ub_col_mod_align // 16
            r_zu = row_ub // 16
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_col_mod_align * 16)\
                            * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

            with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
                dst_offset = n_index * col_len * row_len \
                             + (num_rowz * row_ub + num_ru) * col_len \
                             + col_mod_begin
                res_offset = num_ru * ub_col_mod_align
                burst_len_dst = ub_col_mod_align // cp_align_len
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))


def _move_for_row_align_large_fp16_fencore(args):
    """
    function of moving data for row align large fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
    row_len, n_index, row_index, row_ub, col_len_now, col_len_begin = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len + row_index * row_ub
    n_burst = col_len_now
    burst_len_data = row_ub // cp_align_len
    src_stride = (row_len - row_ub) // cp_align_len
    args = tvm_ib, data, data_ub, data_offset, 0, n_burst, \
           burst_len_data, src_stride, 0, cp_align_len
    _func_gm_to_ub_align(args)

    c_zu = col_len_now // 16
    r_zu = row_ub // 16
    with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
        one_begin = (num_rz * 16) * float_size
        two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
        repeat_vconv = c_zu
        src_stride_vconv = 16 * r_zu
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, \
               two_begin, repeat_vconv, src_stride_vconv, \
               dst_stride_vconv, r_zu, c_zu
        _vconv_one(args)

    with tvm_ib.for_range(0, row_ub, name="num_ru") as num_ru:
        dst_offset = n_index * col_len * row_len \
                     + (row_index * row_ub + num_ru) * col_len \
                     + col_len_begin
        res_offset = num_ru * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r",
                                                        offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_row_align_large_fp16_fencore_nomod(args):
    """
    function for row align large fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_zu, \
    row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = ub_col
    col_len_begin = col_index * ub_col
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
           row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
    _move_for_row_align_large_fp16_fencore(args)


def _func_two_row_align_large_fp16_fencore_mod(args):
    """
    function of moving data for row align large fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_zu, \
    row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(col_index < col_fen - 1):
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len,\
               row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
        _move_for_row_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
        col_len_now = ub_col_mod_align
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, col_len_now, col_len_begin
        _move_for_row_align_large_fp16_fencore(args)


def _two_row_align_large_fp16_fencore(dst, data):
    """
    function of making ir node builder for row align large fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    row_zu = row_len // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    with tvm_ib.if_scope(ub_col_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
            _func_two_row_align_large_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, row_zu, \
                       row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, \
                       group_index
                _func_two_row_align_large_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_zu, \
                   row_ub, fen_n, ub_loop, ub_col, ub_col_mod, col_fen, num_g
            _func_two_row_align_large_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, row_zu, \
                       row_ub, fen_n, ub_loop, ub_col, ub_col_mod, \
                       col_fen, group_index
                _func_two_row_align_large_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _vconv_one_not_align(args):
    """
    function of vnchwconv for one _func_vconv_fp16

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
    repeat_vconv, src_stride_vconv, dst_stride_vconv, r_zu = args

    src0_offset = 8 * 0
    src1_offset = 8 * 1
    dst0_offset = 8 * 2
    dst1_offset = 8 * 3
    src_gap = 32 * r_zu
    src_eight_gap = src_gap * 8
    dst_gap = 32
    dst_eight_gap = dst_gap * 8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))
    with tvm_ib.if_scope(repeat_vconv == 1):
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    1,
                                    0,
                                    0))
    with tvm_ib.else_scope():
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    repeat_vconv,
                                    dst_stride_vconv,
                                    src_stride_vconv))


def _vconv_two_not_align(args):
    """
    function of vnchwconv for two _func_vconv_fp16

    """
    tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
    repeat_vconv, src_stride_vconv, dst_stride_vconv = args

    src0_offset = 8 * 0
    src1_offset = 8 * 1
    dst0_offset = 8 * 2
    dst1_offset = 8 * 3
    src_gap = 32
    src_eight_gap = src_gap * 8
    dst_gap = 32
    dst_eight_gap = dst_gap * 8

    with tvm_ib.for_range(0, 8, name="i") as i:
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src0_offset + i]),
                                    one_begin + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        src1_offset + i]),
                                    one_begin + src_eight_gap
                                    + i * src_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst0_offset + i]),
                                    two_begin + i * dst_gap))
        tvm_ib.emit(tvm.call_extern("uint64", "reg_mov",
                                    tvm.call_extern(addr_array.dtype, "reg",
                                                    addr_array[
                                                        dst1_offset + i]),
                                    two_begin + dst_eight_gap
                                    + i * dst_gap))

    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA0",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA1",
                                addr_array_buf.access_ptr("rw",
                                                          offset=src1_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA2",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst0_offset)))
    tvm_ib.emit(tvm.call_extern("int32",
                                "set_va_reg_sb",
                                "VA3",
                                addr_array_buf.access_ptr("rw",
                                                          offset=dst1_offset)))
    with tvm_ib.if_scope(repeat_vconv == 1):
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    1,
                                    0,
                                    0))
    with tvm_ib.else_scope():
        tvm_ib.emit(tvm.call_extern("int32",
                                    "scatter_vnchwconv_b16",
                                    "VA2",
                                    "VA0",
                                    repeat_vconv,
                                    dst_stride_vconv,
                                    src_stride_vconv))


def _func_two_not_align_small_fp16(args):
    """
    function of moving data for not align small fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(row_len <= 31):
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            add_zu = col_len // 8
            add_mod = col_len % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len
                repeat = add_zu
                srcm0 = row_len
                dstm0 = 1
                srcm1 = srcm0 * 8
                dstm1 = 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                ub_offset = num_r * 16 * col_len + add_zu * 8 * 16
                repeat = 1
                srcm0 = row_len
                dstm0 = 1
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len
            n_burst = col_len
            burst_len = 1
            src_stride = row_len - 1
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(dim_ele % cp_align_len > 0):
        dim_ele_sub = dim_ele - cp_align_len
        dst_offset = n_index * col_len * row_len
        burst_len = _ceil_div(dim_ele_sub, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=dim_ele_sub + num_a)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr('w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + dim_ele_sub),
                                    data_tail.access_ptr("r", offset=0),
                                    0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = n_index * col_len * row_len
        burst_len_dst = dim_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_not_align_small_fp16(dst, data):
    """
    function of making ir node builder for not align small fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_small_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_small_fp16(args)

    return tvm_ib.get()


def _func_two_not_align_small_multidim_fp16(args):
    """
    function of moving data for not align small multidim fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    addr_array, addr_array_buf, device_core_num, block_index,\
    cp_align_len, float_size, ub_ele, num_dim_ub, num_g, num_dim_cur = args

    n_i, col_len, row_len = data.shape
    n_index = num_g * device_core_num + block_index

    cur_ele = num_dim_cur * col_len * row_len
    data_offset = n_index * num_dim_ub * col_len * row_len
    burst_len_data = _ceil_div(cur_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    cur_ele_align = _ceil_fill(cur_ele, 16)
    cur_ele_div = cur_ele_align // 16
    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = cur_ele_div
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, num_dim_cur, name="num_d") as num_d:
        with tvm_ib.for_range(0, col_len, name="num_cl") as num_cl:
            res_offset = num_d * col_len * row_len * cp_align_len\
                         + num_cl * row_len * cp_align_len
            ub_offset = num_d * col_len * row_len * cp_align_len\
                        + num_cl * cp_align_len
            n_burst = row_len
            burst_len = 1
            dst_stride = col_len - 1
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                0, dst_stride))

    cur_ele_align = _ceil_fill(cur_ele, 16)
    cur_ele_div = cur_ele_align // 16
    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = cur_ele_div
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(cur_ele % cp_align_len > 0):
        with tvm_ib.if_scope(cur_ele > cp_align_len):
            move_len = cur_ele - cp_align_len
            dst_offset = n_index * num_dim_ub * col_len * row_len
            burst_len = _ceil_div(move_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=move_len + num_a)
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr('w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=(dst_offset + move_len)),
                                        data_tail.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = n_index * num_dim_ub * col_len * row_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        dst_offset = n_index * num_dim_ub * col_len * row_len
        burst_len = cur_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len, 0, 0))


def _two_not_align_small_multidim_fp16(dst, data):
    """
    function of making ir node builder for not align small multidim fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    dim_ele = _ceil_fill(col_len * row_len, 16) * 16
    num_dim_ub = ub_ele // dim_ele
    core_full = n_i // num_dim_ub
    num_dim_mod = n_i % num_dim_ub

    group_index = core_full // device_core_num
    group_mod = core_full % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, device_core_num, block_index,\
               cp_align_len, float_size, ub_ele, num_dim_ub, num_g, num_dim_ub
        _func_two_not_align_small_multidim_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, device_core_num, block_index, \
                   cp_align_len, float_size, ub_ele, num_dim_ub,\
                   group_index, num_dim_ub
            _func_two_not_align_small_multidim_fp16(args)

    with tvm_ib.if_scope(num_dim_mod > 0):
        core_mod = core_full
        core_group = core_mod // device_core_num
        core_block = core_mod % device_core_num

        with tvm_ib.if_scope(tvm.all(block_index > (core_block - 1),
                                     block_index < (core_block + 1))):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, device_core_num, block_index, \
                   cp_align_len, float_size, ub_ele, num_dim_ub, \
                   core_group, num_dim_mod
            _func_two_not_align_small_multidim_fp16(args)

    return tvm_ib.get()


def _func_two_not_align_split_row_fp16_new(args):
    """
    function of moving data for not align split row fp16 new scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = 16 * num_row_len_ub

    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * row_len_ub
        dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(col_len <= 31):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                add_zu = row_len_ub // 8
                add_mod = row_len_ub % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_c * 16 * row_len_ub
                    ub_offset = num_c * 16
                    repeat = add_zu
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 8
                    dstm1 = dstm0 * 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_c * 16 * row_len_ub + add_zu * 8 * 16
                    ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                    repeat = 1
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                res_offset = num_c * 16 * row_len_ub
                ub_offset = num_c * 16
                n_burst = row_len_ub
                burst_len = 1
                src_stride = 0
                dst_stride = col_len - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len \
                     + num_u * row_len_ub * col_len
        burst_len_dst = col_len * row_len_ub // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = row_len - ub_mod_align

        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + ub_mod_begin
            ub_offset = num_c * ub_mod_align
            burst_len_data = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * ub_mod_align
        dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(col_len <= 31):
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                add_zu = ub_mod_align // 8
                add_mod = ub_mod_align % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_c * 16 * ub_mod_align
                    ub_offset = num_c * 16
                    repeat = add_zu
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 8
                    dstm1 = dstm0 * 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_c * 16 * ub_mod_align + add_zu * 8 * 16
                    ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                    repeat = 1
                    srcm0 = 1
                    dstm0 = col_len
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
                res_offset = num_c * 16 * ub_mod_align
                ub_offset = num_c * 16
                n_burst = ub_mod_align
                burst_len = 1
                src_stride = 0
                dst_stride = col_len - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len \
                     + ub_mod_begin * col_len
        burst_len_dst = col_len * ub_mod_align // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_not_align_split_row_fp16_new(dst, data):
    """
    function of making ir node builder for not align split row fp16 new scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_split_row_fp16_new(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_split_row_fp16_new(args)

    return tvm_ib.get()


def _move_for_not_align_split_row_fp16_new_fencore(args):
    """
    function of moving data for not align split row fp16 new fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    float_size, cp_align_len, ub_ele, n_index, col_len,\
    row_len, row_len_ub, row_len_begin, row_len_now = args

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len \
                      + num_c * row_len + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    dim_ele = col_len * row_len_now
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(col_len <= 31):
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            add_zu = row_len_now // 8
            add_mod = row_len_now % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_c * 16 * row_len_now
                ub_offset = num_c * 16
                repeat = add_zu
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 8
                dstm1 = dstm0 * 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_c * 16 * row_len_now + add_zu * 8 * 16
                ub_offset = num_c * 16 + add_zu * 8 * 16 * col_len
                repeat = 1
                srcm0 = 1
                dstm0 = col_len
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            res_offset = num_c * 16 * row_len_now
            ub_offset = num_c * 16
            n_burst = row_len_now
            burst_len = 1
            src_stride = 0
            dst_stride = col_len - 1
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len \
                 + row_len_begin * col_len
    burst_len_dst = col_len * row_len_now // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_split_row_fp16_new_fencore_nomod(args):
    """
    function for not align split row fp16 new fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, \
           n_index, col_len, row_len, row_len_ub, \
           row_len_begin, row_len_now
    _move_for_not_align_split_row_fp16_new_fencore(args)


def _func_two_not_align_split_row_fp16_new_fencore_mod(args):
    """
    function for not align split row fp16 new fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele,\
               n_index, col_len, row_len, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_not_align_split_row_fp16_new_fencore(args)
    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        row_len_now = ub_mod_align
        row_len_begin = row_len - row_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, \
               n_index, col_len, row_len, row_len_ub, \
               row_len_begin, row_len_now
        _move_for_not_align_split_row_fp16_new_fencore(args)


def _two_not_align_split_row_fp16_new_fencore(dst, data):
    """
    function of making ir node builder
    for not align split row fp16 new fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = 16 * num_row_len_ub
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_row_fp16_new_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_row_fp16_new_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_row_fp16_new_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_row_fp16_new_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_not_align_split_row_fp16(args):
    """
    function of moving data for not align split row fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    col_len_align = _ceil_fill(col_len, cp_align_len)

    row_len_ub = (ub_ele // col_len_align // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    n_index = num_g * device_core_num + block_index
    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len_align // 16
        r_zu = row_len_ub // 16
        with tvm_ib.if_scope(row_len_ub >= col_len_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_ub * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.if_scope(ub_mod > 0):
            with tvm_ib.for_range(0, row_len_ub, name="num_rl") as num_rl:
                dst_offset = n_index * col_len * row_len\
                             + (num_u * row_len_ub + num_rl) * col_len
                res_offset = num_rl * col_len_align
                burst_len_dst = _ceil_div(col_len, cp_align_len)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))
        with tvm_ib.else_scope():
            with tvm_ib.if_scope(num_u < ub_loop - 1):
                with tvm_ib.for_range(0, row_len_ub, name="num_rl") as num_rl:
                    dst_offset = n_index * col_len * row_len \
                                 + (num_u * row_len_ub + num_rl) * col_len
                    res_offset = num_rl * col_len_align
                    burst_len_dst = _ceil_div(col_len, cp_align_len)
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset),
                                                data_res.access_ptr(
                                                    "r", offset=res_offset),
                                                0, 1, burst_len_dst, 0, 0))

            with tvm_ib.else_scope():
                with tvm_ib.for_range(0, (row_len_ub - 1), name="num_rl")\
                        as num_rl:
                    dst_offset = n_index * col_len * row_len \
                                 + (num_u * row_len_ub + num_rl) * col_len
                    res_offset = num_rl * col_len_align
                    burst_len_dst = _ceil_div(col_len, cp_align_len)
                    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_offset),
                                                data_res.access_ptr(
                                                    "r", offset=res_offset),
                                                0, 1, burst_len_dst, 0, 0))

                move_len = col_len - cp_align_len
                dst_offset = n_index * col_len * row_len \
                             + (num_u * row_len_ub + row_len_ub - 1) * col_len
                res_offset = (row_len_ub - 1) * col_len_align
                burst_len_dst = _ceil_div(move_len, cp_align_len)
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr('w',
                                                           offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, burst_len_dst, 0, 0))
                with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                    tvm_ib.emit(tvm.call_extern(
                        data_res.dtype, "reg_mov",
                        tvm.call_extern(reg.dtype, "reg", reg[0]),
                        data_res.access_ptr(
                            'r',
                            offset=((row_len_ub - 1) * col_len_align
                                    + move_len + num_a))
                    ))
                    tvm_ib.emit(tvm.call_extern(
                        data_tail.dtype, "reg_mov",
                        data_tail.access_ptr(
                            'w', offset=num_a),
                        tvm.call_extern(reg.dtype, "reg", reg[0])
                    ))
                tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset + move_len),
                                            data_tail.access_ptr(
                                                "r", offset=res_offset),
                                            0, 1, 1, 0, 0))
    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = row_len - ub_mod_align

        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len \
                          + num_c * row_len + ub_mod_begin
            ub_offset = num_c * ub_mod_align
            burst_len_data = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len_align // 16
        r_zu = ub_mod_align // 16
        with tvm_ib.if_scope(ub_mod_align >= col_len_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * ub_mod_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, (ub_mod_align - 1), name="num_rl") as num_rl:
            dst_offset = n_index * col_len * row_len \
                         + (ub_mod_begin + num_rl) * col_len
            res_offset = num_rl * col_len_align
            burst_len_dst = _ceil_div(col_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

        move_len = col_len - cp_align_len
        dst_offset = n_index * col_len * row_len \
                     + (ub_mod_begin + ub_mod_align - 1) * col_len
        res_offset = (ub_mod_align - 1) * col_len_align
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=((ub_mod_align - 1) * col_len_align
                            + move_len + num_a))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + move_len),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))


def _two_not_align_split_row_fp16(dst, data):
    """
    function of making ir node builder for not align split row fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_split_row_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_split_row_fp16(args)

    return tvm_ib.get()


def _move_for_not_align_split_row_fp16_fencore(args):
    """
    function of moving data for not align split row fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, \
    n_index, col_len, row_len, row_len_ub, \
    row_len_begin, row_len_now = args

    col_len_align = _ceil_fill(col_len, cp_align_len)

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len \
                      + num_c * row_len + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_align // 16
    r_zu = row_len_now // 16
    with tvm_ib.if_scope(row_len_now >= col_len_align):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_now * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_align * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, (row_len_now - 1), name="num_rl") as num_rl:
        dst_offset = n_index * col_len * row_len \
                     + (row_len_begin + num_rl) * col_len
        res_offset = num_rl * col_len_align
        burst_len_dst = _ceil_div(col_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))

    move_len = col_len - cp_align_len
    dst_offset = n_index * col_len * row_len \
                 + (row_len_begin + row_len_now - 1) * col_len
    res_offset = (row_len_now - 1) * col_len_align
    burst_len_dst = _ceil_div(move_len, cp_align_len)
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, 1, burst_len_dst, 0, 0))
    with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_res.access_ptr(
                'r', offset=((row_len_now - 1) * col_len_align
                             + move_len + num_a))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_tail.dtype, "reg_mov",
            data_tail.access_ptr(
                'w', offset=num_a),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset + move_len),
                                data_tail.access_ptr(
                                    "r", offset=0),
                                0, 1, 1, 0, 0))


def _func_two_not_align_split_row_fp16_fencore_nomod(args):
    """
    function for not align split row fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
           addr_array, addr_array_buf, float_size, cp_align_len, ub_ele, \
           n_index, col_len, row_len, row_len_ub, \
           row_len_begin, row_len_now
    _move_for_not_align_split_row_fp16_fencore(args)


def _func_two_not_align_split_row_fp16_fencore_mod(args):
    """
    function for not align split row fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, float_size, cp_align_len, ub_ele, \
               n_index, col_len, row_len, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_not_align_split_row_fp16_fencore(args)
    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        row_len_now = ub_mod_align
        row_len_begin = row_len - row_len_now
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, float_size, cp_align_len, ub_ele, \
               n_index, col_len, row_len, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_not_align_split_row_fp16_fencore(args)


def _two_not_align_split_row_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for not align split row fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    col_len_align = _ceil_fill(col_len, cp_align_len)

    row_len_ub = (ub_ele // col_len_align // cp_align_len) * cp_align_len
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_row_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_row_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_row_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_row_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_not_align_split_col_fp16(args):
    """
    function of moving data for not align split col fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    col_len_ub = (ub_ele // row_len_align // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len_ub, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + num_u * col_len_ub * row_len + num_cl * row_len
            ub_offset = num_cl * row_len_align
            burst_len_data = _ceil_div(row_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = col_len_ub // 16
        r_zu = row_len_align // 16
        with tvm_ib.if_scope(row_len_align >= col_len_ub):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * col_len_ub * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + num_r * col_len + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align
        with tvm_ib.for_range(0, ub_mod_align, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + ub_mod_begin * row_len + num_cl * row_len
            ub_offset = num_cl * row_len_align
            burst_len_data = _ceil_div(row_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_mod_align // 16
        r_zu = row_len_align // 16
        with tvm_ib.if_scope(row_len_align >= ub_mod_align):
            with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
                one_begin = (num_cz * row_len_align * 16) * float_size
                two_begin = (ub_ele + num_cz * 16) * float_size
                repeat_vconv = r_zu
                src_stride_vconv = 1
                dst_stride_vconv = 16 * c_zu
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)
        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
                one_begin = (num_rz * 16) * float_size
                two_begin = (ub_ele + num_rz * ub_mod_align * 16) * float_size
                repeat_vconv = c_zu
                src_stride_vconv = 16 * r_zu
                dst_stride_vconv = 1
                args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                       two_begin, repeat_vconv, src_stride_vconv, \
                       dst_stride_vconv, r_zu, c_zu
                _vconv_one(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + num_r * col_len + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _two_not_align_split_col_fp16(dst, data):
    """
    function of making ir node builder for not align split col fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_split_col_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_split_col_fp16(args)

    return tvm_ib.get()


def _move_for_not_align_split_col_fp16_fencore(args):
    """
    function of moving data for not align split col fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
    col_len, row_len, col_len_begin, col_len_now = args

    row_len_align = _ceil_fill(row_len, cp_align_len)

    with tvm_ib.for_range(0, col_len_now, name="num_cl") as num_cl:
        data_offset = n_index * col_len * row_len \
                      + col_len_begin * row_len + num_cl * row_len
        ub_offset = num_cl * row_len_align
        burst_len_data = _ceil_div(row_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len_align // 16
    with tvm_ib.if_scope(row_len_align >= col_len_now):
        with tvm_ib.for_range(0, c_zu, name="num_cz") as num_cz:
            one_begin = (num_cz * row_len_align * 16) * float_size
            two_begin = (ub_ele + num_cz * 16) * float_size
            repeat_vconv = r_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16 * c_zu
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)
    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + num_r * col_len + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_split_col_fp16_fencore_nomod(args):
    """
    function for not align split col fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, col_len_begin, col_len_now
    _move_for_not_align_split_col_fp16_fencore(args)


def _func_two_not_align_split_col_fp16_fencore_mod(args):
    """
    function for not align split col fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index,\
               col_len, row_len, col_len_begin, col_len_now
        _move_for_not_align_split_col_fp16_fencore(args)

    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_now = ub_mod_align
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_not_align_split_col_fp16_fencore(args)


def _two_not_align_split_col_fp16_fencore(dst, data):
    """
    function of making ir node builder
    for not align split col fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    row_len_align = _ceil_fill(row_len, cp_align_len)
    col_len_ub = (ub_ele // row_len_align // cp_align_len) * cp_align_len
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_col_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_col_fp16_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_col_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_col_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_not_align_split_col_fp16_new(args):
    """
    function of moving data for not align split col fp16 new scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = 16 * num_col_len_ub

    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = col_len_ub * row_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele_align = col_len_ub * row_len
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(row_len <= 31):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                add_zu = col_len_ub // 8
                add_mod = col_len_ub % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_r * 16
                    ub_offset = num_r * 16 * col_len_ub
                    repeat = add_zu
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = srcm0 * 8
                    dstm1 = 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                    ub_offset = num_r * 16 * col_len_ub + add_zu * 8 * 16
                    repeat = 1
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len_ub
                n_burst = col_len_ub
                burst_len = 1
                src_stride = row_len - 1
                dst_stride = 0
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + num_r * col_len + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align

        data_offset = n_index * col_len * row_len \
                      + ub_mod_begin * row_len
        burst_len_data = ub_mod_align * row_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele_align = ub_mod_align * row_len
        dim_zu = dim_ele_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(row_len <= 31):
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                add_zu = ub_mod_align // 8
                add_mod = ub_mod_align % 8
                with tvm_ib.if_scope(add_zu > 0):
                    res_offset = num_r * 16
                    ub_offset = num_r * 16 * ub_mod_align
                    repeat = add_zu
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = srcm0 * 8
                    dstm1 = 8
                    mask1, mask2 = _set_mask(128)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)
                with tvm_ib.if_scope(add_mod > 0):
                    res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                    ub_offset = num_r * 16 * ub_mod_align + add_zu * 8 * 16
                    repeat = 1
                    srcm0 = row_len
                    dstm0 = 1
                    srcm1 = 0
                    dstm1 = 0
                    mask_len = add_mod * 16
                    mask1, mask2 = _set_mask(mask_len)
                    tvm_ib.emit(tvm.call_extern(
                        dst.dtype, "set_vector_mask",
                        tvm.const(mask1, dtype="uint64"),
                        tvm.const(mask2, dtype="uint64")))
                    args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                           repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                    _func_vadds(args)

            tvm_ib.emit(tvm.call_extern(
                dst.dtype, "set_vector_mask",
                tvm.const(-1, dtype="uint64"),
                tvm.const(-1, dtype="uint64")))

        with tvm_ib.else_scope():
            with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
                res_offset = num_r * 16
                ub_offset = num_r * 16 * ub_mod_align
                n_burst = ub_mod_align
                burst_len = 1
                src_stride = row_len - 1
                dst_stride = 0
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len \
                         + num_r * col_len + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _two_not_align_split_col_fp16_new(dst, data):
    """
    function of making ir node builder for not align split col fp16 new scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_split_col_fp16_new(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_split_col_fp16_new(args)

    return tvm_ib.get()


def _move_for_not_align_split_col_fp16_new_fencore(args):
    """
    function of moving data for not align split col fp16 new fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
    col_len, row_len, col_len_begin, col_len_now = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = col_len_now * row_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    dim_ele_align = col_len_now * row_len
    dim_zu = dim_ele_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(row_len <= 31):
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            add_zu = col_len_now // 8
            add_mod = col_len_now % 8
            with tvm_ib.if_scope(add_zu > 0):
                res_offset = num_r * 16
                ub_offset = num_r * 16 * col_len_now
                repeat = add_zu
                srcm0 = row_len
                dstm0 = 1
                srcm1 = srcm0 * 8
                dstm1 = 8
                mask1, mask2 = _set_mask(128)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)
            with tvm_ib.if_scope(add_mod > 0):
                res_offset = num_r * 16 + add_zu * 8 * 16 * row_len
                ub_offset = num_r * 16 * col_len_now + add_zu * 8 * 16
                repeat = 1
                srcm0 = row_len
                dstm0 = 1
                srcm1 = 0
                dstm1 = 0
                mask_len = add_mod * 16
                mask1, mask2 = _set_mask(mask_len)
                tvm_ib.emit(tvm.call_extern(
                    dst.dtype, "set_vector_mask",
                    tvm.const(mask1, dtype="uint64"),
                    tvm.const(mask2, dtype="uint64")))
                args = tvm_ib, data_res, data_ub, res_offset, ub_offset, \
                       repeat, srcm0, dstm0, srcm1, dstm1, cp_align_len
                _func_vadds(args)

        tvm_ib.emit(tvm.call_extern(
            dst.dtype, "set_vector_mask",
            tvm.const(-1, dtype="uint64"),
            tvm.const(-1, dtype="uint64")))

    with tvm_ib.else_scope():
        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_now
            n_burst = col_len_now
            burst_len = 1
            src_stride = row_len - 1
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + num_r * col_len + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_split_col_fp16_new_fencore_nomod(args):
    """
    function for not align split col fp16 new fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, col_len_begin, col_len_now
    _move_for_not_align_split_col_fp16_new_fencore(args)


def _func_two_not_align_split_col_fp16_new_fencore_mod(args):
    """
    function for not align split col fp16 new fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index,\
               col_len, row_len, col_len_begin, col_len_now
        _move_for_not_align_split_col_fp16_new_fencore(args)

    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_now = ub_mod_align
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_not_align_split_col_fp16_new_fencore(args)


def _two_not_align_split_col_fp16_new_fencore(dst, data):
    """
    function of making ir node builder
    for not align split col fp16 new fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = 16 * num_col_len_ub

    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_col_fp16_new_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_col_fp16_new_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_not_align_split_col_fp16_new_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_not_align_split_col_fp16_new_fencore_nomod(args)

    return tvm_ib.get()


def _move_data_large_not_align(args):
    """
    function of moving data for not align large scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, addr_array_buf,\
    cp_align_len, col_len, row_len, ub_ele, float_size, row_ub, ub_loop,\
    ub_col, ub_col_mod, n_index, num_rowz, row_len_now = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, ub_col, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (num_u * ub_col + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + (num_rowz * row_ub + num_r) * col_len\
                         + num_u * ub_col
            res_offset = num_r * ub_col
            burst_len_dst = ub_col // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_col_mod > 0):
        ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
        ub_col_mod_begin = col_len - ub_col_mod_align

        with tvm_ib.for_range(0, ub_col_mod_align, name="num_uc") as num_uc:
            data_offset = n_index * col_len * row_len\
                          + (ub_col_mod_begin + num_uc) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_uc * row_len_now_align
            burst_len_data = _ceil_div(row_len_now, cp_align_len)
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr("w",
                                                           offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        c_zu = ub_col_mod_align // 16
        r_zu = row_len_now_align // 16
        with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
            one_begin = (num_rz * 16) * float_size
            two_begin = (ub_ele + num_rz * ub_col_mod_align * 16) * float_size
            repeat_vconv = c_zu
            src_stride_vconv = 16 * r_zu
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, \
                   two_begin, repeat_vconv, src_stride_vconv, \
                   dst_stride_vconv, r_zu, c_zu
            _vconv_one(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + (num_rowz * row_ub + num_r) * col_len\
                         + ub_col_mod_begin
            res_offset = num_r * ub_col_mod_align
            burst_len_dst = ub_col_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_large_fp16(args):
    """
    function for not align large fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_len_align = _ceil_fill(row_len, cp_align_len)

    row_zu = row_len_align // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.if_scope(num_rowz < (row_zu - 1)):
            row_len_now = row_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
                   addr_array_buf, cp_align_len, col_len, row_len, ub_ele,\
                   float_size, row_ub, ub_loop, ub_col, ub_col_mod, n_index,\
                   num_rowz, row_len_now
            _move_data_large_not_align(args)

        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, cp_align_len, col_len, row_len, ub_ele, \
                   float_size, row_ub, ub_loop, ub_col, ub_col_mod, n_index, \
                   num_rowz, row_len_now
            _move_data_large_not_align(args)


def _two_not_align_large_fp16(dst, data):
    """
    function of making ir node builder for not align large fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_not_align_large_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_not_align_large_fp16(args)

    return tvm_ib.get()


def _move_for_not_align_large_fp16_fencore(args):
    """
    function of moving data for not align large fp16 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
    row_len, n_index, row_index, row_ub, \
    row_len_now, col_len_now, col_len_begin = args

    row_len_now_align = _ceil_fill(row_len_now, cp_align_len)

    with tvm_ib.for_range(0, col_len_now, name="num_uc") as num_uc:
        data_offset = n_index * col_len * row_len \
                      + (col_len_begin + num_uc) * row_len \
                      + row_index * row_ub
        ub_offset = num_uc * row_len_now_align
        burst_len_data = _ceil_div(row_len_now, cp_align_len)
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w",
                                                       offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    c_zu = col_len_now // 16
    r_zu = row_len_now_align // 16
    with tvm_ib.for_range(0, r_zu, name="num_rz") as num_rz:
        one_begin = (num_rz * 16) * float_size
        two_begin = (ub_ele + num_rz * col_len_now * 16) * float_size
        repeat_vconv = c_zu
        src_stride_vconv = 16 * r_zu
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, \
               two_begin, repeat_vconv, src_stride_vconv, \
               dst_stride_vconv, r_zu, c_zu
        _vconv_one(args)

    with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + (row_index * row_ub + num_r) * col_len + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_not_align_large_fp16_fencore_nomod(args):
    """
    function for not align large fp16 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, \
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        row_len_now = row_ub
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_not_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = row_len - (row_zu - 1) * row_ub
        col_len_now = ub_col
        col_len_begin = col_index * ub_col
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_not_align_large_fp16_fencore(args)


def _func_two_not_align_large_fp16_fencore_mod(args):
    """
    function for not align large fp16 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, \
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_ub
            col_len_now = ub_col
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_not_align_large_fp16_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_ub
            ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
            col_len_now = ub_col_mod_align
            col_len_begin = col_len - col_len_now
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_not_align_large_fp16_fencore(args)
    with tvm_ib.else_scope():
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_len - (row_zu - 1) * row_ub
            col_len_now = ub_col
            col_len_begin = col_index * ub_col
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_not_align_large_fp16_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            ub_col_mod_align = _ceil_fill(ub_col_mod, cp_align_len)
            col_len_now = ub_col_mod_align
            col_len_begin = col_len - col_len_now
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_not_align_large_fp16_fencore(args)


def _two_not_align_large_fp16_fencore(dst, data):
    """
    function of making ir node builder for not align large fp16 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    row_len_align = _ceil_fill(row_len, cp_align_len)

    row_zu = row_len_align // 16
    col_16_ele = col_len * 16
    ub_loop = col_16_ele // ub_ele
    ub_mod = col_16_ele % ub_ele
    ub_col = ub_ele // 16
    row_ub = 16
    ub_col_mod = ub_mod // 16

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_col_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, num_g
            _func_two_not_align_large_fp16_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen, \
                       ub_col, ub_col_mod, group_index
                _func_two_not_align_large_fp16_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, ub_col, ub_col_mod, num_g
            _func_two_not_align_large_fp16_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen, \
                       ub_col, ub_col_mod, group_index
                _func_two_not_align_large_fp16_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_not_align_little_fp16(args):
    """
    function of moving data for not align little fp16 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g, num_dim_one_core, num_dim_cur_core = args

    n_i, col_len, row_len = data.shape
    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    num_dim_one_group = num_dim_one_core * device_core_num
    num_dim_before_core = num_g * num_dim_one_group\
                          + block_index * num_dim_one_core
    dim_ele = col_len * row_len
    cur_dim_ele = dim_ele * num_dim_cur_core
    cur_dim_ele_align = _ceil_fill(cur_dim_ele, cp_align_len)
    cur_core_ele = num_dim_cur_core * dim_ele

    data_offset = num_dim_before_core * dim_ele
    burst_len_data = _ceil_div(cur_core_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    d_zu = cur_dim_ele_align // 16
    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = d_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, dim_ele, name="num_e") as num_e:
        res_offset = num_e * 16
        row_index = num_e // row_len
        col_index = num_e % row_len
        ub_offset = (col_index * col_len + row_index) * 16
        n_burst = num_dim_cur_core
        burst_len = 1
        src_stride = dim_ele - 1
        dst_stride = dim_ele - 1
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = d_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(cur_core_ele % cp_align_len > 0):
        with tvm_ib.if_scope(cur_core_ele > cp_align_len):
            cur_core_ele_align = cur_core_ele - cp_align_len

            dst_offset = num_dim_before_core * dim_ele
            burst_len_dst = _ceil_div(cur_core_ele_align, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r', offset=cur_core_ele_align + num_a)
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr(
                        'w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(
                tvm.call_extern(
                    dst.dtype, "copy_ubuf_to_gm",
                    dst.access_ptr(
                        'w',
                        offset=dst_offset + cur_core_ele_align),
                    data_tail.access_ptr("r", offset=0),
                    0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            dst_offset = num_dim_before_core * dim_ele
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = num_dim_before_core * dim_ele
        burst_len_dst = cur_core_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_not_align_little_fp16(dst, data):
    """
    function of making ir node builder for not align little fp16 scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    n_i, col_len, row_len = data.shape

    dim_ele = col_len * row_len
    dim_ele_align = _ceil_fill(dim_ele, cp_align_len)

    num_dim_one_core = ub_ele // 16 // dim_ele_align
    num_dim_one_group = num_dim_one_core * device_core_num

    group_index = n_i // num_dim_one_group
    group_mod = n_i % num_dim_one_group

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g,\
               num_dim_one_core, num_dim_one_core
        _func_two_not_align_little_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        num_core = group_mod // num_dim_one_core
        num_dim_mod = group_mod % num_dim_one_core
        with tvm_ib.if_scope(num_core > 0):
            with tvm_ib.if_scope(block_index < num_core):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       group_index, num_dim_one_core, num_dim_one_core
                _func_two_not_align_little_fp16(args)
        with tvm_ib.if_scope(num_dim_mod > 0):
            with tvm_ib.if_scope(tvm.all(block_index > (num_core - 1),
                                         block_index < (num_core + 1))):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       group_index, num_dim_one_core, num_dim_mod
                _func_two_not_align_little_fp16(args)

    return tvm_ib.get()


def _func_two_small_fp32(args):
    """
    function of moving data for two small fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    dim_ele = col_len * row_len
    dim_ele_two = dim_ele * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    dim_zu = dim_ele_two_align // 16

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    data_offset = n_index * col_len * row_len
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        res_offset = num_r * 16
        ub_offset = num_r * 16 * col_len
        n_burst = col_len
        burst_len = 2
        src_stride = row_len * 2 - 2
        dst_stride = 0
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(dim_ele % cp_align_len > 0):
        dim_ele_sub = dim_ele - cp_align_len
        dst_offset = n_index * col_len * row_len
        burst_len = _ceil_div(dim_ele_sub, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=dim_ele_sub + num_a)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr('w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + dim_ele_sub),
                                    data_tail.access_ptr("r", offset=0),
                                    0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = n_index * col_len * row_len
        burst_len_dst = dim_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_small_fp32(dst, data):
    """
    function of making ir node builder for two small fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_small_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_small_fp32(args)

    return tvm_ib.get()


def _func_two_little_fp32(args):
    """
    function of moving data for two little fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g, num_dim_one_core, num_dim_cur_core = args

    n_i, col_len, row_len = data.shape
    dim_ele = col_len * row_len
    dim_ele_two = dim_ele * 2

    mov_ele = col_len * row_len * num_dim_cur_core
    mov_ele_two = mov_ele * 2
    mov_ele_two_align = _ceil_fill(mov_ele_two, 16)
    dim_zu = mov_ele_two_align // 16

    num_dim_one_group = num_dim_one_core * device_core_num
    num_dim_before_core = num_g * num_dim_one_group\
                          + block_index * num_dim_one_core
    data_offset = num_dim_before_core * dim_ele
    burst_len_data = _ceil_div(num_dim_cur_core * dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, dim_ele, name="num_de") as num_de:
        col_index = num_de // row_len
        row_index = num_de % row_len
        new_index = row_index * col_len + col_index

        res_offset = num_de * 16
        ub_offset = new_index * 16
        n_burst = num_dim_cur_core
        burst_len = 2
        src_stride = dim_ele_two - 2
        dst_stride = dim_ele_two - 2
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    core_ele = dim_ele * num_dim_cur_core
    with tvm_ib.if_scope(core_ele % cp_align_len > 0):
        with tvm_ib.if_scope(core_ele > cp_align_len):
            core_ele_align = core_ele - cp_align_len
            dst_offset = num_dim_before_core * dim_ele
            burst_len = _ceil_div(core_ele_align, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=core_ele_align + num_a)
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr('w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(
                tvm.call_extern(
                    dst.dtype, "copy_ubuf_to_gm",
                    dst.access_ptr(
                        'w',
                        offset=dst_offset + core_ele_align),
                    data_tail.access_ptr("r", offset=0),
                    0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = num_dim_before_core * dim_ele
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        dst_offset = num_dim_before_core * dim_ele
        burst_len = core_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len, 0, 0))


def _two_little_fp32(dst, data):
    """
    function of making ir node builder for two little fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape
    dim_space = col_len * row_len * 2 * 8

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    num_dim_one_core = ub_ele // dim_space
    num_dim_one_group = num_dim_one_core * device_core_num
    group_index = n_i // num_dim_one_group
    group_mod = n_i % num_dim_one_group

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len,\
               num_g, num_dim_one_core, num_dim_one_core
        _func_two_little_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        num_core = group_mod // num_dim_one_core
        num_dim_mod = group_mod % num_dim_one_core
        with tvm_ib.if_scope(num_core > 0):
            with tvm_ib.if_scope(block_index < num_core):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       group_index, num_dim_one_core, num_dim_one_core
                _func_two_little_fp32(args)
        with tvm_ib.if_scope(num_dim_mod > 0):
            with tvm_ib.if_scope(tvm.all(block_index > (num_core - 1),
                                         block_index < (num_core + 1))):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       group_index, num_dim_one_core, num_dim_mod
                _func_two_little_fp32(args)

    return tvm_ib.get()


def _func_two_split_row_fp32(args):
    """
    function of moving data for two split row fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_row = col_len * 8 * 2 * 8
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = num_row_len_ub * 8

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + num_u * row_len_ub
            ub_offset = num_c * row_len_ub
            burst_len_data = row_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * row_len_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len
            n_burst = col_len
            burst_len = 2
            src_stride = row_len_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len\
                     + num_u * row_len_ub * col_len
        burst_len_dst = row_len_ub * col_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = row_len - ub_mod_align

        with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
            data_offset = n_index * col_len * row_len\
                          + num_c * row_len + ub_mod_begin
            ub_offset = num_c * ub_mod_align
            burst_len_data = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len * ub_mod_align
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, ub_mod_align, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len
            n_burst = col_len
            burst_len = 2
            src_stride = ub_mod_align * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * col_len * row_len + ub_mod_begin * col_len
        burst_len_dst = ub_mod_align * col_len // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _two_split_row_fp32(dst, data):
    """
    function of making ir node builder for two split row fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_split_row_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_split_row_fp32(args)

    return tvm_ib.get()


def _move_for_two_split_row_fp32_fencore(args):
    """
    function of moving data for two split row fp32 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, \
    n_index, col_len, row_len, row_len_ub, \
    row_len_begin, row_len_now = args

    with tvm_ib.for_range(0, col_len, name="num_c") as num_c:
        data_offset = n_index * col_len * row_len \
                      + num_c * row_len + row_len_begin
        ub_offset = num_c * row_len_now
        burst_len_data = row_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    dim_ele = col_len * row_len_now
    dim_ele_two = dim_ele * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    dim_zu = dim_ele_two_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
        res_offset = num_r * 16
        ub_offset = num_r * 16 * col_len
        n_burst = col_len
        burst_len = 2
        src_stride = row_len_now * 2 - 2
        dst_stride = 0
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    dst_offset = n_index * col_len * row_len + row_len_begin * col_len
    burst_len_dst = row_len_now * col_len // cp_align_len
    tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                dst.access_ptr('w',
                                               offset=dst_offset),
                                data_res.access_ptr("r", offset=0),
                                0, 1, burst_len_dst, 0, 0))


def _func_two_split_row_fp32_fencore_nomod(args):
    """
    function for two split row fp32 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    row_len_now = row_len_ub
    row_len_begin = fen_index * row_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, \
           n_index, col_len, row_len, row_len_ub, \
           row_len_begin, row_len_now
    _move_for_two_split_row_fp32_fencore(args)


def _func_two_split_row_fp32_fencore_mod(args):
    """
    function for two split row fp32 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, row_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        row_len_now = row_len_ub
        row_len_begin = fen_index * row_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array,\
               addr_array_buf, float_size, cp_align_len, ub_ele,\
               n_index, col_len, row_len, row_len_ub,\
               row_len_begin, row_len_now
        _move_for_two_split_row_fp32_fencore(args)
    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        row_len_now = ub_mod_align
        row_len_begin = row_len - row_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, \
               n_index, col_len, row_len, row_len_ub, \
               row_len_begin, row_len_now
        _move_for_two_split_row_fp32_fencore(args)


def _two_split_row_fp32_fencore(dst, data):
    """
    function of making ir node builder for two split row fp32 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape
    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_row = col_len * 8 * 2 * 8
    num_row_len_ub = ub_ele // new_space_ele_split_row
    row_len_ub = num_row_len_ub * 8
    ub_loop = row_len // row_len_ub
    ub_mod = row_len % row_len_ub

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_split_row_fp32_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_split_row_fp32_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, row_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_split_row_fp32_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       row_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_split_row_fp32_fencore_nomod(args)

    return tvm_ib.get()


def _func_two_split_col_fp32(args):
    """
    function of moving data for two split col fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    new_space_ele_split_col = row_len * 8 * 2 * 8
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = num_col_len_ub * 8

    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        data_offset = n_index * col_len * row_len\
                      + num_u * col_len_ub * row_len
        burst_len_data = row_len * col_len_ub // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele = col_len_ub * row_len
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_ub
            n_burst = col_len_ub
            burst_len = 2
            src_stride = row_len * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + num_r * col_len + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align

        data_offset = n_index * col_len * row_len \
                      + ub_mod_begin * row_len
        burst_len_data = row_len * ub_mod_align // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr("w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        dim_ele = ub_mod_align * row_len
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * ub_mod_align
            n_burst = ub_mod_align
            burst_len = 2
            src_stride = row_len * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len \
                         + num_r * col_len + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _two_split_col_fp32(dst, data):
    """
    function of making ir node builder for two split col fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_split_col_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_split_col_fp32(args)

    return tvm_ib.get()


def _move_for_two_split_col_fp32_fencore(args):
    """
    function of moving data for two split col fp32 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
    col_len, row_len, col_len_begin, col_len_now = args

    data_offset = n_index * col_len * row_len \
                  + col_len_begin * row_len
    burst_len_data = row_len * col_len_now // cp_align_len
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr("w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    dim_ele = col_len_now * row_len
    dim_ele_two = dim_ele * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    dim_zu = dim_ele_two_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        res_offset = num_r * 16
        ub_offset = num_r * 16 * col_len_now
        n_burst = col_len_now
        burst_len = 2
        src_stride = row_len * 2 - 2
        dst_stride = 0
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + num_r * col_len + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_split_col_fp32_fencore_nomod(args):
    """
    function for two split col fp32 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    col_len_now = col_len_ub
    col_len_begin = fen_index * col_len_ub
    args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
           addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
           col_len, row_len, col_len_begin, col_len_now
    _move_for_two_split_col_fp32_fencore(args)


def _func_two_split_col_fp32_fencore_mod(args):
    """
    function for two split col fp32 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, col_len_ub, \
    fen_n, ub_loop, ub_mod, num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        col_len_now = col_len_ub
        col_len_begin = fen_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_two_split_col_fp32_fencore(args)

    with tvm_ib.else_scope():
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        col_len_now = ub_mod_align
        col_len_begin = col_len - col_len_now
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, float_size, cp_align_len, ub_ele, n_index, \
               col_len, row_len, col_len_begin, col_len_now
        _move_for_two_split_col_fp32_fencore(args)


def _two_split_col_fp32_fencore(dst, data):
    """
    function of making ir node builder for two split col fp32 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    new_space_ele_split_col = row_len * 8 * 2 * 8
    num_col_len_ub = ub_ele // new_space_ele_split_col
    col_len_ub = num_col_len_ub * 8
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_split_col_fp32_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_split_col_fp32_fencore_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, col_len_ub, \
                   fen_n, ub_loop, ub_mod, num_g
            _func_two_split_col_fp32_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len,\
                       col_len_ub, fen_n, ub_loop, ub_mod, group_index
                _func_two_split_col_fp32_fencore_nomod(args)

    return tvm_ib.get()


def _move_for_large_fp32(args):
    """
    function of moving data for large fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g, col_len_ub, ub_loop, ub_mod, n_index, row_ub,\
    num_rowz, row_len_now = args

    n_i, col_len, row_len = data.shape

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len_ub, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + (num_u * col_len_ub + num_cl) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_cl * row_ub
            burst_len_data = row_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len_ub * row_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_ub
            n_burst = col_len_ub
            burst_len = 2
            src_stride = row_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + (num_rowz * row_ub + num_r) * col_len\
                         + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align

        with tvm_ib.for_range(0, ub_mod_align, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + (ub_mod_begin + num_cl) * row_len \
                          + num_rowz * row_ub
            ub_offset = num_cl * row_ub
            burst_len_data = row_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = ub_mod_align * row_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * ub_mod_align
            n_burst = ub_mod_align
            burst_len = 2
            src_stride = row_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len \
                         + (num_rowz * row_ub + num_r) * col_len \
                         + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _func_two_large_fp32(args):
    """
    function for two large fp32 scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, ub_ele, float_size,\
    device_core_num, block_index, cp_align_len, num_g = args

    n_i, col_len, row_len = data.shape
    row_ub = 8
    col_len_ub = (ub_ele // 16 // 8 // 16) * 16
    n_index = num_g * device_core_num + block_index

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub

    row_len_align = _ceil_fill(row_len, cp_align_len)
    row_zu = row_len_align // cp_align_len

    with tvm_ib.for_range(0, row_zu, name="num_rowz") as num_rowz:
        with tvm_ib.if_scope(num_rowz < (row_zu - 1)):
            row_len_now = row_ub
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, num_g,\
                   col_len_ub, ub_loop, ub_mod, n_index, row_ub,\
                   num_rowz, row_len_now
            _move_for_large_fp32(args)
        with tvm_ib.else_scope():
            row_len_now = row_len - ((row_zu - 1) * row_ub)
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, num_g, \
                   col_len_ub, ub_loop, ub_mod, n_index, row_ub, \
                   num_rowz, row_len_now
            _move_for_large_fp32(args)


def _two_large_fp32(dst, data):
    """
    function of making ir node builder for two large fp32 scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_two_large_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   device_core_num, block_index, cp_align_len, group_index
            _func_two_large_fp32(args)

    return tvm_ib.get()


def _move_for_large_fp32_fencore(args):
    """
    function of moving data for large fp32 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g, col_len_ub, ub_loop, ub_mod, n_index, row_ub,\
    num_rowz, row_len_now = args

    n_i, col_len, row_len = data.shape

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        with tvm_ib.for_range(0, col_len_ub, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + (num_u * col_len_ub + num_cl) * row_len\
                          + num_rowz * row_ub
            ub_offset = num_cl * row_ub
            burst_len_data = row_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = col_len_ub * row_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * col_len_ub
            n_burst = col_len_ub
            burst_len = 2
            src_stride = row_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len\
                         + (num_rowz * row_ub + num_r) * col_len\
                         + num_u * col_len_ub
            res_offset = num_r * col_len_ub
            burst_len_dst = col_len_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))

    with tvm_ib.if_scope(ub_mod > 0):
        ub_mod_align = _ceil_fill(ub_mod, cp_align_len)
        ub_mod_begin = col_len - ub_mod_align

        with tvm_ib.for_range(0, ub_mod_align, name="num_cl") as num_cl:
            data_offset = n_index * col_len * row_len \
                          + (ub_mod_begin + num_cl) * row_len \
                          + num_rowz * row_ub
            ub_offset = num_cl * row_ub
            burst_len_data = row_ub // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        dim_ele = ub_mod_align * row_ub
        dim_ele_two = dim_ele * 2
        dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
        dim_zu = dim_ele_two_align // 16

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
            res_offset = num_r * 16
            ub_offset = num_r * 16 * ub_mod_align
            n_burst = ub_mod_align
            burst_len = 2
            src_stride = row_ub * 2 - 2
            dst_stride = 0
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=ub_offset),
                                data_res.access_ptr(
                                    "r", offset=res_offset),
                                0, n_burst, burst_len,
                                src_stride, dst_stride))

        one_begin = 0
        two_begin = ub_ele * float_size
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
            dst_offset = n_index * col_len * row_len \
                         + (num_rowz * row_ub + num_r) * col_len \
                         + ub_mod_begin
            res_offset = num_r * ub_mod_align
            burst_len_dst = ub_mod_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _move_for_two_large_fp32_fencore(args):
    """
    function of moving data for two large fp32 fencore scene

    """
    tvm_ib, data, dst, data_ub, data_res, addr_array, \
    addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
    row_len, n_index, row_index, row_ub, \
    row_len_now, col_len_now, col_len_begin = args

    with tvm_ib.for_range(0, col_len_now, name="num_cl") as num_cl:
        data_offset = n_index * col_len * row_len \
                      + (col_len_begin + num_cl) * row_len \
                      + row_index * row_ub
        ub_offset = num_cl * row_ub
        burst_len_data = row_ub // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    dim_ele = col_len_now * row_ub
    dim_ele_two = dim_ele * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    dim_zu = dim_ele_two_align // 16

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_ub, name="num_r") as num_r:
        res_offset = num_r * 16
        ub_offset = num_r * 16 * col_len_now
        n_burst = col_len_now
        burst_len = 2
        src_stride = row_ub * 2 - 2
        dst_stride = 0
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr(
                                "w", offset=ub_offset),
                            data_res.access_ptr(
                                "r", offset=res_offset),
                            0, n_burst, burst_len,
                            src_stride, dst_stride))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_zu
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, row_len_now, name="num_r") as num_r:
        dst_offset = n_index * col_len * row_len \
                     + (row_index * row_ub + num_r) * col_len \
                     + col_len_begin
        res_offset = num_r * col_len_now
        burst_len_dst = col_len_now // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, 1, burst_len_dst, 0, 0))


def _func_two_large_fp32_fencore_nomod(args):
    """
    function for two large fp32 fencore nomod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, col_len_ub, ub_mod, \
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        row_len_now = row_ub
        col_len_now = col_len_ub
        col_len_begin = col_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_two_large_fp32_fencore(args)
    with tvm_ib.else_scope():
        row_len_now = row_len - (row_zu - 1) * row_ub
        col_len_now = col_len_ub
        col_len_begin = col_index * col_len_ub
        args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
               addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
               row_len, n_index, row_index, row_ub, \
               row_len_now, col_len_now, col_len_begin
        _move_for_two_large_fp32_fencore(args)


def _func_two_large_fp32_fencore_mod(args):
    """
    function for two large fp32 fencore mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, \
    device_core_num, block_index, cp_align_len, \
    row_ub, row_zu, fen_n, col_fen, col_len_ub, ub_mod, \
    num_g = args

    n_i, col_len, row_len = data.shape
    all_fen_index = num_g * device_core_num + block_index
    n_index = all_fen_index // fen_n
    fen_index = all_fen_index % fen_n
    row_index = fen_index // col_fen
    col_index = fen_index % col_fen

    _clean_ubuf(tvm_ib, data_ub, 0, ub_ele)
    _clean_ubuf(tvm_ib, data_res, 0, ub_ele)

    with tvm_ib.if_scope(row_index < row_zu - 1):
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_ub
            col_len_now = col_len_ub
            col_len_begin = col_index * col_len_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_two_large_fp32_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_ub
            ub_col_mod_align = _ceil_fill(ub_mod, cp_align_len)
            col_len_now = ub_col_mod_align
            col_len_begin = col_len - col_len_now
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_two_large_fp32_fencore(args)
    with tvm_ib.else_scope():
        with tvm_ib.if_scope(col_index < col_fen - 1):
            row_len_now = row_len - (row_zu - 1) * row_ub
            col_len_now = col_len_ub
            col_len_begin = col_index * col_len_ub
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_two_large_fp32_fencore(args)
        with tvm_ib.else_scope():
            row_len_now = row_len - (row_zu - 1) * row_ub
            ub_col_mod_align = _ceil_fill(ub_mod, cp_align_len)
            col_len_now = ub_col_mod_align
            col_len_begin = col_len - col_len_now
            args = tvm_ib, data, dst, data_ub, data_res, addr_array, \
                   addr_array_buf, ub_ele, float_size, cp_align_len, col_len, \
                   row_len, n_index, row_index, row_ub, \
                   row_len_now, col_len_now, col_len_begin
            _move_for_two_large_fp32_fencore(args)


def _two_large_fp32_fencore(dst, data):
    """
    function of making ir node builder for two large fp32 fencore scene

    """
    tvm_ib = tvm.ir_builder.create()

    n_i, col_len, row_len = data.shape

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    row_ub = 8
    col_len_ub = (ub_ele // 16 // 8 // 16) * 16
    ub_loop = col_len // col_len_ub
    ub_mod = col_len % col_len_ub
    row_len_align = _ceil_fill(row_len, cp_align_len)
    row_zu = row_len_align // cp_align_len

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(ub_mod > 0):
        col_fen = ub_loop + 1
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, col_len_ub, ub_mod, num_g
            _func_two_large_fp32_fencore_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen, \
                       col_len_ub, ub_mod, group_index
                _func_two_large_fp32_fencore_mod(args)
    with tvm_ib.else_scope():
        col_fen = ub_loop
        fen_n = col_fen * row_zu
        all_fen = n_i * fen_n
        group_index = all_fen // device_core_num
        group_mod = all_fen % device_core_num

        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, \
                   row_ub, row_zu, fen_n, col_fen, col_len_ub, ub_mod, num_g
            _func_two_large_fp32_fencore_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       device_core_num, block_index, cp_align_len, \
                       row_ub, row_zu, fen_n, col_fen, \
                       col_len_ub, ub_mod, group_index
                _func_two_large_fp32_fencore_nomod(args)

    return tvm_ib.get()


def _reg_mov_batch_0213(args):
    """
    reg_mov data in ub for 0213 scene

    """
    tvm_ib, data_ub, data_res, reg, one_ele, two_ele,\
    three_d, num_o, num_e, two_d = args

    ele_reg = 8
    r_cycle = two_d // ele_reg
    r_mod = two_d % ele_reg
    reg_zero = 0
    reg_one = 1
    reg_two = 2
    reg_three = 3
    reg_four = 4
    reg_five = 5
    reg_six = 6
    reg_seven = 7

    with tvm_ib.for_range(0, r_cycle, name="num_cr") as num_cr:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_zero)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_one]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_one)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_two]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_two)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_three]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_three)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_four]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_four)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_five]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_five)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_six]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_six)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (num_cr*ele_reg + reg_seven)
                                       * three_d + num_e))
        ))

        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_zero)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_zero])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_one)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_one])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_two)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_two])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_three)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_three])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_four)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_four])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_five)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_five])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_six)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_six])
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((num_cr*ele_reg + reg_seven)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[reg_seven])
        ))
    with tvm_ib.for_range(0, r_mod, name="num_er") as num_er:
        tvm_ib.emit(tvm.call_extern(
            data_ub.dtype, "reg_mov",
            tvm.call_extern(reg.dtype, "reg", reg[0]),
            data_ub.access_ptr('r',
                               offset=(num_o * one_ele
                                       + (r_cycle*ele_reg + num_er)
                                       * three_d + num_e))
        ))
        tvm_ib.emit(tvm.call_extern(
            data_res.dtype, "reg_mov",
            data_res.access_ptr('w',
                                offset=((r_cycle*ele_reg + num_er)
                                        * two_ele + num_o * three_d + num_e)),
            tvm.call_extern(reg.dtype, "reg", reg[0])
        ))


def _func_move_0213_small_dim(args):
    """
    function of moving data for 0213 small dim scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    float_size, cp_align_len, device_core_num, block_index, num_g = args
    _, one_d, two_d, three_d = data.shape

    dim_ele = one_d * two_d * three_d

    n_index = num_g * device_core_num + block_index

    data_offset = n_index * dim_ele
    burst_len_data = _ceil_div(dim_ele, cp_align_len)
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_ele = two_d * three_d
    two_ele = one_d * three_d
    with tvm_ib.for_range(0, one_d, name="num_o") as num_o:
        with tvm_ib.for_range(0, three_d, name="num_e") as num_e:
            args = tvm_ib, data_ub, data_res, reg, one_ele, two_ele,\
                   three_d, num_o, num_e, two_d
            _reg_mov_batch_0213(args)

    dst_offset = n_index * dim_ele
    with tvm_ib.if_scope(dim_ele % cp_align_len > 0):
        move_len = dim_ele - cp_align_len
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r', offset=move_len + num_a)
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + move_len),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))

    with tvm_ib.else_scope():
        burst_len_dst = _ceil_div(dim_ele, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _move_0213_small_dim(dst, data):
    """
    function of making ir node builder for 0213 small dim scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)

    n_i = data.shape[0]

    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               float_size, cp_align_len, device_core_num, block_index, num_g
        _func_move_0213_small_dim(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
                   float_size, cp_align_len, device_core_num,\
                   block_index, group_index
            _func_move_0213_small_dim(args)

    return tvm_ib.get()


def _move_0213_sp1(dst, data):
    """
    function of making ir node builder for move 0213 special one scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)

    one_d, two_d, three_d, four_d = data.shape
    half_two = two_d // 2
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.if_scope(block_index < 2):
        data_offset = block_index * half_two * three_d * four_d
        burst_len_data = half_two * three_d * four_d // cp_align_len
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=0),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

        with tvm_ib.for_range(0, three_d, name="num_t") as num_t:
            dst_offset = block_index * half_two * four_d\
                         + num_t * two_d * four_d
            res_offset = num_t * four_d
            n_burst = half_two
            burst_len_dst = four_d // cp_align_len
            src_stride = (three_d - 1) * four_d // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_ub.access_ptr(
                                            "r", offset=res_offset),
                                        0, n_burst, burst_len_dst, src_stride,
                                        0))

    return tvm_ib.get()


def _func_move_0213_12_30_26_fp16(args):
    """
    function of moving data for 0213 scene
    [n, 12, 30, 26]  or  [n, 30, 12, 26]

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, cp_align_len, float_size, ub_ele, device_core_num,\
    block_index, num_g = args

    one_d, two_d, three_d, four_d = data.shape
    split_zu = 3
    split_three = three_d // split_zu
    dim_ele = two_d * three_d * four_d
    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, split_zu, name="num_z") as num_z:
        data_len = split_three * four_d
        data_len_align = _ceil_fill(data_len, cp_align_len)
        data_len_div = data_len_align // cp_align_len
        with tvm_ib.for_range(0, two_d, name="num_t") as num_t:
            data_offset = n_index * dim_ele + num_z * split_three * four_d\
                          + num_t * three_d * four_d
            ub_offset = num_t * data_len_align
            burst_len_data = data_len_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        with tvm_ib.for_range(0, two_d, name="num_t") as num_t:
            one_begin = num_t * data_len_align * float_size
            two_begin = ub_ele * float_size\
                        + num_t * data_len * cp_align_len * float_size
            repeat_vconv = data_len_div
            src_stride_vconv = 1
            dst_stride_vconv = 16
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_two_not_align(args)

        with tvm_ib.for_range(0, split_three, name="num_s") as num_s:
            res_offset = num_s * four_d * cp_align_len
            ub_offset = num_s * two_d * four_d * cp_align_len
            n_burst = two_d
            burst_len = four_d
            src_stride = (split_three - 1) * four_d
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr("w",
                                                   offset=ub_offset),
                                data_res.access_ptr('r',
                                                    offset=res_offset),
                                0, n_burst, burst_len, src_stride, 0))

        all_ele = data_len * two_d
        all_ele_div = _ceil_div(all_ele, cp_align_len)
        ub_begin = 0
        res_begin = ub_ele * float_size
        repeat_vconv = all_ele_div
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, ub_begin, res_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.if_scope(all_ele % cp_align_len > 0):
            move_len = all_ele - cp_align_len
            dst_offset = n_index * dim_ele + num_z * all_ele
            burst_len_dst = _ceil_div(move_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=(move_len + num_a))
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr(
                        'w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=(dst_offset + move_len)),
                                        data_tail.access_ptr(
                                            "r", offset=0),
                                        0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = n_index * dim_ele + num_z * all_ele
            burst_len_dst = all_ele // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _move_0213_12_30_26_fp16(dst, data):
    """
    function of making ir node builder for move 0213
    [n,12,30,26] or [n,30,12,26] special scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    one_d = data.shape[0]
    group_index = one_d // device_core_num
    group_mod = one_d % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, cp_align_len, float_size,\
               ub_ele, device_core_num, block_index, num_g
        _func_move_0213_12_30_26_fp16(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, cp_align_len, float_size, \
                   ub_ele, device_core_num, block_index, group_index
            _func_move_0213_12_30_26_fp16(args)

    return tvm_ib.get()


def _func_move_0213_12_30_26_fp32(args):
    """
    function of moving data for 0213 scene
    [n, 12, 30, 26]  or  [n, 30, 12, 26]

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, cp_align_len, float_size, ub_ele, device_core_num,\
    block_index, num_g = args

    one_d, two_d, three_d, four_d = data.shape
    split_zu = 6
    split_three = three_d // split_zu
    dim_ele = two_d * three_d * four_d
    n_index = num_g * device_core_num + block_index

    with tvm_ib.for_range(0, split_zu, name="num_z") as num_z:
        data_len = split_three * four_d
        data_len_align = _ceil_fill(data_len, cp_align_len)
        data_len_div = data_len_align // cp_align_len
        with tvm_ib.for_range(0, two_d, name="num_t") as num_t:
            data_offset = n_index * dim_ele + num_z * split_three * four_d\
                          + num_t * three_d * four_d
            ub_offset = num_t * data_len_align
            burst_len_data = data_len_align // cp_align_len
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w", offset=ub_offset),
                                        data.access_ptr('r',
                                                        offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        vconv_len = data_len * 2
        vconv_len_div = _ceil_div(vconv_len, 16)
        with tvm_ib.for_range(0, two_d, name="num_t") as num_t:
            one_begin = num_t * data_len_align * float_size
            two_begin = ub_ele * float_size\
                        + num_t * vconv_len * cp_align_len * float_size
            repeat_vconv = vconv_len_div
            src_stride_vconv = 1
            dst_stride_vconv = 16
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_two_not_align(args)

        with tvm_ib.for_range(0, split_three, name="num_s") as num_s:
            res_offset = num_s * four_d * 2 * cp_align_len
            ub_offset = num_s * two_d * four_d * 2 * cp_align_len
            n_burst = two_d
            burst_len = four_d * 2
            src_stride = (split_three - 1) * four_d * 2
            tvm_ib.emit(
                tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                data_ub.access_ptr("w",
                                                   offset=ub_offset),
                                data_res.access_ptr('r',
                                                    offset=res_offset),
                                0, n_burst, burst_len, src_stride, 0))

        all_ele = data_len * two_d * 2
        all_ele_div = _ceil_div(all_ele, 16)
        ub_begin = 0
        res_begin = ub_ele * float_size
        repeat_vconv = all_ele_div
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, ub_begin, res_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        move_ele = two_d * split_three * four_d
        with tvm_ib.if_scope(move_ele % cp_align_len > 0):
            move_ele_sub = move_ele - cp_align_len
            dst_offset = n_index * dim_ele + num_z * move_ele
            burst_len_dst = _ceil_div(move_ele_sub, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=(move_ele_sub + num_a))
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr(
                        'w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))
            tvm_ib.emit(
                tvm.call_extern(
                    dst.dtype, "copy_ubuf_to_gm",
                    dst.access_ptr(
                        'w', offset=(dst_offset + move_ele_sub)),
                    data_tail.access_ptr("r", offset=0),
                    0, 1, 1, 0, 0))

        with tvm_ib.else_scope():
            dst_offset = n_index * dim_ele + num_z * move_ele
            burst_len_dst = move_ele // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _move_0213_12_30_26_fp32(dst, data):
    """
    function of making ir node builder for move 0213
    [n,12,30,26] or [n,30,12,26] special scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    one_d = data.shape[0]
    group_index = one_d // device_core_num
    group_mod = one_d % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, cp_align_len, float_size,\
               ub_ele, device_core_num, block_index, num_g
        _func_move_0213_12_30_26_fp32(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, cp_align_len, float_size, \
                   ub_ele, device_core_num, block_index, group_index
            _func_move_0213_12_30_26_fp32(args)

    return tvm_ib.get()


def _func_0213_vec_small(args):

    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array,\
    addr_array_buf, block_index, device_core_num, cp_align_len, float_size,\
    ub_ele, num_g = args

    n_index = num_g * device_core_num + block_index
    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    dim_ele_div = _ceil_div(dim_ele, cp_align_len)

    data_offset = n_index * dim_ele
    burst_len_data = dim_ele_div
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_ele_div
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, three_d, name="num_te") as num_te:
        res_offset = num_te * four_d * cp_align_len
        ub_offset = num_te * two_d * four_d * cp_align_len
        n_burst = two_d
        burst_len = four_d
        src_stride = three_d * four_d - four_d
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr("w",
                                               offset=ub_offset),
                            data_res.access_ptr('r',
                                                offset=res_offset),
                            0, n_burst, burst_len, src_stride, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = dim_ele_div
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(dim_ele % cp_align_len > 0):
        move_len = dim_ele - cp_align_len
        dst_offset = n_index * dim_ele
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=(move_len + num_a))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))

        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w', offset=(dst_offset + move_len)),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        dst_offset = n_index * dim_ele
        burst_len_dst = dim_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _move_0213_vec_small(dst, data):
    """
    function of making ir node builder for 0213 vec small scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i = data.shape[0]
    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, block_index, device_core_num,\
               cp_align_len, float_size, ub_ele, num_g
        _func_0213_vec_small(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, block_index, device_core_num, \
                   cp_align_len, float_size, ub_ele, group_index
            _func_0213_vec_small(args)

    return tvm_ib.get()


def _0213_vec_mid_two(args):
    """
    function of moving data for 0213 vec mid two scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
    two_d, three_d, four_d, n_index, dim_ele, thf_ele,\
    two_len, two_before = args

    twof_ele = two_len * four_d
    twof_ele_align = _ceil_fill(twof_ele, cp_align_len)

    move_ele = two_len * thf_ele
    move_ele_div = _ceil_div(move_ele, 16)
    data_offset = n_index * dim_ele + two_before * thf_ele
    burst_len_data = move_ele_div
    tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                data_ub.access_ptr(
                                    "w", offset=0),
                                data.access_ptr('r',
                                                offset=data_offset),
                                0, 1, burst_len_data, 0, 0))

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = move_ele_div
    src_stride_vconv = 1
    dst_stride_vconv = 16
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.for_range(0, three_d, name="num_te") as num_te:
        res_offset = num_te * four_d * cp_align_len
        ub_offset = num_te * two_len * four_d * cp_align_len
        n_burst = two_len
        burst_len = four_d
        src_stride = three_d * four_d - four_d
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr("w",
                                               offset=ub_offset),
                            data_res.access_ptr('r',
                                                offset=res_offset),
                            0, n_burst, burst_len, src_stride, 0))

    with tvm_ib.for_range(0, three_d, name="num_tr") as num_tr:
        one_begin = num_tr * twof_ele * cp_align_len * float_size
        two_begin = ub_ele * float_size \
                    + num_tr * twof_ele_align * float_size
        repeat_vconv = twof_ele_align // 16
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

    with tvm_ib.for_range(0, three_d, name="num_tz") as num_tz:
        with tvm_ib.if_scope(twof_ele % cp_align_len > 0):
            move_len = twof_ele - cp_align_len
            dst_offset = n_index * dim_ele + two_before * four_d\
                         + num_tz * two_d * four_d
            res_offset = num_tz * twof_ele_align
            burst_len_dst = _ceil_div(move_len, cp_align_len)
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))
            with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
                tvm_ib.emit(tvm.call_extern(
                    data_res.dtype, "reg_mov",
                    tvm.call_extern(reg.dtype, "reg", reg[0]),
                    data_res.access_ptr(
                        'r',
                        offset=(num_tz * twof_ele_align + move_len + num_a))
                ))
                tvm_ib.emit(tvm.call_extern(
                    data_tail.dtype, "reg_mov",
                    data_tail.access_ptr(
                        'w', offset=num_a),
                    tvm.call_extern(reg.dtype, "reg", reg[0])
                ))

            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr(
                                            'w',
                                            offset=dst_offset + move_len),
                                        data_tail.access_ptr(
                                            "r", offset=0),
                                        0, 1, 1, 0, 0))
        with tvm_ib.else_scope():
            dst_offset = n_index * dim_ele + two_before * four_d \
                         + num_tz * two_d * four_d
            res_offset = num_tz * twof_ele_align
            burst_len_dst = twof_ele // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr(
                                            "r", offset=res_offset),
                                        0, 1, burst_len_dst, 0, 0))


def _func_0213_vec_mid_two(args):
    """
    function of 0213 vec mid two scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, block_index, device_core_num, cp_align_len, float_size, \
    ub_ele, num_g = args

    _, two_d, three_d, four_d = data.shape
    n_index = num_g * device_core_num + block_index
    dim_ele = two_d * three_d * four_d

    thf_ele = three_d * four_d
    thf_space_ele = _ceil_fill(thf_ele, 16) * cp_align_len
    two_ub = ub_ele // thf_space_ele
    ub_loop = two_d // two_ub
    ub_mod = two_d % two_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        two_len = two_ub
        two_before = num_u * two_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
               two_d, three_d, four_d, n_index, dim_ele, thf_ele,\
               two_len, two_before
        _0213_vec_mid_two(args)
    with tvm_ib.if_scope(ub_mod > 0):
        with tvm_ib.if_scope(ub_mod * four_d >= cp_align_len):
            two_len = ub_mod
            two_before = ub_loop * two_ub
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_d, three_d, four_d, n_index, dim_ele,\
                   thf_ele, two_len, two_before
            _0213_vec_mid_two(args)
        with tvm_ib.else_scope():
            two_len = _ceil_div(cp_align_len, four_d)
            two_before = two_d - two_len
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_d, three_d, four_d, n_index, dim_ele,\
                   thf_ele, two_len, two_before
            _0213_vec_mid_two(args)


def _move_0213_vec_mid_two(dst, data):
    """
    function of making ir node builder for 0213 vec mid two scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i = data.shape[0]
    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, block_index, device_core_num,\
               cp_align_len, float_size, ub_ele, num_g
        _func_0213_vec_mid_two(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, block_index, device_core_num, \
                   cp_align_len, float_size, ub_ele, group_index
            _func_0213_vec_mid_two(args)

    return tvm_ib.get()


def _func_0213_vec_mid_two_mod(args):
    """
    function of 0213 vec mid two mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
    two_ub, ub_mod, fen_n, device_core_num, device_core_num,\
    block_index, num_g = args

    core_before = num_g * device_core_num + block_index
    n_index = core_before // fen_n
    fen_index = core_before % fen_n

    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    thf_ele = three_d * four_d

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        two_len = two_ub
        two_before = fen_index * two_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
               two_d, three_d, four_d, n_index, dim_ele, thf_ele, \
               two_len, two_before
        _0213_vec_mid_two(args)
    with tvm_ib.else_scope():
        with tvm_ib.if_scope(ub_mod * four_d >= cp_align_len):
            two_len = ub_mod
            two_before = (fen_n - 1) * two_ub
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_d, three_d, four_d, n_index, dim_ele,\
                   thf_ele, two_len, two_before
            _0213_vec_mid_two(args)
        with tvm_ib.else_scope():
            two_len = _ceil_div(cp_align_len, four_d)
            two_before = two_d - two_len
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_d, three_d, four_d, n_index, dim_ele,\
                   thf_ele, two_len, two_before
            _0213_vec_mid_two(args)


def _func_0213_vec_mid_two_nomod(args):
    """
    function of 0213 vec mid two no mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
    two_ub, ub_mod, fen_n, device_core_num, device_core_num,\
    block_index, num_g = args

    core_before = num_g * device_core_num + block_index
    n_index = core_before // fen_n
    fen_index = core_before % fen_n

    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    thf_ele = three_d * four_d

    two_len = two_ub
    two_before = fen_index * two_ub
    args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
           addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
           two_d, three_d, four_d, n_index, dim_ele, thf_ele, \
           two_len, two_before
    _0213_vec_mid_two(args)


def _move_0213_vec_mid_two_fencore(dst, data):
    """
    function of making ir node builder for 0213 vec mid two fen core scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    n_i, two_d, three_d, four_d = data.shape
    thf_ele = three_d * four_d
    thf_space_ele = _ceil_fill(thf_ele, 16) * cp_align_len
    two_ub = ub_ele // thf_space_ele
    ub_loop = two_d // two_ub
    ub_mod = two_d % two_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_core = n_i * fen_n
        group_index = all_core // device_core_num
        group_mod = all_core % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_ub, ub_mod, fen_n, device_core_num,\
                   device_core_num, block_index, num_g
            _func_0213_vec_mid_two_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size,\
                       cp_align_len, two_ub, ub_mod, fen_n, device_core_num,\
                       device_core_num, block_index, group_index
                _func_0213_vec_mid_two_mod(args)

    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_core = n_i * fen_n
        group_index = all_core // device_core_num
        group_mod = all_core % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size,\
                   cp_align_len, two_ub, ub_mod, fen_n, device_core_num,\
                   device_core_num, block_index, num_g
            _func_0213_vec_mid_two_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size,\
                       cp_align_len, two_ub, ub_mod, fen_n, device_core_num,\
                       device_core_num, block_index, group_index
                _func_0213_vec_mid_two_nomod(args)

    return tvm_ib.get()


def _0213_vec_mid_one(args):
    """
    function of moving data for 0213 vec mid one scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
    two_d, three_d, four_d, n_index, dim_ele, twofour_ele,\
    three_len, three_before = args

    tef_ele = three_len * four_d
    tef_ele_align = _ceil_fill(tef_ele, cp_align_len)
    tef_ele_div = tef_ele_align // cp_align_len

    with tvm_ib.for_range(0, two_d, name="num_tw") as num_tw:
        data_offset = n_index * dim_ele + three_before * four_d\
                      + num_tw * three_d * four_d
        ub_offset = num_tw * tef_ele_align
        burst_len_data = tef_ele_div
        tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data.access_ptr('r',
                                                    offset=data_offset),
                                    0, 1, burst_len_data, 0, 0))

    with tvm_ib.for_range(0, two_d, name="num_to") as num_to:
        one_begin = num_to * tef_ele_align * float_size
        two_begin = ub_ele * float_size\
                    + num_to * tef_ele * cp_align_len * float_size
        repeat_vconv = tef_ele_align // 16
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

    with tvm_ib.for_range(0, two_d, name="num_td") as num_td:
        res_offset = num_td * three_len * four_d * cp_align_len
        ub_offset = num_td * four_d * cp_align_len
        n_burst = three_len
        burst_len = four_d
        dst_stride = two_d * four_d - four_d
        tvm_ib.emit(
            tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                            data_ub.access_ptr("w",
                                               offset=ub_offset),
                            data_res.access_ptr('r',
                                                offset=res_offset),
                            0, n_burst, burst_len, 0, dst_stride))

    all_ele = three_len * two_d * four_d
    all_ele_align = _ceil_fill(all_ele, cp_align_len)
    all_ele_div = all_ele_align // cp_align_len

    one_begin = 0
    two_begin = ub_ele * float_size
    repeat_vconv = all_ele_div
    src_stride_vconv = 16
    dst_stride_vconv = 1
    args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
           repeat_vconv, src_stride_vconv, dst_stride_vconv
    _vconv_two_not_align(args)

    with tvm_ib.if_scope(all_ele % cp_align_len > 0):
        move_len = all_ele - cp_align_len
        dst_offset = n_index * dim_ele + three_before * two_d * four_d
        burst_len_dst = _ceil_div(move_len, cp_align_len)
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))
        with tvm_ib.for_range(0, cp_align_len, name="num_a") as num_a:
            tvm_ib.emit(tvm.call_extern(
                data_res.dtype, "reg_mov",
                tvm.call_extern(reg.dtype, "reg", reg[0]),
                data_res.access_ptr(
                    'r',
                    offset=(move_len + num_a))
            ))
            tvm_ib.emit(tvm.call_extern(
                data_tail.dtype, "reg_mov",
                data_tail.access_ptr(
                    'w', offset=num_a),
                tvm.call_extern(reg.dtype, "reg", reg[0])
            ))

        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr(
                                        'w',
                                        offset=dst_offset + move_len),
                                    data_tail.access_ptr(
                                        "r", offset=0),
                                    0, 1, 1, 0, 0))
    with tvm_ib.else_scope():
        dst_offset = n_index * dim_ele + three_before * two_d * four_d
        burst_len_dst = all_ele // cp_align_len
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr(
                                        "r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _func_0213_vec_mid_one(args):
    """
    function of 0213 vec mid one scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, addr_array, \
    addr_array_buf, block_index, device_core_num, cp_align_len, float_size, \
    ub_ele, num_g = args

    _, two_d, three_d, four_d = data.shape
    n_index = num_g * device_core_num + block_index
    dim_ele = two_d * three_d * four_d

    twofour_ele = two_d * four_d
    twofour_space_ele = _ceil_fill(twofour_ele, 16) * cp_align_len
    three_ub = ub_ele // twofour_space_ele
    ub_loop = three_d // three_ub
    ub_mod = three_d % three_ub

    with tvm_ib.for_range(0, ub_loop, name="num_u") as num_u:
        three_len = three_ub
        three_before = num_u * three_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
               two_d, three_d, four_d, n_index, dim_ele, twofour_ele,\
               three_len, three_before
        _0213_vec_mid_one(args)
    with tvm_ib.if_scope(ub_mod > 0):
        three_len = ub_mod
        three_before = ub_loop * three_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, ub_ele, float_size, \
               cp_align_len, two_d, three_d, four_d, n_index, dim_ele, \
               twofour_ele, three_len, three_before
        _0213_vec_mid_one(args)


def _move_0213_vec_mid_one(dst, data):
    """
    function of making ir node builder for 0213 vec mid one scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i = data.shape[0]
    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, block_index, device_core_num,\
               cp_align_len, float_size, ub_ele, num_g
        _func_0213_vec_mid_one(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, block_index, device_core_num, \
                   cp_align_len, float_size, ub_ele, group_index
            _func_0213_vec_mid_one(args)

    return tvm_ib.get()


def _func_0213_vec_mid_one_mod(args):
    """
    function of 0213 vec mid one mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
    three_ub, ub_mod, fen_n, device_core_num, device_core_num, \
    block_index, num_g = args

    core_before = num_g * device_core_num + block_index
    n_index = core_before // fen_n
    fen_index = core_before % fen_n

    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    twofour_ele = two_d * four_d

    with tvm_ib.if_scope(fen_index < fen_n - 1):
        three_len = three_ub
        three_before = fen_index * three_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg,\
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len,\
               two_d, three_d, four_d, n_index, dim_ele, twofour_ele,\
               three_len, three_before
        _0213_vec_mid_one(args)
    with tvm_ib.else_scope():
        three_len = ub_mod
        three_before = (fen_n - 1) * three_ub
        args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
               addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
               two_d, three_d, four_d, n_index, dim_ele, twofour_ele, \
               three_len, three_before
        _0213_vec_mid_one(args)


def _func_0213_vec_mid_one_nomod(args):
    """
    function of 0213 vec mid one no mod scene

    """
    tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
    addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
    three_ub, ub_mod, fen_n, device_core_num, device_core_num, \
    block_index, num_g = args

    core_before = num_g * device_core_num + block_index
    n_index = core_before // fen_n
    fen_index = core_before % fen_n

    _, two_d, three_d, four_d = data.shape
    dim_ele = two_d * three_d * four_d
    twofour_ele = two_d * four_d

    three_len = three_ub
    three_before = fen_index * three_ub
    args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
           addr_array, addr_array_buf, ub_ele, float_size, cp_align_len, \
           two_d, three_d, four_d, n_index, dim_ele, twofour_ele, \
           three_len, three_before
    _0213_vec_mid_one(args)


def _move_0213_vec_mid_one_fencore(dst, data):
    """
    function of making ir node builder for 0213 vec mid one fen core scene

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    data_tail = _new_alloc(tvm_ib, dst.dtype, cp_align_len,
                           "data_tail", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    n_i, two_d, three_d, four_d = data.shape
    twofour_ele = two_d * four_d
    twofour_space_ele = _ceil_fill(twofour_ele, 16) * cp_align_len
    three_ub = ub_ele // twofour_space_ele
    ub_loop = three_d // three_ub
    ub_mod = three_d % three_ub

    with tvm_ib.if_scope(ub_mod > 0):
        fen_n = ub_loop + 1
        all_core = n_i * fen_n
        group_index = all_core // device_core_num
        group_mod = all_core % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   cp_align_len, three_ub, ub_mod, fen_n, device_core_num, \
                   device_core_num, block_index, num_g
            _func_0213_vec_mid_one_mod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       cp_align_len, three_ub, ub_mod, fen_n, device_core_num,\
                       device_core_num, block_index, group_index
                _func_0213_vec_mid_one_mod(args)
    with tvm_ib.else_scope():
        fen_n = ub_loop
        all_core = n_i * fen_n
        group_index = all_core // device_core_num
        group_mod = all_core % device_core_num
        with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
            args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   cp_align_len, three_ub, ub_mod, fen_n, device_core_num, \
                   device_core_num, block_index, num_g
            _func_0213_vec_mid_one_nomod(args)
        with tvm_ib.if_scope(group_mod > 0):
            with tvm_ib.if_scope(block_index < group_mod):
                args = tvm_ib, data, dst, data_ub, data_res, data_tail, reg, \
                       addr_array, addr_array_buf, ub_ele, float_size, \
                       cp_align_len, three_ub, ub_mod, fen_n, device_core_num,\
                       device_core_num, block_index, group_index
                _func_0213_vec_mid_one_nomod(args)

    return tvm_ib.get()


def _func_move_014253_sp1(args):
    """
    function of moving data for [0,1,4,2,5,3] scene
    [1,32,2,2,851,664] float32

    """
    tvm_ib, data, dst, data_ub, data_res, reg, reg_addr, addr_array,\
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g = args

    _, _, one_d, two_d, three_d, four_d = data.shape
    n_index = num_g * device_core_num + block_index
    n_ele = one_d * two_d * three_d * four_d
    in_big_ele = two_d * three_d * four_d
    in_dim_ele = three_d * four_d
    dim_ele = two_d * four_d
    dim_ele_two = dim_ele * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    dim_zu = dim_ele_two_align // 16

    with tvm_ib.for_range(0, three_d, name="num_te") as num_te:
        with tvm_ib.for_range(0, one_d, name="num_o") as num_o:

            with tvm_ib.for_range(0, two_d, name="num_to") as num_to:
                data_offset = n_index * n_ele + num_o * in_big_ele\
                              + num_to * in_dim_ele + num_te * four_d
                ub_offset = num_to * four_d
                burst_len_data = four_d // cp_align_len
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w",
                                                offset=ub_offset),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset),
                                            0, 1, burst_len_data, 0, 0))

            reg_addr[0] = tvm.expr.Cast(
                "int64",
                tvm.call_extern("handle", "",
                                data_ub.access_ptr("r"))).astype("int32")
            reg_addr[1] = tvm.expr.Cast(
                "int64",
                tvm.call_extern("handle", "",
                                data_res.access_ptr("r"))).astype("int32")
            one_begin = reg_addr[0]
            two_begin = reg_addr[1]
            repeat_vconv = dim_zu
            src_stride_vconv = 1
            dst_stride_vconv = 16
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_two_not_align(args)

            with tvm_ib.for_range(0, two_d, name="num_tod") as num_tod:
                res_offset = num_tod * four_d * 2 * cp_align_len
                ub_offset = num_tod * 2 * cp_align_len
                n_burst = four_d
                burst_len = 2
                src_stride = 0
                dst_stride = (two_d - 1) * 2
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

            one_begin = reg_addr[0]
            two_begin = reg_addr[1]
            repeat_vconv = dim_zu
            src_stride_vconv = 16
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_two_not_align(args)

            dst_offset = n_index * n_ele + num_te * one_d * four_d * two_d\
                         + num_o * four_d * two_d
            burst_len_dst = two_d * four_d // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _move_014253_sp1(dst, data):
    """
    function of making ir node builder for [0,1,4,2,5,3] scene
    [1,32,2,2,851,664] float32

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_addr = tvm_ib.allocate("int32", (2,), name='reg_addr',
                               scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i = data.shape[1]
    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, reg, reg_addr,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_move_014253_sp1(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, reg, reg_addr, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, group_index
            _func_move_014253_sp1(args)

    return tvm_ib.get()


def _func_move_014253_sp2(args):
    """
    function of moving data for [0,1,4,2,5,3] scene
    [1,32,2,2,851,664] float16

    """
    tvm_ib, data, dst, data_ub, data_res, reg, reg_addr, addr_array,\
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g = args

    _, _, one_d, two_d, three_d, four_d = data.shape
    n_index = num_g * device_core_num + block_index
    n_ele = one_d * two_d * three_d * four_d
    in_dim_ele = three_d * four_d

    in_loop = one_d * two_d
    four_align = _ceil_fill(four_d, cp_align_len)
    four_div = _ceil_div(four_d, cp_align_len)

    with tvm_ib.for_range(0, three_d, name="num_te") as num_te:
        with tvm_ib.for_range(0, in_loop, name="num_i") as num_i:
            data_offset = n_index * n_ele + num_i * in_dim_ele\
                          + num_te * four_d
            ub_offset = num_i * four_align
            burst_len_data = four_div
            tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                        data_ub.access_ptr(
                                            "w",
                                            offset=ub_offset),
                                        data.access_ptr(
                                            'r',
                                            offset=data_offset),
                                        0, 1, burst_len_data, 0, 0))

        reg_addr[0] = tvm.expr.Cast(
            "int64",
            tvm.call_extern("handle", "",
                            data_ub.access_ptr("r"))).astype("int32")
        reg_addr[1] = tvm.expr.Cast(
            "int64",
            tvm.call_extern("handle", "",
                            data_res.access_ptr("r"))).astype("int32")

        dim_zu1 = one_d * two_d * four_align // 16
        one_begin = reg_addr[0]
        two_begin = reg_addr[1]
        repeat_vconv = dim_zu1
        src_stride_vconv = 1
        dst_stride_vconv = 16
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        with tvm_ib.for_range(0, one_d, name="num_o") as num_o:
            with tvm_ib.for_range(0, two_d, name="num_tod") as num_tod:
                res_offset = num_o * two_d * four_align * cp_align_len\
                             + num_tod * four_align * cp_align_len
                ub_offset = num_o * two_d * four_d * cp_align_len\
                            + num_tod * cp_align_len
                n_burst = four_d
                burst_len = 1
                src_stride = 0
                dst_stride = two_d - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

        dim_ele = one_d * two_d * four_d
        dim_zu = _ceil_div(dim_ele, 16)
        one_begin = reg_addr[0]
        two_begin = reg_addr[1]
        repeat_vconv = dim_zu
        src_stride_vconv = 16
        dst_stride_vconv = 1
        args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
               repeat_vconv, src_stride_vconv, dst_stride_vconv
        _vconv_two_not_align(args)

        dst_offset = n_index * n_ele + num_te * dim_ele
        burst_len_dst = dim_zu
        tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                    dst.access_ptr('w',
                                                   offset=dst_offset),
                                    data_res.access_ptr("r", offset=0),
                                    0, 1, burst_len_dst, 0, 0))


def _move_014253_sp2(dst, data):
    """
    function of making ir node builder for [0,1,4,2,5,3] scene
    [1,32,2,2,851,664] float16

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_addr = tvm_ib.allocate("int32", (2,), name='reg_addr',
                               scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i = data.shape[1]
    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, reg, reg_addr,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_move_014253_sp2(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, reg, reg_addr, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, group_index
            _func_move_014253_sp2(args)

    return tvm_ib.get()


def _func_move_014253_sp3(args):
    """
    function of moving data for [0,1,4,2,5,3] scene
    [1,32,2,2,851,664] float32

    """
    tvm_ib, data, dst, data_ub, data_res, reg, reg_addr, addr_array,\
    addr_array_buf, ub_ele, float_size, device_core_num, block_index,\
    cp_align_len, num_g = args

    _, _, one_d, two_d, three_d, four_d = data.shape
    n_index = num_g * device_core_num + block_index
    n_ele = one_d * two_d * three_d * four_d
    in_big_ele = two_d * three_d * four_d
    in_dim_ele = three_d * four_d
    dim_ele = two_d * four_d
    dim_ele_align = _ceil_fill(dim_ele, 16)
    dim_zu = dim_ele_align // 16
    four_align = _ceil_fill(four_d, cp_align_len)

    with tvm_ib.for_range(0, three_d, name="num_te") as num_te:
        with tvm_ib.for_range(0, one_d, name="num_o") as num_o:

            with tvm_ib.for_range(0, two_d, name="num_to") as num_to:
                data_offset = n_index * n_ele + num_o * in_big_ele\
                              + num_to * in_dim_ele + num_te * four_d
                ub_offset = num_to * four_align
                burst_len_data = four_align // cp_align_len
                tvm_ib.emit(tvm.call_extern(data_ub.dtype, "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w",
                                                offset=ub_offset),
                                            data.access_ptr(
                                                'r',
                                                offset=data_offset),
                                            0, 1, burst_len_data, 0, 0))

            reg_addr[0] = tvm.expr.Cast(
                "int64",
                tvm.call_extern("handle", "",
                                data_ub.access_ptr("r"))).astype("int32")
            reg_addr[1] = tvm.expr.Cast(
                "int64",
                tvm.call_extern("handle", "",
                                data_res.access_ptr("r"))).astype("int32")

            dim_zu1 = two_d * four_align // 16
            one_begin = reg_addr[0]
            two_begin = reg_addr[1]
            repeat_vconv = dim_zu1
            src_stride_vconv = 1
            dst_stride_vconv = 16
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin, \
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_two_not_align(args)

            with tvm_ib.for_range(0, two_d, name="num_tod") as num_tod:
                res_offset = num_tod * four_align * cp_align_len
                ub_offset = num_tod * cp_align_len
                n_burst = four_align
                burst_len = 1
                src_stride = 0
                dst_stride = two_d - 1
                tvm_ib.emit(
                    tvm.call_extern(data_ub.dtype, "copy_ubuf_to_ubuf",
                                    data_ub.access_ptr(
                                        "w", offset=ub_offset),
                                    data_res.access_ptr(
                                        "r", offset=res_offset),
                                    0, n_burst, burst_len,
                                    src_stride, dst_stride))

            one_begin = reg_addr[0]
            two_begin = reg_addr[1]
            repeat_vconv = dim_zu1
            src_stride_vconv = 16
            dst_stride_vconv = 1
            args = tvm_ib, addr_array, addr_array_buf, one_begin, two_begin,\
                   repeat_vconv, src_stride_vconv, dst_stride_vconv
            _vconv_two_not_align(args)

            dst_offset = n_index * n_ele + num_te * one_d * four_d * two_d\
                         + num_o * four_d * two_d
            burst_len_dst = two_d * four_d // cp_align_len
            tvm_ib.emit(tvm.call_extern(dst.dtype, "copy_ubuf_to_gm",
                                        dst.access_ptr('w',
                                                       offset=dst_offset),
                                        data_res.access_ptr("r", offset=0),
                                        0, 1, burst_len_dst, 0, 0))


def _move_014253_sp3(dst, data):
    """
    function of making ir node builder for [0,1,4,2,5,3] scene
    [1,32,2,2,851,664] float32

    """
    tvm_ib = tvm.ir_builder.create()

    float_size = cce.cce_intrin.get_bit_len(data.dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    data_ub = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                         "data_ub", scope=cce.scope_ubuf)
    data_res = _new_alloc(tvm_ib, dst.dtype, ub_ele,
                          "data_res", scope=cce.scope_ubuf)
    reg = tvm_ib.allocate(dst.dtype, (8,), name='reg', scope=cce.scope_reg)
    reg_addr = tvm_ib.allocate("int32", (2,), name='reg_addr',
                               scope=cce.scope_reg)
    addr_array = tvm_ib.allocate("uint64", (32,), name="addr_array",
                                 scope=cce.scope_reg)
    addr_array_buf = tvm.decl_buffer((32,), "uint64_t", "addr_array_buf",
                                     scope=cce.scope_reg,
                                     data=addr_array)

    n_i = data.shape[1]
    group_index = n_i // device_core_num
    group_mod = n_i % device_core_num
    block_index = tvm.thread_axis("blockIdx.x")
    tvm_ib.scope_attr(block_index, "thread_extent", device_core_num)

    with tvm_ib.for_range(0, group_index, name="num_g") as num_g:
        args = tvm_ib, data, dst, data_ub, data_res, reg, reg_addr,\
               addr_array, addr_array_buf, ub_ele, float_size,\
               device_core_num, block_index, cp_align_len, num_g
        _func_move_014253_sp3(args)
    with tvm_ib.if_scope(group_mod > 0):
        with tvm_ib.if_scope(block_index < group_mod):
            args = tvm_ib, data, dst, data_ub, data_res, reg, reg_addr, \
                   addr_array, addr_array_buf, ub_ele, float_size, \
                   device_core_num, block_index, cp_align_len, group_index
            _func_move_014253_sp3(args)

    return tvm_ib.get()


def _clean_ubuf(ib_, src, src_offset, dup_len):
    """
    function of cleaning space in UB

    """
    uint64_all_one = tvm.const(2**64 - 1, dtype="uint64")
    uint64_all_zero = tvm.const(0, dtype="uint64")
    dtype_factor = 32 // cce.cce_intrin.get_bit_len(src.dtype)
    dup_value = tvm.const(0.0, dtype=src.dtype)
    batch_cnt = 64

    if dup_len > 0:
        if src.dtype == "float16":
            ib_.emit(
                tvm.call_extern("uint64", 'set_vector_mask', uint64_all_one,
                                uint64_all_one))
        else:
            ib_.emit(
                tvm.call_extern("uint64", 'set_vector_mask', uint64_all_zero,
                                uint64_all_one))

        repeat = dup_len // (batch_cnt * dtype_factor)
        dup_left = dup_len % (batch_cnt * dtype_factor)
        if repeat >= 255:
            repeat_loop = (repeat + 255 - 1) // 255
            with ib_.for_range(0, repeat_loop) as i:
                with ib_.if_scope(i != repeat_loop - 1):
                    ib_.emit(
                        tvm.call_extern(
                            src.dtype, 'vector_dup',
                            src.access_ptr(
                                "rw",
                                offset=(255 * batch_cnt * dtype_factor) * i +
                                src_offset), dup_value, 255, 1, 1, 8, 8))
                with ib_.else_scope():
                    ib_.emit(
                        tvm.call_extern(
                            src.dtype, "vector_dup",
                            src.access_ptr(
                                "rw",
                                offset=(255 * batch_cnt * dtype_factor) * i +
                                src_offset), dup_value, repeat % 255, 1, 1, 8,
                            8))

        else:
            ib_.emit(
                tvm.call_extern(src.dtype, "vector_dup",
                                src.access_ptr("rw", offset=src_offset),
                                dup_value, repeat, 1, 1, 8, 8))

            if dup_left > 0:
                if dup_left > 64:
                    high_mask = tvm.const(2 ** (dup_left % 64) - 1,
                                          dtype="uint64")
                    ib_.emit(
                        tvm.call_extern("uint64", 'set_vector_mask',
                                        high_mask,
                                        uint64_all_one))
                elif 0 < dup_left <= 64:
                    low_mask = tvm.const(2 ** dup_left - 1, dtype="uint64")
                    ib_.emit(
                        tvm.call_extern("uint64", 'set_vector_mask',
                                        uint64_all_zero,
                                        low_mask))
                ib_.emit(
                    tvm.call_extern(src.dtype, "vector_dup",
                                    src.access_ptr(
                                        "rw",
                                        offset=(src_offset
                                                + repeat * batch_cnt
                                                * dtype_factor)),
                                    dup_value, 1, 1, 1, 8, 8))

        ib_.emit(
            tvm.call_extern("uint64", 'set_vector_mask', uint64_all_one,
                            uint64_all_one))


def _func_gm_to_ub_align(args):
    """
    function of moving data from data to data_ub

    """
    tvm_ib, data, data_ub, data_offset, ub_offset, ori_nburst,\
    burst_len, src_stride, dst_stride, cp_align_len = args

    with tvm_ib.if_scope(ori_nburst > 0):
        with tvm_ib.if_scope(burst_len > 0):
            with tvm_ib.if_scope(burst_len <= 65535):
                with tvm_ib.if_scope(src_stride >= 0):
                    with tvm_ib.if_scope(dst_stride >= 0):
                        with tvm_ib.if_scope(dst_stride <= 65535):
                            with tvm_ib.if_scope(src_stride <= 65535):
                                with tvm_ib.if_scope(ori_nburst <= 4095):
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_ub.dtype,
                                            "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_offset),
                                            data.access_ptr(
                                                'r', offset=data_offset),
                                            0, ori_nburst,
                                            burst_len,
                                            src_stride, dst_stride))
                                with tvm_ib.else_scope():
                                    n_burst = 4095
                                    c_cycle = ori_nburst // n_burst
                                    c_mod = ori_nburst % n_burst
                                    with tvm_ib.for_range(0, c_cycle,
                                                          name="num_cy")\
                                            as num_cy:
                                        data_cur = data_offset + (
                                            burst_len + src_stride) \
                                                   * cp_align_len\
                                                   * n_burst * num_cy
                                        ub_cur = ub_offset + (
                                            burst_len + dst_stride) \
                                                 * cp_align_len\
                                                 * n_burst * num_cy
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w", offset=ub_cur),
                                                data.access_ptr(
                                                    'r', offset=data_cur),
                                                0, n_burst,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                                    with tvm_ib.if_scope(c_mod > 0):
                                        data_cur = data_offset + (
                                            burst_len + src_stride) \
                                                   * cp_align_len\
                                                   * n_burst * c_cycle
                                        ub_cur = ub_offset + (
                                            burst_len + dst_stride) \
                                                 * cp_align_len\
                                                 * n_burst * c_cycle
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                data_ub.dtype,
                                                "copy_gm_to_ubuf",
                                                data_ub.access_ptr(
                                                    "w", offset=ub_cur),
                                                data.access_ptr(
                                                    'r', offset=data_cur),
                                                0, c_mod, burst_len,
                                                src_stride,
                                                dst_stride))
                            with tvm_ib.else_scope():
                                with tvm_ib.for_range(0, ori_nburst,
                                                      name="num_nb") as num_nb:
                                    data_cur = data_offset + (
                                        burst_len + src_stride)\
                                               * cp_align_len * num_nb
                                    ub_cur = ub_offset + (
                                        burst_len + dst_stride)\
                                             * cp_align_len * num_nb
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            data_ub.dtype,
                                            "copy_gm_to_ubuf",
                                            data_ub.access_ptr(
                                                "w", offset=ub_cur),
                                            data.access_ptr(
                                                'r', offset=data_cur),
                                            0, 1, burst_len,
                                            0, 0))


def _func_ub_to_gm_align(args):
    """
    function of moving data from ub to gm

    """
    tvm_ib, dst, data_res, dst_offset, res_offset, ori_nburst,\
    burst_len, src_stride, dst_stride, cp_align_len = args

    with tvm_ib.if_scope(ori_nburst > 0):
        with tvm_ib.if_scope(burst_len > 0):
            with tvm_ib.if_scope(burst_len <= 65535):
                with tvm_ib.if_scope(src_stride >= 0):
                    with tvm_ib.if_scope(src_stride <= 65535):
                        with tvm_ib.if_scope(dst_stride >= 0):
                            with tvm_ib.if_scope(dst_stride <= 65535):
                                with tvm_ib.if_scope(ori_nburst <= 4095):
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            dst.dtype,
                                            "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w', offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, ori_nburst,
                                            burst_len,
                                            src_stride,
                                            dst_stride))
                                with tvm_ib.else_scope():
                                    n_burst = 4095
                                    c_cycle = ori_nburst // n_burst
                                    c_mod = ori_nburst % n_burst
                                    with tvm_ib.for_range(0, c_cycle,
                                                          name="num_cy")\
                                            as num_cy:
                                        dst_cur = dst_offset + (
                                            burst_len + dst_stride) \
                                                  * cp_align_len\
                                                  * n_burst * num_cy
                                        res_cur = res_offset + (
                                            burst_len + src_stride) \
                                                  * cp_align_len\
                                                  * n_burst * num_cy
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                dst.dtype,
                                                "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w',
                                                    offset=dst_cur),
                                                data_res.access_ptr(
                                                    "r", offset=res_cur),
                                                0, n_burst,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                                    with tvm_ib.if_scope(c_mod > 0):
                                        dst_cur = dst_offset + (
                                            burst_len + dst_stride) \
                                                  * cp_align_len\
                                                  * n_burst * c_cycle
                                        res_cur = res_offset + (
                                            burst_len + src_stride) \
                                                  * cp_align_len\
                                                  * n_burst * c_cycle
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                dst.dtype,
                                                "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_cur),
                                                data_res.access_ptr(
                                                    "r", offset=res_cur),
                                                0, c_mod,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                            with tvm_ib.else_scope():
                                with tvm_ib.for_range(0, ori_nburst,
                                                      name="num_nb") as num_nb:
                                    dst_cur = dst_offset + (
                                        burst_len + dst_stride)\
                                              * cp_align_len * num_nb
                                    res_cur = res_offset + (
                                        burst_len + src_stride)\
                                              * cp_align_len * num_nb
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            dst.dtype,
                                            "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w', offset=dst_cur),
                                            data_res.access_ptr(
                                                "r", offset=res_cur),
                                            0, 1, burst_len,
                                            0, 0))


def _func_ub_to_gm(args):
    """
    function of moving data from ub to gm

    """
    tvm_ib, param, dst, data_res, dst_offset, res_offset, ori_nburst,\
    burst_len, src_stride, dst_stride = args

    with tvm_ib.if_scope(ori_nburst > 0):
        with tvm_ib.if_scope(burst_len > 0):
            with tvm_ib.if_scope(burst_len <= 65535):
                with tvm_ib.if_scope(src_stride >= 0):
                    with tvm_ib.if_scope(src_stride <= 65535):
                        with tvm_ib.if_scope(dst_stride >= 0):
                            with tvm_ib.if_scope(dst_stride <= 65535):
                                with tvm_ib.if_scope(ori_nburst <= 4095):
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            dst.dtype,
                                            "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_offset),
                                            data_res.access_ptr(
                                                "r", offset=res_offset),
                                            0, ori_nburst,
                                            burst_len,
                                            src_stride,
                                            dst_stride))
                                with tvm_ib.else_scope():
                                    n_burst = 4095
                                    c_cycle = ori_nburst // n_burst
                                    c_mod = ori_nburst % n_burst
                                    with tvm_ib.for_range(0, c_cycle,
                                                          name="num_cy")\
                                            as num_cy:
                                        dst_cur = dst_offset + (
                                            burst_len + dst_stride) \
                                                  * param.get("cp_align_len")\
                                                  * n_burst * num_cy
                                        res_cur = res_offset + (
                                            burst_len + src_stride) \
                                                  * param.get("cp_align_len")\
                                                  * n_burst * num_cy
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                dst.dtype,
                                                "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_cur),
                                                data_res.access_ptr(
                                                    "r", offset=res_cur),
                                                0, n_burst,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                                    with tvm_ib.if_scope(c_mod > 0):
                                        dst_cur = dst_offset + (
                                            burst_len + dst_stride) \
                                                  * param.get("cp_align_len")\
                                                  * n_burst * c_cycle
                                        res_cur = res_offset + (
                                            burst_len + src_stride) \
                                                  * param.get("cp_align_len")\
                                                  * n_burst * c_cycle
                                        tvm_ib.emit(
                                            tvm.call_extern(
                                                dst.dtype,
                                                "copy_ubuf_to_gm",
                                                dst.access_ptr(
                                                    'w', offset=dst_cur),
                                                data_res.access_ptr(
                                                    "r", offset=res_cur),
                                                0, c_mod,
                                                burst_len,
                                                src_stride,
                                                dst_stride))
                            with tvm_ib.else_scope():
                                with tvm_ib.for_range(0, ori_nburst,
                                                      name="num_nb") as num_nb:
                                    dst_cur = dst_offset + (
                                        burst_len + dst_stride)\
                                              * param.get("cp_align_len")\
                                              * num_nb
                                    res_cur = res_offset + (
                                        burst_len + src_stride)\
                                              * param.get("cp_align_len")\
                                              * num_nb
                                    tvm_ib.emit(
                                        tvm.call_extern(
                                            dst.dtype,
                                            "copy_ubuf_to_gm",
                                            dst.access_ptr(
                                                'w',
                                                offset=dst_cur),
                                            data_res.access_ptr(
                                                "r",
                                                offset=res_cur),
                                            0, 1, burst_len,
                                            0, 0))


def _get_branch_0231_core(ub_bytes, core_divide, c_i, cp_align_len):
    ub_bytes_core = ub_bytes // core_divide
    ub_half_core = ub_bytes_core // 2
    num_block_in_ub_half_core = ub_half_core // 32

    if c_i <= num_block_in_ub_half_core:
        return "more_row_ir_0231"
    else:
        num_block_ci = c_i + _ceil_div(c_i, cp_align_len)
        num_block_in_ub_core = ub_bytes_core // 32
        if num_block_ci <= num_block_in_ub_core:
            return "one_row_ir_0231"
        else:
            return "split_row_ir_0231"


def _get_branch_0231(src_shape, dtype):
    """
    judge ir node builder branch when perm is [0, 2, 3, 1]

    """
    device_core_num = AICORE_NUM
    c_i = src_shape[1]
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    num_block_in_ub_half = ub_half // 32

    shape_ele = functools_reduce(lambda x, y: x*y, src_shape[:])
    shape_bytes = shape_ele*float_size
    ub_bytes_group = ub_bytes*device_core_num
    ub_half_group = ub_half*device_core_num

    no_divide = 1
    core_divide = 8
    if c_i <= num_block_in_ub_half:
        if shape_bytes < ub_half_group:
            branch = _get_branch_0231_core(ub_bytes, core_divide,
                                           c_i, cp_align_len)
            return branch, core_divide
        else:
            return "more_row_ir_0231", no_divide
    else:
        if shape_bytes < ub_bytes_group:
            branch = _get_branch_0231_core(ub_bytes, core_divide,
                                           c_i, cp_align_len)
            return branch, core_divide
        else:
            num_block_ci = c_i + _ceil_div(c_i, cp_align_len)
            num_block_in_ub = ub_bytes // 32
            if num_block_ci <= num_block_in_ub:
                return "one_row_ir_0231", no_divide
            else:
                return "split_row_ir_0231", no_divide


def _get_branch_0312(src_shape, dtype):
    """
    judge ir node builder branch when perm is [0, 3, 1, 2]

    """
    _, h_i, w_i, c_i = src_shape
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    num_row = h_i*w_i
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    dim_bytes = num_row*cp_align_len*float_size
    actual_row_len = min(cp_align_len, c_i)
    one_row_bytes = _ceil_fill(num_row, cp_align_len)*(actual_row_len + 1)\
                    * float_size
    if dim_bytes <= ub_half:
        return "more_dim_0312"
    else:
        if one_row_bytes <= ub_bytes:
            if c_i >= cp_align_len:
                return "one_dim_0312"
            else:
                return "one_dim_0312_small"
        else:
            if c_i >= cp_align_len:
                return "split_dim_0312"
            else:
                return "split_dim_0312_small"


# pylint: disable=locally-disabled,too-many-return-statements
def _get_branch_10(src_shape, dtype):
    """
    judge ir node builder branch when perm is [1, 0]

    """
    num, col_len, row_len = src_shape
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size
    two_dim_ele = col_len*row_len
    two_dim_ele_align = _ceil_fill(two_dim_ele, cp_align_len)
    row_len_align = _ceil_fill(row_len, cp_align_len)
    ub_ele_small = (ub_bytes - 32*cp_align_len) // 2 // float_size

    shape_ele = num*col_len*row_len
    ub_ele_group = ub_ele*device_core_num
    no_divide = 1

    if shape_ele < ub_ele_group:
        core_divide = 8
        ub_ele_core = ub_ele // core_divide
        ub_ele_small_core = ub_ele_small // core_divide
        if two_dim_ele_align <= ub_ele_core:
            return "more_two_dim", core_divide
        elif col_len * cp_align_len <= ub_ele_core:
            return "more_dim", core_divide
        elif row_len_align * cp_align_len <= ub_ele_small_core:
            return "split_dim", core_divide
        else:
            return "large_two_dim", core_divide
    else:
        if two_dim_ele_align <= ub_ele:
            return "more_two_dim", no_divide
        elif col_len * cp_align_len <= ub_ele:
            return "more_dim", no_divide
        elif row_len_align * cp_align_len <= ub_ele_small:
            return "split_dim", no_divide
        else:
            return "large_two_dim", no_divide


def _check_branch_10(src_shape, dtype):
    """
    judge ir node builder branch when perm is [1, 0]

    """
    num, col_len, row_len = src_shape
    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size
    two_dim_ele = col_len*row_len
    two_dim_ele_align = _ceil_fill(two_dim_ele, cp_align_len)
    row_len_align = _ceil_fill(row_len, cp_align_len)
    ub_ele_small = (ub_bytes - 32*cp_align_len) // 2 // float_size

    if two_dim_ele_align <= ub_ele:
        return "more_two_dim"
    elif col_len*cp_align_len <= ub_ele:
        return "more_dim"
    elif row_len_align*cp_align_len <= ub_ele_small:
        return "split_dim"
    else:
        return "large_two_dim"


def _check_two_dim(perm, dtype):
    """
    judge whether to use branch of two dim

    """
    if dtype != "float16" and dtype != "float32"\
            and dtype != "int32" and dtype != "int8":
        return False
    if len(perm) < 2:
        return False
    len_p = len(perm)

    if perm[-1] == (len_p - 2) and perm[-2] == (len_p - 1):
        for i in range(0, len_p - 2):
            if perm[i] != i:
                return False
        return True
    if list(perm) == [1, 2, 0]:
        return True

    return False


def _update_shape_10(shape, perm):
    """
    update shape for two dim scene

    """
    len_p = len(perm)
    shape_new = []
    if perm[-1] == (len_p - 2) and perm[-2] == (len_p - 1):
        dim_zero = 1
        for i in range(len_p - 2):
            dim_zero = dim_zero * shape[i]
        shape_new.append(dim_zero)
        shape_new.append(shape[-2])
        shape_new.append(shape[-1])
    elif list(perm) == [1, 2, 0]:
        shape_new.append(1)
        shape_new.append(shape[0])
        shape_new.append(shape[1] * shape[2])

    return shape_new


def _check_shape_102(shape, perm, dtype):
    """
    check whether branch shape 102 scene

    """
    if dtype != "float16" and dtype != "float32":
        return False

    if list(perm) != [0, 2, 1, 3]:
        return False

    if shape[0] != 1:
        return False

    ub_bytes = UB_SIZE_B - 32
    ub_half = ub_bytes // 2
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = ub_half // float_size
    shape_ele = functools_reduce(lambda x, y: x*y, shape[:])
    if shape_ele < ub_ele and shape[-1] < cp_align_len:
        return True

    return False


def _get_max_mod(a, b):
    """
    function of getting max common divisor

    """
    if b > a:
        temp = a
        a = b
        b = temp

    c = b
    while a % b != 0:
        c = a % b
        a = b
        b = c

    return c


def _get_min_mul(a, b):
    """
    function of getting min common multiple

    """
    mod = _get_max_mod(a, b)
    res = (a*b)//mod

    return res


def _get_row_zu(row_out, dtype):
    """
    function of getting row group

    """
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    row_mod = row_out % cp_align_len
    row_zu = _get_min_mul(cp_align_len, row_mod) // row_mod

    return row_zu


def _check_sp_0312_fp32(shape_nhwc, dtype):
    """
    check whether 0312 float32 special branch

    """
    if dtype != "float32":
        return False

    n_i, h_i, w_i, c_i = shape_nhwc

    device_core_num = AICORE_NUM
    if device_core_num != 32:
        return False

    if n_i > device_core_num:
        return False

    if n_i < device_core_num:
        if device_core_num % n_i > 0:
            return False

    if h_i*w_i % 256 > 0:
        return False

    if n_i < device_core_num:
        flag = device_core_num // n_i
        hw_new = h_i*w_i // flag
        if hw_new % 256 > 0:
            return False

    if c_i == 19:
        return True

    return False


def _check_sp_0231_fp32(shape_nchw, dtype):
    """
    check whether 0231 float32 special branch

    """
    if dtype != "float32":
        return False

    n_i, c_i, h_i, w_i = shape_nchw

    device_core_num = AICORE_NUM
    if device_core_num != 32:
        return False

    if n_i > device_core_num:
        return False

    if n_i < device_core_num:
        if device_core_num % n_i > 0:
            return False

    if h_i * w_i % 256 > 0:
        return False

    if n_i < device_core_num:
        flag = device_core_num // n_i
        hw_new = h_i * w_i // flag
        if hw_new % 256 > 0:
            return False

    if c_i == 19:
        return True

    return False


def _update_shape_for_notchange_last(shape, perm):
    """
    update the shape and perm for not change last axis scene

    """
    if len(perm) < 2:
        return shape, perm

    len_p = len(perm)
    list_range = list(range(len_p))
    if list(perm) == list_range:
        perm_up = [0]
        value_all = functools_reduce(lambda x, y: x*y, shape[:])
        shape_up = [value_all]
        return shape_up, perm_up

    flag = len_p - 1
    for i, perm_i in enumerate(reversed(perm)):
        if (i + perm_i) != (len_p - 1):
            flag = i
            break

    diff_loc = len_p - flag - 1
    same_loc = diff_loc + 1

    shape_up = []
    perm_up = []
    for i, (shape_i, perm_i) in enumerate(zip(shape, perm)):
        if i <= diff_loc:
            shape_up.append(shape_i)
            perm_up.append(perm_i)

    perm_up.append(same_loc)
    value_last = functools_reduce(lambda x, y: x*y, shape[same_loc:])
    shape_up.append(value_last)

    return shape_up, perm_up


def _check_two_permute_align_fp16(shape, perm, dtype):
    """
    check whether two permute align fp16

    """
    if dtype != "float16":
        return False

    if perm != [0, 2, 1]:
        return False

    _, col_len, row_len = shape

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if col_len % cp_align_len == 0 and row_len % cp_align_len == 0:
        return True

    return False


def _update_shape_perm(shape, perm):
    """
    function of updating shape and perm for two permute scene

    """
    if perm == [0, 2, 1]:
        return shape, perm

    n_i = shape[0]

    if perm == [0, 2, 3, 1]:
        col_len = shape[1]
        row_len = shape[2] * shape[3]
    elif perm == [0, 3, 1, 2]:
        col_len = shape[1] * shape[2]
        row_len = shape[3]
    elif perm == [1, 0]:
        n_i = 1
        col_len = shape[0]
        row_len = shape[1]
    elif perm == [0, 1, 3, 2]:
        n_i = shape[0] * shape[1]
        col_len = shape[2]
        row_len = shape[3]
    elif perm == [0, 1, 2, 4, 3]:
        n_i = shape[0] * shape[1] * shape[2]
        col_len = shape[3]
        row_len = shape[4]
    elif perm == [2, 0, 1]:
        n_i = 1
        col_len = shape[0] * shape[1]
        row_len = shape[2]
    elif perm == [0, 2, 3, 4, 1]:
        col_len = shape[1]
        row_len = shape[2] * shape[3] * shape[4]
    elif perm == [0, 4, 1, 2, 3]:
        col_len = shape[1] * shape[2] * shape[3]
        row_len = shape[4]

    shape_new = [n_i, col_len, row_len]
    perm_new = [0, 2, 1]

    return shape_new, perm_new


def _choose_branch_two_permute_align_fp16(shape, dtype):
    """
    choose which branch in two permute align fp16

    """
    n_i, col_len, row_len = shape

    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256
    dim_ele = col_len * row_len

    device_core_num = AICORE_NUM

    if dim_ele <= ub_ele:
        return "small"
    elif col_len * cp_align_len <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif col_len * cp_align_len <= ub_ele:
        return "split_row"
    elif cp_align_len * row_len <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif cp_align_len * row_len <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _check_two_col_align_fp16(shape, perm, dtype):
    """
    check whether two col align fp16

    """
    if dtype != "float16":
        return False

    if perm != [0, 2, 1]:
        return False

    _, col_len, row_len = shape

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if col_len % cp_align_len == 0 and row_len % cp_align_len > 0:
        return True

    return False


def _choose_branch_two_col_align_fp16(shape, dtype):
    """
    choose which branch in two col align fp16

    """
    n_i, col_len, row_len = shape

    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    row_len_align = _ceil_fill(row_len, cp_align_len)
    dim_ele = col_len * row_len_align
    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16

    device_core_num = AICORE_NUM

    little_ele = _ceil_fill(col_len * row_len, cp_align_len)

    if little_ele * 16 <= ub_ele:
        return "little"
    elif dim_ele <= ub_ele:
        return "small"
    elif cp_align_len * row_len_align <= ub_ele\
            and new_space_ele_split_col <= ub_ele\
            and n_i < device_core_num:
        return "split_col_new_fencore"
    elif cp_align_len * row_len_align <= ub_ele\
            and new_space_ele_split_col <= ub_ele:
        return "split_col_new"
    elif col_len * cp_align_len <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif col_len * cp_align_len <= ub_ele:
        return "split_row"
    elif cp_align_len * row_len_align <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif cp_align_len * row_len_align <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _check_two_row_align_fp16(shape, perm, dtype):
    """
    check whether two row align fp16

    """
    if dtype != "float16":
        return False

    if perm != [0, 2, 1]:
        return False

    _, col_len, row_len = shape

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if col_len % cp_align_len > 0 and row_len % cp_align_len == 0:
        return True

    return False


def _choose_branch_two_row_align_fp16(shape, dtype):
    """
    choose which branch in two row align fp16

    """
    n_i, col_len, row_len = shape

    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    col_len_align = _ceil_fill(col_len, cp_align_len)
    dim_ele = col_len_align * row_len

    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16

    device_core_num = AICORE_NUM

    little_ele = _ceil_fill(col_len * row_len, cp_align_len)

    if list(shape) == [1, 21, 880] and col_len_align * cp_align_len <= ub_ele\
            and new_space_ele_split_row <= ub_ele and n_i < device_core_num\
            and little_ele * cp_align_len > ub_ele:
        return "split_row_new_fencore"

    if little_ele * 16 <= ub_ele:
        return "little"
    elif dim_ele <= ub_ele and col_len >= cp_align_len:
        return "small"
    elif col_len_align * cp_align_len <= ub_ele \
             and new_space_ele_split_row <= ub_ele \
             and n_i < device_core_num:
        return "split_row_new_fencore"
    elif col_len_align * cp_align_len <= ub_ele \
            and new_space_ele_split_row <= ub_ele:
        return "split_row_new"
    elif col_len_align * cp_align_len <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif col_len_align * cp_align_len <= ub_ele:
        return "split_row"
    elif cp_align_len * row_len <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif cp_align_len * row_len <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _check_two_not_align_fp16(shape, perm, dtype):
    """
    check whether two not align fp16

    """
    if dtype != "float16":
        return False

    if perm != [0, 2, 1]:
        return False

    n_i, col_len, row_len = shape
    device_core_num = AICORE_NUM
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if n_i > 50000 * device_core_num and col_len * row_len < 4 * cp_align_len:
        return False

    if col_len % cp_align_len > 0 and row_len % cp_align_len > 0:
        return True

    return False


def _choose_branch_two_not_align_fp16(shape, dtype):
    """
    choose which branch in two not align fp16

    """
    n_i, col_len, row_len = shape

    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 256) * 256

    col_len_align = _ceil_fill(col_len, cp_align_len)
    row_len_align = _ceil_fill(row_len, cp_align_len)
    dim_ele = _ceil_fill(col_len * row_len, 16) * 16
    new_space_ele_split_row = _ceil_fill(col_len * 16, 16) * 16
    new_space_ele_split_col = _ceil_fill(row_len * 16, 16) * 16

    true_dim_ele = col_len * row_len

    device_core_num = AICORE_NUM

    if true_dim_ele < cp_align_len:
        return "little"
    elif dim_ele <= ub_ele:
        num_dim_ub = ub_ele // dim_ele
        num_dim_group = num_dim_ub * device_core_num
        if num_dim_group <= n_i and num_dim_ub > 1:
            return "small_multidim"
        else:
            return "small"
    elif col_len_align * cp_align_len <= ub_ele \
            and new_space_ele_split_row <= ub_ele \
            and n_i < device_core_num:
        return "split_row_new_fencore"
    elif col_len_align * cp_align_len <= ub_ele\
            and new_space_ele_split_row <= ub_ele:
        return "split_row_new"
    elif row_len_align * cp_align_len <= ub_ele \
            and new_space_ele_split_col <= ub_ele \
            and n_i < device_core_num:
        return "split_col_new_fencore"
    elif row_len_align * cp_align_len <= ub_ele\
            and new_space_ele_split_col <= ub_ele:
        return "split_col_new"
    elif col_len_align * cp_align_len <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif col_len_align * cp_align_len <= ub_ele:
        return "split_row"
    elif cp_align_len * row_len_align <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif cp_align_len * row_len_align <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _check_two_fp32(perm, dtype):
    """
    check whether two fp32

    """
    if dtype != "float32":
        return False

    if perm != [0, 2, 1]:
        return False

    return True


def _choose_branch_two_fp32(shape, dtype):
    """
    choose which branch in two fp32

    """
    n_i, col_len, row_len = shape
    ub_bytes = UB_SIZE_B - 64
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    dim_ele = col_len * row_len
    dim_ele_two = col_len * row_len * 2
    dim_ele_two_align = _ceil_fill(dim_ele_two, 16)
    space_ele = dim_ele_two_align * 8

    new_space_split_row_fp32 = col_len * 8 * 2 * 8
    new_space_split_col_fp32 = row_len * 8 * 2 * 8

    device_core_num = AICORE_NUM

    if dim_ele < cp_align_len:
        return "little"
    elif space_ele <= ub_ele:
        dim_space = col_len * row_len * 2 * 8
        if dim_space < ub_ele:
            num_dim_one_core = ub_ele // dim_space
            num_dim_one_group = num_dim_one_core * device_core_num
            if num_dim_one_group <= n_i and num_dim_one_core > 1:
                return "little"
            else:
                return "small"
        else:
            return "small"
    elif new_space_split_row_fp32 <= ub_ele and n_i < device_core_num:
        return "split_row_fencore"
    elif new_space_split_row_fp32 <= ub_ele:
        return "split_row"
    elif new_space_split_col_fp32 <= ub_ele and n_i < device_core_num:
        return "split_col_fencore"
    elif new_space_split_col_fp32 <= ub_ele:
        return "split_col"
    elif n_i < device_core_num:
        return "large_fencore"
    else:
        return "large"


def _update_shape_side_one(shape):
    value_shape = functools_reduce(lambda x, y: x * y, shape[:])
    shape_new = [value_shape]
    perm_new = [0]
    shape_res_new = [value_shape]

    return shape_new, perm_new, shape_res_new


def _check_side_one(shape, perm, shape_res):
    """
    check whether side one branch

    """
    if perm == [0, 2, 1]:
        if shape[1] == 1 or shape[2] == 1:
            return _update_shape_side_one(shape)

    if perm == [1, 0, 2]:
        if shape[0] == 1 or shape[1] == 1:
            return _update_shape_side_one(shape)
        else:
            one_d = 1
            two_d = shape[0]
            three_d = shape[1]
            four_d = shape[2]
            shape_new = [one_d, two_d, three_d, four_d]
            perm_new = [0, 2, 1, 3]
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 2, 3, 1]:
        if shape[1] == 1 or shape[2] * shape[3] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 3, 1, 2]:
        if shape[1] * shape[2] == 1 or shape[3] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [1, 0]:
        if shape[0] == 1 or shape[1] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 1, 3, 2]:
        if shape[2] == 1 or shape[3] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 1, 2, 4, 3]:
        if shape[3] == 1 or shape[4] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [2, 0, 1]:
        if shape[0] * shape[1] == 1 or shape[2] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 2, 3, 4, 1]:
        if shape[1] == 1 or shape[2] * shape[3] * shape[4] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    if perm == [0, 4, 1, 2, 3]:
        if shape[1] * shape[2] * shape[3] == 1 or shape[4] == 1:
            return _update_shape_side_one(shape)
        else:
            shape_new, perm_new = _update_shape_perm(shape, perm)
            shape_res_new = _get_perm_shape(shape_new, perm_new)
            return shape_new, perm_new, shape_res_new

    return shape, perm, shape_res


def _check_0213(shape, perm, dtype):
    """
    check whether 0213 branch

    """
    if perm != [0, 2, 1, 3]:
        return False

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    device_core_num = AICORE_NUM
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    n_i, one_d, two_d, three_d = shape
    if n_i < device_core_num:
        return False

    if three_d >= cp_align_len:
        return False

    shape_ele = one_d * two_d * three_d
    if shape_ele <= cp_align_len:
        return False

    shape_ele_align = _ceil_fill(shape_ele, cp_align_len)
    if shape_ele_align < ub_ele:
        return True

    return False


def _check_0213_sp1(shape, perm, dtype):
    """
    check whether 0213 special one branch

    """
    if shape != [1, 128, 12, 64] or perm != [0, 2, 1, 3]\
            or dtype != "float16":
        return False

    device_core_num = AICORE_NUM
    if device_core_num < 2:
        return False

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // float_size // cp_align_len) * cp_align_len
    one_d, two_d, three_d, four_d = shape
    half_two = two_d // 2
    dim_ele = half_two * three_d * four_d

    if dim_ele > ub_ele:
        return False

    return True


def _check_0213_12_30_26(shape, perm, dtype):
    """
    check whether 0213 special one branch

    """
    if len(shape) != 4:
        return False

    if perm != [0, 2, 1, 3]:
        return False

    if dtype != "float16" and dtype != "float32":
        return False

    shape_sub = shape[1:]

    if shape_sub != [12, 30, 26] and shape_sub != [30, 12, 26]:
        return False

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    _, two_d, three_d, four_d = shape

    if dtype == "float16":
        split_zu = 3
        split_three = three_d // split_zu
        all_ele = two_d * split_three * four_d
        all_ele_align = _ceil_fill(all_ele, cp_align_len)
        space_ele = all_ele_align * cp_align_len

        if space_ele <= ub_ele:
            return True
    elif dtype == "float32":
        split_zu = 6
        split_three = three_d // split_zu
        all_ele = two_d * split_three * four_d * 2
        all_ele_align = _ceil_fill(all_ele, cp_align_len)
        space_ele = all_ele_align * cp_align_len

        if space_ele <= ub_ele:
            return True

    return False


def _check_0213_vec(shape, perm, dtype):
    """
    check whether 0213 vec branch

    """
    if len(shape) != 4:
        return False

    if perm != [0, 2, 1, 3] or dtype != "float16":
        return False

    one_d, two_d, three_d, four_d = shape
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size

    if four_d % cp_align_len == 0:
        return False

    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    all_ele = two_d * three_d * four_d
    small_ele = _ceil_fill(all_ele, 16) * cp_align_len
    if small_ele <= ub_ele:
        if all_ele < cp_align_len:
            return False
        return True

    if two_d > three_d:
        all_ele = three_d * four_d
        mid_two_ele = _ceil_fill(all_ele, 16) * cp_align_len
        if mid_two_ele <= ub_ele:
            two_ub = ub_ele // mid_two_ele
            move_len = four_d * two_ub
            if move_len >= cp_align_len:
                return True
            else:
                change_len = two_d * four_d
                mid_one_ele = _ceil_fill(change_len, 16) * cp_align_len
                if mid_one_ele <= ub_ele:
                    if change_len < cp_align_len:
                        return False
                    return True

    else:
        all_ele = two_d * four_d
        mid_one_ele = _ceil_fill(all_ele, 16) * cp_align_len
        if mid_one_ele <= ub_ele:
            if all_ele >= cp_align_len:
                return True
            else:
                change_ele = three_d * four_d
                mid_two_ele = _ceil_fill(change_ele, 16) * cp_align_len
                if mid_two_ele <= ub_ele:
                    two_ub = ub_ele // mid_two_ele
                    move_len = four_d * two_ub
                    if move_len < cp_align_len:
                        return False
                    return True

    return False


def _choose_branch_0213_vec(shape, dtype):
    """
    choose whether 0213 vec branch

    """
    one_d, two_d, three_d, four_d = shape
    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    small_ele = _ceil_fill(two_d * three_d * four_d, 16) * cp_align_len
    if small_ele <= ub_ele:
        return "small_ele"

    if two_d > three_d:
        all_ele = three_d * four_d
        mid_two_ele = _ceil_fill(all_ele, 16) * cp_align_len
        if mid_two_ele <= ub_ele:
            two_ub = ub_ele // mid_two_ele
            move_len = four_d * two_ub
            if move_len >= cp_align_len:
                if one_d < AICORE_NUM:
                    return "mid_two_ele_fencore"
                else:
                    return "mid_two_ele"
            else:
                change_len = two_d * four_d
                mid_one_ele = _ceil_fill(change_len, 16) * cp_align_len
                if mid_one_ele <= ub_ele:
                    if one_d < AICORE_NUM:
                        return "mid_one_ele_fencore"
                    else:
                        return "mid_one_ele"

    else:
        all_ele = two_d * four_d
        mid_one_ele = _ceil_fill(all_ele, 16) * cp_align_len
        if mid_one_ele <= ub_ele:
            if all_ele >= cp_align_len:
                if one_d < AICORE_NUM:
                    return "mid_one_ele_fencore"
                else:
                    return "mid_one_ele"
            else:
                change_ele = three_d * four_d
                mid_two_ele = _ceil_fill(change_ele, 16) * cp_align_len
                if mid_two_ele <= ub_ele:
                    two_ub = ub_ele // mid_two_ele
                    move_len = four_d * two_ub
                    if move_len >= cp_align_len:
                        if one_d < AICORE_NUM:
                            return "mid_two_ele_fencore"
                        else:
                            return "mid_two_ele"


def check_014253_sp1(shape, perm, dtype):
    """
    choose whether [1,32,2,2,851,664] [0,1,4,2,5,3] float32
    """
    if shape != [1, 32, 2, 2, 851, 664] or perm != [0, 1, 4, 2, 5, 3] \
            or dtype != "float32":
        return False

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // 128) * 128

    _, n_i, one_d, two_d, three_d, four_d = shape
    dim_space = two_d * four_d * 2 * cp_align_len
    if dim_space > ub_ele:
        return False

    if four_d % cp_align_len > 0:
        return False

    return True


def check_014253_sp2(shape, perm, dtype):
    """
    choose whether [1,32,2,2,851,664] [0,1,4,2,5,3] float16
    """
    if shape not in ([1, 32, 2, 2, 851, 664], [1, 32, 2, 2, 1702, 664],
                     [1, 32, 2, 2, 800, 600], [1, 32, 2, 2, 800, 450],
                     [1, 32, 2, 2, 1600, 600], [1, 32, 2, 2, 1600, 450],
                     [1, 32, 2, 2, 1920, 720], [1, 32, 2, 2, 960, 720]):
        return False

    if perm != [0, 1, 4, 2, 5, 3] or dtype != "float16":
        return False

    float_size = cce.cce_intrin.get_bit_len(dtype) // 8
    cp_align_len = cce_params.BLOCK_REDUCE_INT8 // float_size
    ub_bytes = UB_SIZE_B - 64
    ub_ele = (ub_bytes // 2 // float_size // cp_align_len) * cp_align_len

    _, n_i, one_d, two_d, three_d, four_d = shape
    dim_space = one_d * two_d * four_d * cp_align_len
    if dim_space > ub_ele:
        return False

    return True


# pylint: disable=locally-disabled,too-many-locals,too-many-arguments
@check_op_params(REQUIRED_INPUT, REQUIRED_OUTPUT, REQUIRED_ATTR_LIST_INT, KERNEL_NAME)
def transpose_d(input_x, output_y, perm, kernel_name="transpose_d"):
    """
    algorithm: transpose
    calculating: permute the dimensions according to perm

    Parameters
    ----------
    input_x : dict
        shape and dtype of input
    output_y: dict
        shape and dtype of output, should be same shape and type as input
    perm: list or tuple
        permutation of the dimension of tensor
    kernel_name: str
        cce kernel name, default value is "transpose_d"

    Returns
    -------
    None
    """
    shape = list(input_x.get("shape"))
    dtype = input_x.get("dtype").lower()
    _check_params(shape, perm, dtype)
    perm = list(perm)

    if list(perm) == [0, 3, 4, 1, 2]:
        perm = [0, 2, 3, 1]
        one_dim = shape[0]
        two_dim = shape[1]*shape[2]
        three_dim = shape[3]
        four_dim = shape[4]
        shape = [one_dim, two_dim, three_dim, four_dim]

    elif list(perm) == [3, 2, 0, 1]:
        if shape[3] == 1:
            one_dim = shape[0] * shape[1]
            two_dim = shape[2]
            shape = [one_dim, two_dim]
            perm = [1, 0]
        elif shape[0] == 1 and shape[2] == 1:
            one_dim = shape[1]
            two_dim = shape[3]
            shape = [one_dim, two_dim]
            perm = [1, 0]

    elif list(perm) == [0, 3, 1, 2, 4]:
        one_dim = shape[0]
        two_dim = shape[1] * shape[2]
        three_dim = shape[3]
        four_dim = shape[4]
        shape = [one_dim, two_dim, three_dim, four_dim]
        perm = [0, 2, 1, 3]

    elif list(perm) == [1, 2, 3, 0] and shape[1] == 1 and shape[3] == 1:
        one_dim = shape[0]
        two_dim = shape[2]
        shape = [one_dim, two_dim]
        perm = [1, 0]

    elif list(perm) == [3, 2, 1, 0] and shape[1] == 1 and shape[3] == 1:
        one_dim = shape[0]
        two_dim = shape[2]
        shape = [one_dim, two_dim]
        perm = [1, 0]

    elif list(perm) == [3, 0, 2, 1] and shape[0] == 1 and shape[2] == 1:
        one_dim = shape[1]
        two_dim = shape[3]
        shape = [one_dim, two_dim]
        perm = [1, 0]

    elif list(perm) == [2, 3, 1, 0] and shape[0] == 1:
        one_dim = shape[1]
        two_dim = shape[2]
        three_dim = shape[3]
        shape = [one_dim, two_dim, three_dim]
        perm = [1, 2, 0]
    # this branch only for float32 and cloud
    elif list(perm) == [0, 4, 1, 2, 3] and dtype == "float32" and \
        cce.cce_conf.intrinsic_check_support("Intrinsic_vconv", "f322s32f") and \
        not cce.cce_conf.api_check_support("Intrinsic_vbi", "float16") and \
        list(shape) in (
            [1, 15, 63, 63, 224], [1, 15, 63, 63, 192],
            [1, 15, 63, 63, 160], [1, 15, 63, 63, 128],
            [1, 7, 31, 31, 224], [1, 7, 31, 31, 192],
            [1, 7, 31, 31, 160], [1, 7, 31, 31, 128]):
        one_dim = shape[1] * shape[2] * shape[3]
        two_dim = shape[4]
        shape = [one_dim, two_dim]
        hwc_2_chw(shape, dtype, kernel_name)
        return True

    shape_res = _get_perm_shape(shape, perm)
    shape, perm, shape_res = _check_side_one(shape, perm, shape_res)

    if _check_two_permute_align_fp16(shape, perm, dtype):
        branch_per = _choose_branch_two_permute_align_fp16(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_permute_align_small_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_split_row_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_split_col_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_large_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_split_row_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_split_col_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_permute_align_large_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_col_align_fp16(shape, perm, dtype):
        branch_per = _choose_branch_two_col_align_fp16(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "little":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_little_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_small_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_row_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_new":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_col_fp16_new(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_col_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_large_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_row_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_new_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_col_fp16_new_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_split_col_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_col_align_large_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_row_align_fp16(shape, perm, dtype):
        branch_per = _choose_branch_two_row_align_fp16(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "little":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_row_align_little_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_row_align_small_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_new":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_row_fp16_new(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_row_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_col_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_large_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_new_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_row_fp16_new_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_row_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_split_col_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_row_align_large_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_not_align_fp16(shape, perm, dtype):
        branch_per = _choose_branch_two_not_align_fp16(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "little":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_little_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_small_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small_multidim":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_small_multidim_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_new":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_row_fp16_new(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_new":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_col_fp16_new(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_row_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_col_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_not_align_large_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_new_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_row_fp16_new_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_new_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_col_fp16_new_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_row_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_split_col_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _two_not_align_large_fp16_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_fp32(perm, dtype):
        branch_per = _choose_branch_two_fp32(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch_per == "little":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_little_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "small":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_small_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_split_row_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_split_col_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "large":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_large_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_row_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_split_row_fp32_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch_per == "split_col_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_split_col_fp32_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _two_large_fp32_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_0213_sp1(shape, perm, dtype):
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        res = tvm.extern(shape_res, [data],
                         lambda ins, outs: _move_0213_sp1(
                             outs[0], ins[0]),
                         name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)
    elif _check_0213_12_30_26(shape, perm, dtype):
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if dtype == "float16":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_12_30_26_fp16(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif dtype == "float32":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_12_30_26_fp32(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_0213_vec(shape, perm, dtype):
        branch = _choose_branch_0213_vec(shape, dtype)
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        if branch == "small_ele":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_small(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch == "mid_two_ele":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_mid_two(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch == "mid_two_ele_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_mid_two_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch == "mid_one_ele":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_mid_one(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)
        elif branch == "mid_one_ele_fencore":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _move_0213_vec_mid_one_fencore(
                                 outs[0], ins[0]),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_0213(shape, perm, dtype):
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        res = tvm.extern(shape_res, [data],
                         lambda ins, outs: _move_0213_small_dim(
                             outs[0], ins[0]),
                         name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif _check_two_dim(perm, dtype):
        shape_new = _update_shape_10(shape, perm)
        perm_new = [0, 2, 1]
        shape_res = _get_perm_shape(shape_new, perm_new)
        data = tvm.placeholder(shape_new, dtype=dtype, name="data")
        branch_10, core_divide = _get_branch_10(shape_new, dtype)

        if branch_10 == "more_two_dim":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _more_two_dim_ir_10(outs[0],
                                                                   ins[0],
                                                                   core_divide),
                             name="res", dtype=dtype)
        elif branch_10 == "more_dim":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _more_dim_ir_10(outs[0],
                                                               ins[0],
                                                               core_divide),
                             name="res", dtype=dtype)
        elif branch_10 == "split_dim":
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs: _split_dim_ir_10(outs[0],
                                                                ins[0],
                                                                core_divide),
                             name="res", dtype=dtype)
        else:
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _large_two_dim_ir_10(outs[0], ins[0],
                                                  core_divide),
                             name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)
    elif _check_shape_102(shape, perm, dtype):
        one_dim = shape[1]
        two_dim = shape[2]
        three_dim = shape[3]
        shape_new = [one_dim, two_dim, three_dim]
        perm_new = [1, 0, 2]
        shape_res_new = _get_perm_shape(shape_new, perm_new)

        data = tvm.placeholder(shape_new, dtype=dtype, name="data")
        res = tvm.extern(shape_res_new, [data],
                         lambda ins, outs: _small_shape_ir_102(outs[0],
                                                               ins[0]),
                         name="res", dtype=dtype)
        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif list(perm) == [0, 2, 3, 1]:
        if _check_sp_0231_fp32(shape, dtype):
            row_len = shape[1]
            row_zu = _get_row_zu(row_len, dtype)
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _mov_0231_256_vconv_fp32(outs[0], ins[0], row_zu),
                             name="res", dtype=dtype)
        else:
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            branch_0231, core_divide = _get_branch_0231(shape, dtype)
            if branch_0231 == "more_row_ir_0231":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs:
                                 _more_row_ir_0231(outs[0], ins[0],
                                                   core_divide),
                                 name="res", dtype=dtype)
            elif branch_0231 == "one_row_ir_0231":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs:
                                 _one_row_ir_0231(outs[0], ins[0],
                                                  core_divide),
                                 name="res", dtype=dtype)
            else:
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs:
                                 _split_row_ir_0231(outs[0], ins[0],
                                                    core_divide),
                                 name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)
    elif list(perm) == [0, 3, 1, 2]:
        if _check_sp_0312_fp32(shape, dtype):
            row_len = shape[3]
            row_zu = _get_row_zu(row_len, dtype)
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            res = tvm.extern(shape_res, [data],
                             lambda ins, outs:
                             _mov_0312_256_vconv_fp32(outs[0], ins[0], row_zu),
                             name="res", dtype=dtype)
        else:
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            branch_0312 = _get_branch_0312(shape, dtype)

            if branch_0312 == "more_dim_0312":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _more_dim_ir_0312(outs[0],
                                                                     ins[0]),
                                 name="res", dtype=dtype)
            elif branch_0312 == "one_dim_0312":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _one_dim_ir_0312(outs[0],
                                                                    ins[0]),
                                 name="res", dtype=dtype)
            elif branch_0312 == "one_dim_0312_small":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _one_dim_ir_0312_small(
                                     outs[0],
                                     ins[0]),
                                 name="res", dtype=dtype)
            elif branch_0312 == "split_dim_0312":
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _split_dim_ir_0312(outs[0],
                                                                      ins[0]),
                                 name="res", dtype=dtype)
            else:
                res = tvm.extern(shape_res, [data],
                                 lambda ins, outs: _split_dim_ir_0312_small(
                                     outs[0],
                                     ins[0]),
                                 name="res", dtype=dtype)

        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif check_014253_sp1(shape, perm, dtype):
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        res = tvm.extern(shape_res, [data],
                         lambda ins, outs: _move_014253_sp1(outs[0],
                                                            ins[0]),
                         name="res", dtype=dtype)
        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    elif check_014253_sp2(shape, perm, dtype):
        data = tvm.placeholder(shape, dtype=dtype, name="data")
        res = tvm.extern(shape_res, [data],
                         lambda ins, outs: _move_014253_sp2(outs[0],
                                                            ins[0]),
                         name="res", dtype=dtype)
        tensor_list = [data, res]
        sch = tvm.create_schedule(res.op)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

    else:
        num = 0
        total_size = []
        if len(shape) - 1 == perm[-1]:
            shape_up, perm_up = _update_shape_for_notchange_last(shape, perm)
            shape_res_up = _get_perm_shape(shape_up, perm_up)
            data = tvm.placeholder(shape_up, dtype=dtype, name="data")
            sch, tensor_list = _tranpose_notchange_last(data, shape_res_up,
                                                        perm_up, dtype)
        elif _add_last_axis(shape, perm, dtype):
            shape_update = list(shape)
            shape_res_update = list(shape_res)
            perm_update = list(perm)
            shape_update.append(1)
            shape_res_update.append(1)
            perm_update.append(len(shape))
            data = tvm.placeholder(shape_update, dtype=dtype, name="data")
            sch, tensor_list = _tranpose_notchange_last(data, shape_res_update,
                                                        perm_update, dtype)
        else:
            data = tvm.placeholder(shape, dtype=dtype, name="data")
            sch, tensor_list, num, total_size =\
                _transpose_change_last(data, shape, shape_res, perm, dtype)

        with build_config:
            tvm.build(sch, tensor_list, "cce", name=kernel_name)

        if num > 0:
            workspace_dict = {"workspace": {"num": num, "size": total_size}}
            _write_code(workspace_dict, "kernel_meta/" + kernel_name + ".json")
